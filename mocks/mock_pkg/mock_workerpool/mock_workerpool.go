// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/netapp/trident/pkg/workerpool/types (interfaces: Pool,MultiPool,Config)
//
// Generated by this command:
//
//	mockgen -destination=../../../mocks/mock_pkg/mock_workerpool/mock_workerpool.go -package=mock_workerpool github.com/netapp/trident/pkg/workerpool/types Pool,MultiPool,Config
//

// Package mock_workerpool is a generated GoMock package.
package mock_workerpool

import (
	context "context"
	reflect "reflect"
	time "time"

	types "github.com/netapp/trident/pkg/workerpool/types"
	gomock "go.uber.org/mock/gomock"
)

// MockPool is a mock of Pool interface.
type MockPool struct {
	ctrl     *gomock.Controller
	recorder *MockPoolMockRecorder
	isgomock struct{}
}

// MockPoolMockRecorder is the mock recorder for MockPool.
type MockPoolMockRecorder struct {
	mock *MockPool
}

// NewMockPool creates a new mock instance.
func NewMockPool(ctrl *gomock.Controller) *MockPool {
	mock := &MockPool{ctrl: ctrl}
	mock.recorder = &MockPoolMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPool) EXPECT() *MockPoolMockRecorder {
	return m.recorder
}

// Cap mocks base method.
func (m *MockPool) Cap() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cap")
	ret0, _ := ret[0].(int)
	return ret0
}

// Cap indicates an expected call of Cap.
func (mr *MockPoolMockRecorder) Cap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cap", reflect.TypeOf((*MockPool)(nil).Cap))
}

// Free mocks base method.
func (m *MockPool) Free() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Free")
	ret0, _ := ret[0].(int)
	return ret0
}

// Free indicates an expected call of Free.
func (mr *MockPoolMockRecorder) Free() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Free", reflect.TypeOf((*MockPool)(nil).Free))
}

// IsClosed mocks base method.
func (m *MockPool) IsClosed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClosed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsClosed indicates an expected call of IsClosed.
func (mr *MockPoolMockRecorder) IsClosed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClosed", reflect.TypeOf((*MockPool)(nil).IsClosed))
}

// IsStarted mocks base method.
func (m *MockPool) IsStarted() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsStarted")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsStarted indicates an expected call of IsStarted.
func (mr *MockPoolMockRecorder) IsStarted() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsStarted", reflect.TypeOf((*MockPool)(nil).IsStarted))
}

// Running mocks base method.
func (m *MockPool) Running() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Running")
	ret0, _ := ret[0].(int)
	return ret0
}

// Running indicates an expected call of Running.
func (mr *MockPoolMockRecorder) Running() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Running", reflect.TypeOf((*MockPool)(nil).Running))
}

// Shutdown mocks base method.
func (m *MockPool) Shutdown(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Shutdown", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Shutdown indicates an expected call of Shutdown.
func (mr *MockPoolMockRecorder) Shutdown(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Shutdown", reflect.TypeOf((*MockPool)(nil).Shutdown), ctx)
}

// ShutdownWithTimeout mocks base method.
func (m *MockPool) ShutdownWithTimeout(timeout time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ShutdownWithTimeout", timeout)
	ret0, _ := ret[0].(error)
	return ret0
}

// ShutdownWithTimeout indicates an expected call of ShutdownWithTimeout.
func (mr *MockPoolMockRecorder) ShutdownWithTimeout(timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShutdownWithTimeout", reflect.TypeOf((*MockPool)(nil).ShutdownWithTimeout), timeout)
}

// Start mocks base method.
func (m *MockPool) Start(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockPoolMockRecorder) Start(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockPool)(nil).Start), ctx)
}

// Stats mocks base method.
func (m *MockPool) Stats() types.PoolStats {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stats")
	ret0, _ := ret[0].(types.PoolStats)
	return ret0
}

// Stats indicates an expected call of Stats.
func (mr *MockPoolMockRecorder) Stats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stats", reflect.TypeOf((*MockPool)(nil).Stats))
}

// Submit mocks base method.
func (m *MockPool) Submit(ctx context.Context, task func()) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Submit", ctx, task)
	ret0, _ := ret[0].(error)
	return ret0
}

// Submit indicates an expected call of Submit.
func (mr *MockPoolMockRecorder) Submit(ctx, task any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Submit", reflect.TypeOf((*MockPool)(nil).Submit), ctx, task)
}

// Waiting mocks base method.
func (m *MockPool) Waiting() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Waiting")
	ret0, _ := ret[0].(int)
	return ret0
}

// Waiting indicates an expected call of Waiting.
func (mr *MockPoolMockRecorder) Waiting() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Waiting", reflect.TypeOf((*MockPool)(nil).Waiting))
}

// MockMultiPool is a mock of MultiPool interface.
type MockMultiPool struct {
	ctrl     *gomock.Controller
	recorder *MockMultiPoolMockRecorder
	isgomock struct{}
}

// MockMultiPoolMockRecorder is the mock recorder for MockMultiPool.
type MockMultiPoolMockRecorder struct {
	mock *MockMultiPool
}

// NewMockMultiPool creates a new mock instance.
func NewMockMultiPool(ctrl *gomock.Controller) *MockMultiPool {
	mock := &MockMultiPool{ctrl: ctrl}
	mock.recorder = &MockMultiPoolMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMultiPool) EXPECT() *MockMultiPoolMockRecorder {
	return m.recorder
}

// Cap mocks base method.
func (m *MockMultiPool) Cap() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cap")
	ret0, _ := ret[0].(int)
	return ret0
}

// Cap indicates an expected call of Cap.
func (mr *MockMultiPoolMockRecorder) Cap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cap", reflect.TypeOf((*MockMultiPool)(nil).Cap))
}

// Free mocks base method.
func (m *MockMultiPool) Free() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Free")
	ret0, _ := ret[0].(int)
	return ret0
}

// Free indicates an expected call of Free.
func (mr *MockMultiPoolMockRecorder) Free() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Free", reflect.TypeOf((*MockMultiPool)(nil).Free))
}

// FreeByIndex mocks base method.
func (m *MockMultiPool) FreeByIndex(idx int) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FreeByIndex", idx)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FreeByIndex indicates an expected call of FreeByIndex.
func (mr *MockMultiPoolMockRecorder) FreeByIndex(idx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FreeByIndex", reflect.TypeOf((*MockMultiPool)(nil).FreeByIndex), idx)
}

// IsClosed mocks base method.
func (m *MockMultiPool) IsClosed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClosed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsClosed indicates an expected call of IsClosed.
func (mr *MockMultiPoolMockRecorder) IsClosed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClosed", reflect.TypeOf((*MockMultiPool)(nil).IsClosed))
}

// IsStarted mocks base method.
func (m *MockMultiPool) IsStarted() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsStarted")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsStarted indicates an expected call of IsStarted.
func (mr *MockMultiPoolMockRecorder) IsStarted() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsStarted", reflect.TypeOf((*MockMultiPool)(nil).IsStarted))
}

// Running mocks base method.
func (m *MockMultiPool) Running() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Running")
	ret0, _ := ret[0].(int)
	return ret0
}

// Running indicates an expected call of Running.
func (mr *MockMultiPoolMockRecorder) Running() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Running", reflect.TypeOf((*MockMultiPool)(nil).Running))
}

// RunningByIndex mocks base method.
func (m *MockMultiPool) RunningByIndex(idx int) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunningByIndex", idx)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RunningByIndex indicates an expected call of RunningByIndex.
func (mr *MockMultiPoolMockRecorder) RunningByIndex(idx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunningByIndex", reflect.TypeOf((*MockMultiPool)(nil).RunningByIndex), idx)
}

// Shutdown mocks base method.
func (m *MockMultiPool) Shutdown(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Shutdown", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Shutdown indicates an expected call of Shutdown.
func (mr *MockMultiPoolMockRecorder) Shutdown(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Shutdown", reflect.TypeOf((*MockMultiPool)(nil).Shutdown), ctx)
}

// ShutdownWithTimeout mocks base method.
func (m *MockMultiPool) ShutdownWithTimeout(timeout time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ShutdownWithTimeout", timeout)
	ret0, _ := ret[0].(error)
	return ret0
}

// ShutdownWithTimeout indicates an expected call of ShutdownWithTimeout.
func (mr *MockMultiPoolMockRecorder) ShutdownWithTimeout(timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShutdownWithTimeout", reflect.TypeOf((*MockMultiPool)(nil).ShutdownWithTimeout), timeout)
}

// Start mocks base method.
func (m *MockMultiPool) Start(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockMultiPoolMockRecorder) Start(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockMultiPool)(nil).Start), ctx)
}

// Stats mocks base method.
func (m *MockMultiPool) Stats() types.PoolStats {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stats")
	ret0, _ := ret[0].(types.PoolStats)
	return ret0
}

// Stats indicates an expected call of Stats.
func (mr *MockMultiPoolMockRecorder) Stats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stats", reflect.TypeOf((*MockMultiPool)(nil).Stats))
}

// Submit mocks base method.
func (m *MockMultiPool) Submit(ctx context.Context, task func()) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Submit", ctx, task)
	ret0, _ := ret[0].(error)
	return ret0
}

// Submit indicates an expected call of Submit.
func (mr *MockMultiPoolMockRecorder) Submit(ctx, task any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Submit", reflect.TypeOf((*MockMultiPool)(nil).Submit), ctx, task)
}

// Waiting mocks base method.
func (m *MockMultiPool) Waiting() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Waiting")
	ret0, _ := ret[0].(int)
	return ret0
}

// Waiting indicates an expected call of Waiting.
func (mr *MockMultiPoolMockRecorder) Waiting() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Waiting", reflect.TypeOf((*MockMultiPool)(nil).Waiting))
}

// WaitingByIndex mocks base method.
func (m *MockMultiPool) WaitingByIndex(idx int) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WaitingByIndex", idx)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WaitingByIndex indicates an expected call of WaitingByIndex.
func (mr *MockMultiPoolMockRecorder) WaitingByIndex(idx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitingByIndex", reflect.TypeOf((*MockMultiPool)(nil).WaitingByIndex), idx)
}

// MockConfig is a mock of Config interface.
type MockConfig struct {
	ctrl     *gomock.Controller
	recorder *MockConfigMockRecorder
	isgomock struct{}
}

// MockConfigMockRecorder is the mock recorder for MockConfig.
type MockConfigMockRecorder struct {
	mock *MockConfig
}

// NewMockConfig creates a new mock instance.
func NewMockConfig(ctrl *gomock.Controller) *MockConfig {
	mock := &MockConfig{ctrl: ctrl}
	mock.recorder = &MockConfigMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConfig) EXPECT() *MockConfigMockRecorder {
	return m.recorder
}

// Copy mocks base method.
func (m *MockConfig) Copy() types.Config {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Copy")
	ret0, _ := ret[0].(types.Config)
	return ret0
}

// Copy indicates an expected call of Copy.
func (mr *MockConfigMockRecorder) Copy() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Copy", reflect.TypeOf((*MockConfig)(nil).Copy))
}

// PoolConfig mocks base method.
func (m *MockConfig) PoolConfig() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PoolConfig")
}

// PoolConfig indicates an expected call of PoolConfig.
func (mr *MockConfigMockRecorder) PoolConfig() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PoolConfig", reflect.TypeOf((*MockConfig)(nil).PoolConfig))
}
