// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/netapp/trident/pkg/eventbus/types (interfaces: EventBus,EventBusWithOptions,EventBusWithHooks,EventBusWithMetrics,EventBusHooksOptions,EventBusMetricsOptions,EventBusHooksMetrics,EventBusHooksMetricsOptions)
//
// Generated by this command:
//
//	mockgen -destination=../../../mocks/mock_pkg/mock_eventbus/mock_eventbus.go -package=mock_eventbus github.com/netapp/trident/pkg/eventbus/types EventBus,EventBusWithOptions,EventBusWithHooks,EventBusWithMetrics,EventBusHooksOptions,EventBusMetricsOptions,EventBusHooksMetrics,EventBusHooksMetricsOptions
//

// Package mock_eventbus is a generated GoMock package.
package mock_eventbus

import (
	context "context"
	reflect "reflect"
	time "time"

	types "github.com/netapp/trident/pkg/eventbus/types"
	gomock "go.uber.org/mock/gomock"
)

// MockEventBus is a mock of EventBus interface.
type MockEventBus[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockEventBusMockRecorder[T]
	isgomock struct{}
}

// MockEventBusMockRecorder is the mock recorder for MockEventBus.
type MockEventBusMockRecorder[T any] struct {
	mock *MockEventBus[T]
}

// NewMockEventBus creates a new mock instance.
func NewMockEventBus[T any](ctrl *gomock.Controller) *MockEventBus[T] {
	mock := &MockEventBus[T]{ctrl: ctrl}
	mock.recorder = &MockEventBusMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventBus[T]) EXPECT() *MockEventBusMockRecorder[T] {
	return m.recorder
}

// Close mocks base method.
func (m *MockEventBus[T]) Close(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockEventBusMockRecorder[T]) Close(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockEventBus[T])(nil).Close), ctx)
}

// GetWorkerPoolStats mocks base method.
func (m *MockEventBus[T]) GetWorkerPoolStats() (int, int, int) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkerPoolStats")
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(int)
	return ret0, ret1, ret2
}

// GetWorkerPoolStats indicates an expected call of GetWorkerPoolStats.
func (mr *MockEventBusMockRecorder[T]) GetWorkerPoolStats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkerPoolStats", reflect.TypeOf((*MockEventBus[T])(nil).GetWorkerPoolStats))
}

// HasSubscription mocks base method.
func (m *MockEventBus[T]) HasSubscription() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSubscription")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSubscription indicates an expected call of HasSubscription.
func (mr *MockEventBusMockRecorder[T]) HasSubscription() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSubscription", reflect.TypeOf((*MockEventBus[T])(nil).HasSubscription))
}

// IsClosed mocks base method.
func (m *MockEventBus[T]) IsClosed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClosed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsClosed indicates an expected call of IsClosed.
func (mr *MockEventBusMockRecorder[T]) IsClosed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClosed", reflect.TypeOf((*MockEventBus[T])(nil).IsClosed))
}

// Publish mocks base method.
func (m *MockEventBus[T]) Publish(ctx context.Context, event T) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Publish", ctx, event)
}

// Publish indicates an expected call of Publish.
func (mr *MockEventBusMockRecorder[T]) Publish(ctx, event any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockEventBus[T])(nil).Publish), ctx, event)
}

// Subscribe mocks base method.
func (m *MockEventBus[T]) Subscribe(fn types.SubscriptionFunc[T], opts ...types.SubscribeOption[T]) (types.SubscriptionID, error) {
	m.ctrl.T.Helper()
	varargs := []any{fn}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(types.SubscriptionID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockEventBusMockRecorder[T]) Subscribe(fn any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{fn}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockEventBus[T])(nil).Subscribe), varargs...)
}

// Unsubscribe mocks base method.
func (m *MockEventBus[T]) Unsubscribe(id types.SubscriptionID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unsubscribe", id)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockEventBusMockRecorder[T]) Unsubscribe(id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockEventBus[T])(nil).Unsubscribe), id)
}

// UnsubscribeAll mocks base method.
func (m *MockEventBus[T]) UnsubscribeAll() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UnsubscribeAll")
}

// UnsubscribeAll indicates an expected call of UnsubscribeAll.
func (mr *MockEventBusMockRecorder[T]) UnsubscribeAll() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsubscribeAll", reflect.TypeOf((*MockEventBus[T])(nil).UnsubscribeAll))
}

// WaitAsync mocks base method.
func (m *MockEventBus[T]) WaitAsync() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WaitAsync")
}

// WaitAsync indicates an expected call of WaitAsync.
func (mr *MockEventBusMockRecorder[T]) WaitAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitAsync", reflect.TypeOf((*MockEventBus[T])(nil).WaitAsync))
}

// WithAsync mocks base method.
func (m *MockEventBus[T]) WithAsync() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithAsync")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithAsync indicates an expected call of WithAsync.
func (mr *MockEventBusMockRecorder[T]) WithAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithAsync", reflect.TypeOf((*MockEventBus[T])(nil).WithAsync))
}

// MockEventBusWithOptions is a mock of EventBusWithOptions interface.
type MockEventBusWithOptions[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockEventBusWithOptionsMockRecorder[T]
	isgomock struct{}
}

// MockEventBusWithOptionsMockRecorder is the mock recorder for MockEventBusWithOptions.
type MockEventBusWithOptionsMockRecorder[T any] struct {
	mock *MockEventBusWithOptions[T]
}

// NewMockEventBusWithOptions creates a new mock instance.
func NewMockEventBusWithOptions[T any](ctrl *gomock.Controller) *MockEventBusWithOptions[T] {
	mock := &MockEventBusWithOptions[T]{ctrl: ctrl}
	mock.recorder = &MockEventBusWithOptionsMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventBusWithOptions[T]) EXPECT() *MockEventBusWithOptionsMockRecorder[T] {
	return m.recorder
}

// Close mocks base method.
func (m *MockEventBusWithOptions[T]) Close(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockEventBusWithOptionsMockRecorder[T]) Close(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).Close), ctx)
}

// GetDefaultTimeout mocks base method.
func (m *MockEventBusWithOptions[T]) GetDefaultTimeout() time.Duration {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDefaultTimeout")
	ret0, _ := ret[0].(time.Duration)
	return ret0
}

// GetDefaultTimeout indicates an expected call of GetDefaultTimeout.
func (mr *MockEventBusWithOptionsMockRecorder[T]) GetDefaultTimeout() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDefaultTimeout", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).GetDefaultTimeout))
}

// GetWorkerPoolStats mocks base method.
func (m *MockEventBusWithOptions[T]) GetWorkerPoolStats() (int, int, int) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkerPoolStats")
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(int)
	return ret0, ret1, ret2
}

// GetWorkerPoolStats indicates an expected call of GetWorkerPoolStats.
func (mr *MockEventBusWithOptionsMockRecorder[T]) GetWorkerPoolStats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkerPoolStats", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).GetWorkerPoolStats))
}

// HasSubscription mocks base method.
func (m *MockEventBusWithOptions[T]) HasSubscription() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSubscription")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSubscription indicates an expected call of HasSubscription.
func (mr *MockEventBusWithOptionsMockRecorder[T]) HasSubscription() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSubscription", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).HasSubscription))
}

// IsClosed mocks base method.
func (m *MockEventBusWithOptions[T]) IsClosed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClosed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsClosed indicates an expected call of IsClosed.
func (mr *MockEventBusWithOptionsMockRecorder[T]) IsClosed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClosed", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).IsClosed))
}

// Publish mocks base method.
func (m *MockEventBusWithOptions[T]) Publish(ctx context.Context, event T) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Publish", ctx, event)
}

// Publish indicates an expected call of Publish.
func (mr *MockEventBusWithOptionsMockRecorder[T]) Publish(ctx, event any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).Publish), ctx, event)
}

// SetDefaultTimeout mocks base method.
func (m *MockEventBusWithOptions[T]) SetDefaultTimeout(timeout time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetDefaultTimeout", timeout)
}

// SetDefaultTimeout indicates an expected call of SetDefaultTimeout.
func (mr *MockEventBusWithOptionsMockRecorder[T]) SetDefaultTimeout(timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDefaultTimeout", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).SetDefaultTimeout), timeout)
}

// Subscribe mocks base method.
func (m *MockEventBusWithOptions[T]) Subscribe(fn types.SubscriptionFunc[T], opts ...types.SubscribeOption[T]) (types.SubscriptionID, error) {
	m.ctrl.T.Helper()
	varargs := []any{fn}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(types.SubscriptionID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockEventBusWithOptionsMockRecorder[T]) Subscribe(fn any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{fn}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).Subscribe), varargs...)
}

// Unsubscribe mocks base method.
func (m *MockEventBusWithOptions[T]) Unsubscribe(id types.SubscriptionID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unsubscribe", id)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockEventBusWithOptionsMockRecorder[T]) Unsubscribe(id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).Unsubscribe), id)
}

// UnsubscribeAll mocks base method.
func (m *MockEventBusWithOptions[T]) UnsubscribeAll() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UnsubscribeAll")
}

// UnsubscribeAll indicates an expected call of UnsubscribeAll.
func (mr *MockEventBusWithOptionsMockRecorder[T]) UnsubscribeAll() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsubscribeAll", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).UnsubscribeAll))
}

// WaitAsync mocks base method.
func (m *MockEventBusWithOptions[T]) WaitAsync() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WaitAsync")
}

// WaitAsync indicates an expected call of WaitAsync.
func (mr *MockEventBusWithOptionsMockRecorder[T]) WaitAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitAsync", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).WaitAsync))
}

// WithAsync mocks base method.
func (m *MockEventBusWithOptions[T]) WithAsync() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithAsync")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithAsync indicates an expected call of WithAsync.
func (mr *MockEventBusWithOptionsMockRecorder[T]) WithAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithAsync", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).WithAsync))
}

// WithOnce mocks base method.
func (m *MockEventBusWithOptions[T]) WithOnce() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithOnce")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithOnce indicates an expected call of WithOnce.
func (mr *MockEventBusWithOptionsMockRecorder[T]) WithOnce() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithOnce", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).WithOnce))
}

// WithSerial mocks base method.
func (m *MockEventBusWithOptions[T]) WithSerial() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithSerial")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithSerial indicates an expected call of WithSerial.
func (mr *MockEventBusWithOptionsMockRecorder[T]) WithSerial() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithSerial", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).WithSerial))
}

// WithTimeout mocks base method.
func (m *MockEventBusWithOptions[T]) WithTimeout(timeout time.Duration) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithTimeout", timeout)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithTimeout indicates an expected call of WithTimeout.
func (mr *MockEventBusWithOptionsMockRecorder[T]) WithTimeout(timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithTimeout", reflect.TypeOf((*MockEventBusWithOptions[T])(nil).WithTimeout), timeout)
}

// MockEventBusWithHooks is a mock of EventBusWithHooks interface.
type MockEventBusWithHooks[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockEventBusWithHooksMockRecorder[T]
	isgomock struct{}
}

// MockEventBusWithHooksMockRecorder is the mock recorder for MockEventBusWithHooks.
type MockEventBusWithHooksMockRecorder[T any] struct {
	mock *MockEventBusWithHooks[T]
}

// NewMockEventBusWithHooks creates a new mock instance.
func NewMockEventBusWithHooks[T any](ctrl *gomock.Controller) *MockEventBusWithHooks[T] {
	mock := &MockEventBusWithHooks[T]{ctrl: ctrl}
	mock.recorder = &MockEventBusWithHooksMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventBusWithHooks[T]) EXPECT() *MockEventBusWithHooksMockRecorder[T] {
	return m.recorder
}

// Close mocks base method.
func (m *MockEventBusWithHooks[T]) Close(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockEventBusWithHooksMockRecorder[T]) Close(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).Close), ctx)
}

// DisableHooks mocks base method.
func (m *MockEventBusWithHooks[T]) DisableHooks() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "DisableHooks")
}

// DisableHooks indicates an expected call of DisableHooks.
func (mr *MockEventBusWithHooksMockRecorder[T]) DisableHooks() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DisableHooks", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).DisableHooks))
}

// EnableHooks mocks base method.
func (m *MockEventBusWithHooks[T]) EnableHooks() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "EnableHooks")
}

// EnableHooks indicates an expected call of EnableHooks.
func (mr *MockEventBusWithHooksMockRecorder[T]) EnableHooks() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnableHooks", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).EnableHooks))
}

// GetWorkerPoolStats mocks base method.
func (m *MockEventBusWithHooks[T]) GetWorkerPoolStats() (int, int, int) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkerPoolStats")
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(int)
	return ret0, ret1, ret2
}

// GetWorkerPoolStats indicates an expected call of GetWorkerPoolStats.
func (mr *MockEventBusWithHooksMockRecorder[T]) GetWorkerPoolStats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkerPoolStats", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).GetWorkerPoolStats))
}

// HasSubscription mocks base method.
func (m *MockEventBusWithHooks[T]) HasSubscription() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSubscription")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSubscription indicates an expected call of HasSubscription.
func (mr *MockEventBusWithHooksMockRecorder[T]) HasSubscription() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSubscription", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).HasSubscription))
}

// HooksEnabled mocks base method.
func (m *MockEventBusWithHooks[T]) HooksEnabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HooksEnabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HooksEnabled indicates an expected call of HooksEnabled.
func (mr *MockEventBusWithHooksMockRecorder[T]) HooksEnabled() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HooksEnabled", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).HooksEnabled))
}

// IsClosed mocks base method.
func (m *MockEventBusWithHooks[T]) IsClosed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClosed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsClosed indicates an expected call of IsClosed.
func (mr *MockEventBusWithHooksMockRecorder[T]) IsClosed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClosed", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).IsClosed))
}

// Publish mocks base method.
func (m *MockEventBusWithHooks[T]) Publish(ctx context.Context, event T) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Publish", ctx, event)
}

// Publish indicates an expected call of Publish.
func (mr *MockEventBusWithHooksMockRecorder[T]) Publish(ctx, event any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).Publish), ctx, event)
}

// SetAfterHook mocks base method.
func (m *MockEventBusWithHooks[T]) SetAfterHook(id types.SubscriptionID, hooks ...types.AfterHook[T]) bool {
	m.ctrl.T.Helper()
	varargs := []any{id}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetAfterHook", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SetAfterHook indicates an expected call of SetAfterHook.
func (mr *MockEventBusWithHooksMockRecorder[T]) SetAfterHook(id any, hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{id}, hooks...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetAfterHook", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).SetAfterHook), varargs...)
}

// SetBeforeHook mocks base method.
func (m *MockEventBusWithHooks[T]) SetBeforeHook(id types.SubscriptionID, hooks ...types.BeforeHook[T]) bool {
	m.ctrl.T.Helper()
	varargs := []any{id}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetBeforeHook", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SetBeforeHook indicates an expected call of SetBeforeHook.
func (mr *MockEventBusWithHooksMockRecorder[T]) SetBeforeHook(id any, hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{id}, hooks...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBeforeHook", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).SetBeforeHook), varargs...)
}

// SetErrorHook mocks base method.
func (m *MockEventBusWithHooks[T]) SetErrorHook(id types.SubscriptionID, hooks ...types.ErrorHook[T]) bool {
	m.ctrl.T.Helper()
	varargs := []any{id}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetErrorHook", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SetErrorHook indicates an expected call of SetErrorHook.
func (mr *MockEventBusWithHooksMockRecorder[T]) SetErrorHook(id any, hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{id}, hooks...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetErrorHook", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).SetErrorHook), varargs...)
}

// SetGlobalAfterHook mocks base method.
func (m *MockEventBusWithHooks[T]) SetGlobalAfterHook(hooks ...types.AfterHook[T]) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SetGlobalAfterHook", varargs...)
}

// SetGlobalAfterHook indicates an expected call of SetGlobalAfterHook.
func (mr *MockEventBusWithHooksMockRecorder[T]) SetGlobalAfterHook(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetGlobalAfterHook", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).SetGlobalAfterHook), hooks...)
}

// SetGlobalBeforeHook mocks base method.
func (m *MockEventBusWithHooks[T]) SetGlobalBeforeHook(hooks ...types.BeforeHook[T]) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SetGlobalBeforeHook", varargs...)
}

// SetGlobalBeforeHook indicates an expected call of SetGlobalBeforeHook.
func (mr *MockEventBusWithHooksMockRecorder[T]) SetGlobalBeforeHook(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetGlobalBeforeHook", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).SetGlobalBeforeHook), hooks...)
}

// SetGlobalErrorHook mocks base method.
func (m *MockEventBusWithHooks[T]) SetGlobalErrorHook(hooks ...types.ErrorHook[T]) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SetGlobalErrorHook", varargs...)
}

// SetGlobalErrorHook indicates an expected call of SetGlobalErrorHook.
func (mr *MockEventBusWithHooksMockRecorder[T]) SetGlobalErrorHook(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetGlobalErrorHook", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).SetGlobalErrorHook), hooks...)
}

// Subscribe mocks base method.
func (m *MockEventBusWithHooks[T]) Subscribe(fn types.SubscriptionFunc[T], opts ...types.SubscribeOption[T]) (types.SubscriptionID, error) {
	m.ctrl.T.Helper()
	varargs := []any{fn}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(types.SubscriptionID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockEventBusWithHooksMockRecorder[T]) Subscribe(fn any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{fn}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).Subscribe), varargs...)
}

// Unsubscribe mocks base method.
func (m *MockEventBusWithHooks[T]) Unsubscribe(id types.SubscriptionID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unsubscribe", id)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockEventBusWithHooksMockRecorder[T]) Unsubscribe(id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).Unsubscribe), id)
}

// UnsubscribeAll mocks base method.
func (m *MockEventBusWithHooks[T]) UnsubscribeAll() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UnsubscribeAll")
}

// UnsubscribeAll indicates an expected call of UnsubscribeAll.
func (mr *MockEventBusWithHooksMockRecorder[T]) UnsubscribeAll() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsubscribeAll", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).UnsubscribeAll))
}

// WaitAsync mocks base method.
func (m *MockEventBusWithHooks[T]) WaitAsync() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WaitAsync")
}

// WaitAsync indicates an expected call of WaitAsync.
func (mr *MockEventBusWithHooksMockRecorder[T]) WaitAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitAsync", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).WaitAsync))
}

// WithAfter mocks base method.
func (m *MockEventBusWithHooks[T]) WithAfter(hooks ...types.AfterHook[T]) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WithAfter", varargs...)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithAfter indicates an expected call of WithAfter.
func (mr *MockEventBusWithHooksMockRecorder[T]) WithAfter(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithAfter", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).WithAfter), hooks...)
}

// WithAsync mocks base method.
func (m *MockEventBusWithHooks[T]) WithAsync() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithAsync")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithAsync indicates an expected call of WithAsync.
func (mr *MockEventBusWithHooksMockRecorder[T]) WithAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithAsync", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).WithAsync))
}

// WithBefore mocks base method.
func (m *MockEventBusWithHooks[T]) WithBefore(hooks ...types.BeforeHook[T]) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WithBefore", varargs...)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithBefore indicates an expected call of WithBefore.
func (mr *MockEventBusWithHooksMockRecorder[T]) WithBefore(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithBefore", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).WithBefore), hooks...)
}

// WithOnError mocks base method.
func (m *MockEventBusWithHooks[T]) WithOnError(hooks ...types.ErrorHook[T]) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WithOnError", varargs...)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithOnError indicates an expected call of WithOnError.
func (mr *MockEventBusWithHooksMockRecorder[T]) WithOnError(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithOnError", reflect.TypeOf((*MockEventBusWithHooks[T])(nil).WithOnError), hooks...)
}

// MockEventBusWithMetrics is a mock of EventBusWithMetrics interface.
type MockEventBusWithMetrics[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockEventBusWithMetricsMockRecorder[T]
	isgomock struct{}
}

// MockEventBusWithMetricsMockRecorder is the mock recorder for MockEventBusWithMetrics.
type MockEventBusWithMetricsMockRecorder[T any] struct {
	mock *MockEventBusWithMetrics[T]
}

// NewMockEventBusWithMetrics creates a new mock instance.
func NewMockEventBusWithMetrics[T any](ctrl *gomock.Controller) *MockEventBusWithMetrics[T] {
	mock := &MockEventBusWithMetrics[T]{ctrl: ctrl}
	mock.recorder = &MockEventBusWithMetricsMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventBusWithMetrics[T]) EXPECT() *MockEventBusWithMetricsMockRecorder[T] {
	return m.recorder
}

// Close mocks base method.
func (m *MockEventBusWithMetrics[T]) Close(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockEventBusWithMetricsMockRecorder[T]) Close(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).Close), ctx)
}

// ErrorCount mocks base method.
func (m *MockEventBusWithMetrics[T]) ErrorCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ErrorCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// ErrorCount indicates an expected call of ErrorCount.
func (mr *MockEventBusWithMetricsMockRecorder[T]) ErrorCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ErrorCount", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).ErrorCount))
}

// GetWorkerPoolStats mocks base method.
func (m *MockEventBusWithMetrics[T]) GetWorkerPoolStats() (int, int, int) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkerPoolStats")
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(int)
	return ret0, ret1, ret2
}

// GetWorkerPoolStats indicates an expected call of GetWorkerPoolStats.
func (mr *MockEventBusWithMetricsMockRecorder[T]) GetWorkerPoolStats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkerPoolStats", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).GetWorkerPoolStats))
}

// HasSubscription mocks base method.
func (m *MockEventBusWithMetrics[T]) HasSubscription() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSubscription")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSubscription indicates an expected call of HasSubscription.
func (mr *MockEventBusWithMetricsMockRecorder[T]) HasSubscription() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSubscription", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).HasSubscription))
}

// IsClosed mocks base method.
func (m *MockEventBusWithMetrics[T]) IsClosed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClosed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsClosed indicates an expected call of IsClosed.
func (mr *MockEventBusWithMetricsMockRecorder[T]) IsClosed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClosed", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).IsClosed))
}

// Metrics mocks base method.
func (m *MockEventBusWithMetrics[T]) Metrics() types.BusMetrics {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Metrics")
	ret0, _ := ret[0].(types.BusMetrics)
	return ret0
}

// Metrics indicates an expected call of Metrics.
func (mr *MockEventBusWithMetricsMockRecorder[T]) Metrics() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Metrics", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).Metrics))
}

// ProcessedCount mocks base method.
func (m *MockEventBusWithMetrics[T]) ProcessedCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProcessedCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// ProcessedCount indicates an expected call of ProcessedCount.
func (mr *MockEventBusWithMetricsMockRecorder[T]) ProcessedCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProcessedCount", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).ProcessedCount))
}

// Publish mocks base method.
func (m *MockEventBusWithMetrics[T]) Publish(ctx context.Context, event T) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Publish", ctx, event)
}

// Publish indicates an expected call of Publish.
func (mr *MockEventBusWithMetricsMockRecorder[T]) Publish(ctx, event any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).Publish), ctx, event)
}

// PublishedCount mocks base method.
func (m *MockEventBusWithMetrics[T]) PublishedCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishedCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// PublishedCount indicates an expected call of PublishedCount.
func (mr *MockEventBusWithMetricsMockRecorder[T]) PublishedCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishedCount", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).PublishedCount))
}

// Subscribe mocks base method.
func (m *MockEventBusWithMetrics[T]) Subscribe(fn types.SubscriptionFunc[T], opts ...types.SubscribeOption[T]) (types.SubscriptionID, error) {
	m.ctrl.T.Helper()
	varargs := []any{fn}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(types.SubscriptionID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockEventBusWithMetricsMockRecorder[T]) Subscribe(fn any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{fn}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).Subscribe), varargs...)
}

// SubscriberCount mocks base method.
func (m *MockEventBusWithMetrics[T]) SubscriberCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubscriberCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// SubscriberCount indicates an expected call of SubscriberCount.
func (mr *MockEventBusWithMetricsMockRecorder[T]) SubscriberCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscriberCount", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).SubscriberCount))
}

// Unsubscribe mocks base method.
func (m *MockEventBusWithMetrics[T]) Unsubscribe(id types.SubscriptionID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unsubscribe", id)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockEventBusWithMetricsMockRecorder[T]) Unsubscribe(id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).Unsubscribe), id)
}

// UnsubscribeAll mocks base method.
func (m *MockEventBusWithMetrics[T]) UnsubscribeAll() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UnsubscribeAll")
}

// UnsubscribeAll indicates an expected call of UnsubscribeAll.
func (mr *MockEventBusWithMetricsMockRecorder[T]) UnsubscribeAll() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsubscribeAll", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).UnsubscribeAll))
}

// WaitAsync mocks base method.
func (m *MockEventBusWithMetrics[T]) WaitAsync() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WaitAsync")
}

// WaitAsync indicates an expected call of WaitAsync.
func (mr *MockEventBusWithMetricsMockRecorder[T]) WaitAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitAsync", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).WaitAsync))
}

// WithAsync mocks base method.
func (m *MockEventBusWithMetrics[T]) WithAsync() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithAsync")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithAsync indicates an expected call of WithAsync.
func (mr *MockEventBusWithMetricsMockRecorder[T]) WithAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithAsync", reflect.TypeOf((*MockEventBusWithMetrics[T])(nil).WithAsync))
}

// MockEventBusHooksOptions is a mock of EventBusHooksOptions interface.
type MockEventBusHooksOptions[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockEventBusHooksOptionsMockRecorder[T]
	isgomock struct{}
}

// MockEventBusHooksOptionsMockRecorder is the mock recorder for MockEventBusHooksOptions.
type MockEventBusHooksOptionsMockRecorder[T any] struct {
	mock *MockEventBusHooksOptions[T]
}

// NewMockEventBusHooksOptions creates a new mock instance.
func NewMockEventBusHooksOptions[T any](ctrl *gomock.Controller) *MockEventBusHooksOptions[T] {
	mock := &MockEventBusHooksOptions[T]{ctrl: ctrl}
	mock.recorder = &MockEventBusHooksOptionsMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventBusHooksOptions[T]) EXPECT() *MockEventBusHooksOptionsMockRecorder[T] {
	return m.recorder
}

// Close mocks base method.
func (m *MockEventBusHooksOptions[T]) Close(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) Close(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).Close), ctx)
}

// DisableHooks mocks base method.
func (m *MockEventBusHooksOptions[T]) DisableHooks() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "DisableHooks")
}

// DisableHooks indicates an expected call of DisableHooks.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) DisableHooks() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DisableHooks", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).DisableHooks))
}

// EnableHooks mocks base method.
func (m *MockEventBusHooksOptions[T]) EnableHooks() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "EnableHooks")
}

// EnableHooks indicates an expected call of EnableHooks.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) EnableHooks() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnableHooks", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).EnableHooks))
}

// GetDefaultTimeout mocks base method.
func (m *MockEventBusHooksOptions[T]) GetDefaultTimeout() time.Duration {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDefaultTimeout")
	ret0, _ := ret[0].(time.Duration)
	return ret0
}

// GetDefaultTimeout indicates an expected call of GetDefaultTimeout.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) GetDefaultTimeout() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDefaultTimeout", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).GetDefaultTimeout))
}

// GetWorkerPoolStats mocks base method.
func (m *MockEventBusHooksOptions[T]) GetWorkerPoolStats() (int, int, int) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkerPoolStats")
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(int)
	return ret0, ret1, ret2
}

// GetWorkerPoolStats indicates an expected call of GetWorkerPoolStats.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) GetWorkerPoolStats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkerPoolStats", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).GetWorkerPoolStats))
}

// HasSubscription mocks base method.
func (m *MockEventBusHooksOptions[T]) HasSubscription() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSubscription")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSubscription indicates an expected call of HasSubscription.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) HasSubscription() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSubscription", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).HasSubscription))
}

// HooksEnabled mocks base method.
func (m *MockEventBusHooksOptions[T]) HooksEnabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HooksEnabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HooksEnabled indicates an expected call of HooksEnabled.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) HooksEnabled() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HooksEnabled", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).HooksEnabled))
}

// IsClosed mocks base method.
func (m *MockEventBusHooksOptions[T]) IsClosed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClosed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsClosed indicates an expected call of IsClosed.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) IsClosed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClosed", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).IsClosed))
}

// Publish mocks base method.
func (m *MockEventBusHooksOptions[T]) Publish(ctx context.Context, event T) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Publish", ctx, event)
}

// Publish indicates an expected call of Publish.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) Publish(ctx, event any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).Publish), ctx, event)
}

// SetAfterHook mocks base method.
func (m *MockEventBusHooksOptions[T]) SetAfterHook(id types.SubscriptionID, hooks ...types.AfterHook[T]) bool {
	m.ctrl.T.Helper()
	varargs := []any{id}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetAfterHook", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SetAfterHook indicates an expected call of SetAfterHook.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) SetAfterHook(id any, hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{id}, hooks...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetAfterHook", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).SetAfterHook), varargs...)
}

// SetBeforeHook mocks base method.
func (m *MockEventBusHooksOptions[T]) SetBeforeHook(id types.SubscriptionID, hooks ...types.BeforeHook[T]) bool {
	m.ctrl.T.Helper()
	varargs := []any{id}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetBeforeHook", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SetBeforeHook indicates an expected call of SetBeforeHook.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) SetBeforeHook(id any, hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{id}, hooks...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBeforeHook", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).SetBeforeHook), varargs...)
}

// SetDefaultTimeout mocks base method.
func (m *MockEventBusHooksOptions[T]) SetDefaultTimeout(timeout time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetDefaultTimeout", timeout)
}

// SetDefaultTimeout indicates an expected call of SetDefaultTimeout.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) SetDefaultTimeout(timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDefaultTimeout", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).SetDefaultTimeout), timeout)
}

// SetErrorHook mocks base method.
func (m *MockEventBusHooksOptions[T]) SetErrorHook(id types.SubscriptionID, hooks ...types.ErrorHook[T]) bool {
	m.ctrl.T.Helper()
	varargs := []any{id}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetErrorHook", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SetErrorHook indicates an expected call of SetErrorHook.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) SetErrorHook(id any, hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{id}, hooks...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetErrorHook", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).SetErrorHook), varargs...)
}

// SetGlobalAfterHook mocks base method.
func (m *MockEventBusHooksOptions[T]) SetGlobalAfterHook(hooks ...types.AfterHook[T]) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SetGlobalAfterHook", varargs...)
}

// SetGlobalAfterHook indicates an expected call of SetGlobalAfterHook.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) SetGlobalAfterHook(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetGlobalAfterHook", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).SetGlobalAfterHook), hooks...)
}

// SetGlobalBeforeHook mocks base method.
func (m *MockEventBusHooksOptions[T]) SetGlobalBeforeHook(hooks ...types.BeforeHook[T]) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SetGlobalBeforeHook", varargs...)
}

// SetGlobalBeforeHook indicates an expected call of SetGlobalBeforeHook.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) SetGlobalBeforeHook(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetGlobalBeforeHook", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).SetGlobalBeforeHook), hooks...)
}

// SetGlobalErrorHook mocks base method.
func (m *MockEventBusHooksOptions[T]) SetGlobalErrorHook(hooks ...types.ErrorHook[T]) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SetGlobalErrorHook", varargs...)
}

// SetGlobalErrorHook indicates an expected call of SetGlobalErrorHook.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) SetGlobalErrorHook(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetGlobalErrorHook", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).SetGlobalErrorHook), hooks...)
}

// Subscribe mocks base method.
func (m *MockEventBusHooksOptions[T]) Subscribe(fn types.SubscriptionFunc[T], opts ...types.SubscribeOption[T]) (types.SubscriptionID, error) {
	m.ctrl.T.Helper()
	varargs := []any{fn}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(types.SubscriptionID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) Subscribe(fn any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{fn}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).Subscribe), varargs...)
}

// Unsubscribe mocks base method.
func (m *MockEventBusHooksOptions[T]) Unsubscribe(id types.SubscriptionID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unsubscribe", id)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) Unsubscribe(id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).Unsubscribe), id)
}

// UnsubscribeAll mocks base method.
func (m *MockEventBusHooksOptions[T]) UnsubscribeAll() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UnsubscribeAll")
}

// UnsubscribeAll indicates an expected call of UnsubscribeAll.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) UnsubscribeAll() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsubscribeAll", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).UnsubscribeAll))
}

// WaitAsync mocks base method.
func (m *MockEventBusHooksOptions[T]) WaitAsync() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WaitAsync")
}

// WaitAsync indicates an expected call of WaitAsync.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) WaitAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitAsync", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).WaitAsync))
}

// WithAfter mocks base method.
func (m *MockEventBusHooksOptions[T]) WithAfter(hooks ...types.AfterHook[T]) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WithAfter", varargs...)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithAfter indicates an expected call of WithAfter.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) WithAfter(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithAfter", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).WithAfter), hooks...)
}

// WithAsync mocks base method.
func (m *MockEventBusHooksOptions[T]) WithAsync() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithAsync")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithAsync indicates an expected call of WithAsync.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) WithAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithAsync", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).WithAsync))
}

// WithBefore mocks base method.
func (m *MockEventBusHooksOptions[T]) WithBefore(hooks ...types.BeforeHook[T]) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WithBefore", varargs...)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithBefore indicates an expected call of WithBefore.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) WithBefore(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithBefore", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).WithBefore), hooks...)
}

// WithOnError mocks base method.
func (m *MockEventBusHooksOptions[T]) WithOnError(hooks ...types.ErrorHook[T]) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WithOnError", varargs...)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithOnError indicates an expected call of WithOnError.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) WithOnError(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithOnError", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).WithOnError), hooks...)
}

// WithOnce mocks base method.
func (m *MockEventBusHooksOptions[T]) WithOnce() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithOnce")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithOnce indicates an expected call of WithOnce.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) WithOnce() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithOnce", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).WithOnce))
}

// WithSerial mocks base method.
func (m *MockEventBusHooksOptions[T]) WithSerial() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithSerial")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithSerial indicates an expected call of WithSerial.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) WithSerial() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithSerial", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).WithSerial))
}

// WithTimeout mocks base method.
func (m *MockEventBusHooksOptions[T]) WithTimeout(timeout time.Duration) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithTimeout", timeout)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithTimeout indicates an expected call of WithTimeout.
func (mr *MockEventBusHooksOptionsMockRecorder[T]) WithTimeout(timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithTimeout", reflect.TypeOf((*MockEventBusHooksOptions[T])(nil).WithTimeout), timeout)
}

// MockEventBusMetricsOptions is a mock of EventBusMetricsOptions interface.
type MockEventBusMetricsOptions[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockEventBusMetricsOptionsMockRecorder[T]
	isgomock struct{}
}

// MockEventBusMetricsOptionsMockRecorder is the mock recorder for MockEventBusMetricsOptions.
type MockEventBusMetricsOptionsMockRecorder[T any] struct {
	mock *MockEventBusMetricsOptions[T]
}

// NewMockEventBusMetricsOptions creates a new mock instance.
func NewMockEventBusMetricsOptions[T any](ctrl *gomock.Controller) *MockEventBusMetricsOptions[T] {
	mock := &MockEventBusMetricsOptions[T]{ctrl: ctrl}
	mock.recorder = &MockEventBusMetricsOptionsMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventBusMetricsOptions[T]) EXPECT() *MockEventBusMetricsOptionsMockRecorder[T] {
	return m.recorder
}

// Close mocks base method.
func (m *MockEventBusMetricsOptions[T]) Close(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) Close(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).Close), ctx)
}

// ErrorCount mocks base method.
func (m *MockEventBusMetricsOptions[T]) ErrorCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ErrorCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// ErrorCount indicates an expected call of ErrorCount.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) ErrorCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ErrorCount", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).ErrorCount))
}

// GetDefaultTimeout mocks base method.
func (m *MockEventBusMetricsOptions[T]) GetDefaultTimeout() time.Duration {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDefaultTimeout")
	ret0, _ := ret[0].(time.Duration)
	return ret0
}

// GetDefaultTimeout indicates an expected call of GetDefaultTimeout.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) GetDefaultTimeout() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDefaultTimeout", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).GetDefaultTimeout))
}

// GetWorkerPoolStats mocks base method.
func (m *MockEventBusMetricsOptions[T]) GetWorkerPoolStats() (int, int, int) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkerPoolStats")
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(int)
	return ret0, ret1, ret2
}

// GetWorkerPoolStats indicates an expected call of GetWorkerPoolStats.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) GetWorkerPoolStats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkerPoolStats", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).GetWorkerPoolStats))
}

// HasSubscription mocks base method.
func (m *MockEventBusMetricsOptions[T]) HasSubscription() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSubscription")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSubscription indicates an expected call of HasSubscription.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) HasSubscription() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSubscription", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).HasSubscription))
}

// IsClosed mocks base method.
func (m *MockEventBusMetricsOptions[T]) IsClosed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClosed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsClosed indicates an expected call of IsClosed.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) IsClosed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClosed", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).IsClosed))
}

// Metrics mocks base method.
func (m *MockEventBusMetricsOptions[T]) Metrics() types.BusMetrics {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Metrics")
	ret0, _ := ret[0].(types.BusMetrics)
	return ret0
}

// Metrics indicates an expected call of Metrics.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) Metrics() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Metrics", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).Metrics))
}

// ProcessedCount mocks base method.
func (m *MockEventBusMetricsOptions[T]) ProcessedCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProcessedCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// ProcessedCount indicates an expected call of ProcessedCount.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) ProcessedCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProcessedCount", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).ProcessedCount))
}

// Publish mocks base method.
func (m *MockEventBusMetricsOptions[T]) Publish(ctx context.Context, event T) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Publish", ctx, event)
}

// Publish indicates an expected call of Publish.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) Publish(ctx, event any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).Publish), ctx, event)
}

// PublishedCount mocks base method.
func (m *MockEventBusMetricsOptions[T]) PublishedCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishedCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// PublishedCount indicates an expected call of PublishedCount.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) PublishedCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishedCount", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).PublishedCount))
}

// SetDefaultTimeout mocks base method.
func (m *MockEventBusMetricsOptions[T]) SetDefaultTimeout(timeout time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetDefaultTimeout", timeout)
}

// SetDefaultTimeout indicates an expected call of SetDefaultTimeout.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) SetDefaultTimeout(timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDefaultTimeout", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).SetDefaultTimeout), timeout)
}

// Subscribe mocks base method.
func (m *MockEventBusMetricsOptions[T]) Subscribe(fn types.SubscriptionFunc[T], opts ...types.SubscribeOption[T]) (types.SubscriptionID, error) {
	m.ctrl.T.Helper()
	varargs := []any{fn}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(types.SubscriptionID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) Subscribe(fn any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{fn}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).Subscribe), varargs...)
}

// SubscriberCount mocks base method.
func (m *MockEventBusMetricsOptions[T]) SubscriberCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubscriberCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// SubscriberCount indicates an expected call of SubscriberCount.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) SubscriberCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscriberCount", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).SubscriberCount))
}

// Unsubscribe mocks base method.
func (m *MockEventBusMetricsOptions[T]) Unsubscribe(id types.SubscriptionID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unsubscribe", id)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) Unsubscribe(id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).Unsubscribe), id)
}

// UnsubscribeAll mocks base method.
func (m *MockEventBusMetricsOptions[T]) UnsubscribeAll() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UnsubscribeAll")
}

// UnsubscribeAll indicates an expected call of UnsubscribeAll.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) UnsubscribeAll() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsubscribeAll", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).UnsubscribeAll))
}

// WaitAsync mocks base method.
func (m *MockEventBusMetricsOptions[T]) WaitAsync() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WaitAsync")
}

// WaitAsync indicates an expected call of WaitAsync.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) WaitAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitAsync", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).WaitAsync))
}

// WithAsync mocks base method.
func (m *MockEventBusMetricsOptions[T]) WithAsync() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithAsync")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithAsync indicates an expected call of WithAsync.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) WithAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithAsync", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).WithAsync))
}

// WithOnce mocks base method.
func (m *MockEventBusMetricsOptions[T]) WithOnce() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithOnce")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithOnce indicates an expected call of WithOnce.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) WithOnce() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithOnce", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).WithOnce))
}

// WithSerial mocks base method.
func (m *MockEventBusMetricsOptions[T]) WithSerial() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithSerial")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithSerial indicates an expected call of WithSerial.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) WithSerial() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithSerial", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).WithSerial))
}

// WithTimeout mocks base method.
func (m *MockEventBusMetricsOptions[T]) WithTimeout(timeout time.Duration) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithTimeout", timeout)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithTimeout indicates an expected call of WithTimeout.
func (mr *MockEventBusMetricsOptionsMockRecorder[T]) WithTimeout(timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithTimeout", reflect.TypeOf((*MockEventBusMetricsOptions[T])(nil).WithTimeout), timeout)
}

// MockEventBusHooksMetrics is a mock of EventBusHooksMetrics interface.
type MockEventBusHooksMetrics[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockEventBusHooksMetricsMockRecorder[T]
	isgomock struct{}
}

// MockEventBusHooksMetricsMockRecorder is the mock recorder for MockEventBusHooksMetrics.
type MockEventBusHooksMetricsMockRecorder[T any] struct {
	mock *MockEventBusHooksMetrics[T]
}

// NewMockEventBusHooksMetrics creates a new mock instance.
func NewMockEventBusHooksMetrics[T any](ctrl *gomock.Controller) *MockEventBusHooksMetrics[T] {
	mock := &MockEventBusHooksMetrics[T]{ctrl: ctrl}
	mock.recorder = &MockEventBusHooksMetricsMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventBusHooksMetrics[T]) EXPECT() *MockEventBusHooksMetricsMockRecorder[T] {
	return m.recorder
}

// Close mocks base method.
func (m *MockEventBusHooksMetrics[T]) Close(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) Close(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).Close), ctx)
}

// DisableHooks mocks base method.
func (m *MockEventBusHooksMetrics[T]) DisableHooks() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "DisableHooks")
}

// DisableHooks indicates an expected call of DisableHooks.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) DisableHooks() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DisableHooks", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).DisableHooks))
}

// EnableHooks mocks base method.
func (m *MockEventBusHooksMetrics[T]) EnableHooks() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "EnableHooks")
}

// EnableHooks indicates an expected call of EnableHooks.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) EnableHooks() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnableHooks", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).EnableHooks))
}

// ErrorCount mocks base method.
func (m *MockEventBusHooksMetrics[T]) ErrorCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ErrorCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// ErrorCount indicates an expected call of ErrorCount.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) ErrorCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ErrorCount", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).ErrorCount))
}

// GetWorkerPoolStats mocks base method.
func (m *MockEventBusHooksMetrics[T]) GetWorkerPoolStats() (int, int, int) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkerPoolStats")
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(int)
	return ret0, ret1, ret2
}

// GetWorkerPoolStats indicates an expected call of GetWorkerPoolStats.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) GetWorkerPoolStats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkerPoolStats", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).GetWorkerPoolStats))
}

// HasSubscription mocks base method.
func (m *MockEventBusHooksMetrics[T]) HasSubscription() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSubscription")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSubscription indicates an expected call of HasSubscription.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) HasSubscription() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSubscription", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).HasSubscription))
}

// HooksEnabled mocks base method.
func (m *MockEventBusHooksMetrics[T]) HooksEnabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HooksEnabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HooksEnabled indicates an expected call of HooksEnabled.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) HooksEnabled() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HooksEnabled", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).HooksEnabled))
}

// IsClosed mocks base method.
func (m *MockEventBusHooksMetrics[T]) IsClosed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClosed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsClosed indicates an expected call of IsClosed.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) IsClosed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClosed", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).IsClosed))
}

// Metrics mocks base method.
func (m *MockEventBusHooksMetrics[T]) Metrics() types.BusMetrics {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Metrics")
	ret0, _ := ret[0].(types.BusMetrics)
	return ret0
}

// Metrics indicates an expected call of Metrics.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) Metrics() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Metrics", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).Metrics))
}

// ProcessedCount mocks base method.
func (m *MockEventBusHooksMetrics[T]) ProcessedCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProcessedCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// ProcessedCount indicates an expected call of ProcessedCount.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) ProcessedCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProcessedCount", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).ProcessedCount))
}

// Publish mocks base method.
func (m *MockEventBusHooksMetrics[T]) Publish(ctx context.Context, event T) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Publish", ctx, event)
}

// Publish indicates an expected call of Publish.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) Publish(ctx, event any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).Publish), ctx, event)
}

// PublishedCount mocks base method.
func (m *MockEventBusHooksMetrics[T]) PublishedCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishedCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// PublishedCount indicates an expected call of PublishedCount.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) PublishedCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishedCount", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).PublishedCount))
}

// SetAfterHook mocks base method.
func (m *MockEventBusHooksMetrics[T]) SetAfterHook(id types.SubscriptionID, hooks ...types.AfterHook[T]) bool {
	m.ctrl.T.Helper()
	varargs := []any{id}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetAfterHook", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SetAfterHook indicates an expected call of SetAfterHook.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) SetAfterHook(id any, hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{id}, hooks...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetAfterHook", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).SetAfterHook), varargs...)
}

// SetBeforeHook mocks base method.
func (m *MockEventBusHooksMetrics[T]) SetBeforeHook(id types.SubscriptionID, hooks ...types.BeforeHook[T]) bool {
	m.ctrl.T.Helper()
	varargs := []any{id}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetBeforeHook", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SetBeforeHook indicates an expected call of SetBeforeHook.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) SetBeforeHook(id any, hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{id}, hooks...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBeforeHook", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).SetBeforeHook), varargs...)
}

// SetErrorHook mocks base method.
func (m *MockEventBusHooksMetrics[T]) SetErrorHook(id types.SubscriptionID, hooks ...types.ErrorHook[T]) bool {
	m.ctrl.T.Helper()
	varargs := []any{id}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetErrorHook", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SetErrorHook indicates an expected call of SetErrorHook.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) SetErrorHook(id any, hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{id}, hooks...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetErrorHook", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).SetErrorHook), varargs...)
}

// SetGlobalAfterHook mocks base method.
func (m *MockEventBusHooksMetrics[T]) SetGlobalAfterHook(hooks ...types.AfterHook[T]) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SetGlobalAfterHook", varargs...)
}

// SetGlobalAfterHook indicates an expected call of SetGlobalAfterHook.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) SetGlobalAfterHook(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetGlobalAfterHook", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).SetGlobalAfterHook), hooks...)
}

// SetGlobalBeforeHook mocks base method.
func (m *MockEventBusHooksMetrics[T]) SetGlobalBeforeHook(hooks ...types.BeforeHook[T]) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SetGlobalBeforeHook", varargs...)
}

// SetGlobalBeforeHook indicates an expected call of SetGlobalBeforeHook.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) SetGlobalBeforeHook(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetGlobalBeforeHook", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).SetGlobalBeforeHook), hooks...)
}

// SetGlobalErrorHook mocks base method.
func (m *MockEventBusHooksMetrics[T]) SetGlobalErrorHook(hooks ...types.ErrorHook[T]) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SetGlobalErrorHook", varargs...)
}

// SetGlobalErrorHook indicates an expected call of SetGlobalErrorHook.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) SetGlobalErrorHook(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetGlobalErrorHook", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).SetGlobalErrorHook), hooks...)
}

// Subscribe mocks base method.
func (m *MockEventBusHooksMetrics[T]) Subscribe(fn types.SubscriptionFunc[T], opts ...types.SubscribeOption[T]) (types.SubscriptionID, error) {
	m.ctrl.T.Helper()
	varargs := []any{fn}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(types.SubscriptionID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) Subscribe(fn any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{fn}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).Subscribe), varargs...)
}

// SubscriberCount mocks base method.
func (m *MockEventBusHooksMetrics[T]) SubscriberCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubscriberCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// SubscriberCount indicates an expected call of SubscriberCount.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) SubscriberCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscriberCount", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).SubscriberCount))
}

// Unsubscribe mocks base method.
func (m *MockEventBusHooksMetrics[T]) Unsubscribe(id types.SubscriptionID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unsubscribe", id)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) Unsubscribe(id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).Unsubscribe), id)
}

// UnsubscribeAll mocks base method.
func (m *MockEventBusHooksMetrics[T]) UnsubscribeAll() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UnsubscribeAll")
}

// UnsubscribeAll indicates an expected call of UnsubscribeAll.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) UnsubscribeAll() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsubscribeAll", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).UnsubscribeAll))
}

// WaitAsync mocks base method.
func (m *MockEventBusHooksMetrics[T]) WaitAsync() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WaitAsync")
}

// WaitAsync indicates an expected call of WaitAsync.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) WaitAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitAsync", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).WaitAsync))
}

// WithAfter mocks base method.
func (m *MockEventBusHooksMetrics[T]) WithAfter(hooks ...types.AfterHook[T]) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WithAfter", varargs...)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithAfter indicates an expected call of WithAfter.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) WithAfter(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithAfter", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).WithAfter), hooks...)
}

// WithAsync mocks base method.
func (m *MockEventBusHooksMetrics[T]) WithAsync() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithAsync")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithAsync indicates an expected call of WithAsync.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) WithAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithAsync", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).WithAsync))
}

// WithBefore mocks base method.
func (m *MockEventBusHooksMetrics[T]) WithBefore(hooks ...types.BeforeHook[T]) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WithBefore", varargs...)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithBefore indicates an expected call of WithBefore.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) WithBefore(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithBefore", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).WithBefore), hooks...)
}

// WithOnError mocks base method.
func (m *MockEventBusHooksMetrics[T]) WithOnError(hooks ...types.ErrorHook[T]) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WithOnError", varargs...)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithOnError indicates an expected call of WithOnError.
func (mr *MockEventBusHooksMetricsMockRecorder[T]) WithOnError(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithOnError", reflect.TypeOf((*MockEventBusHooksMetrics[T])(nil).WithOnError), hooks...)
}

// MockEventBusHooksMetricsOptions is a mock of EventBusHooksMetricsOptions interface.
type MockEventBusHooksMetricsOptions[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockEventBusHooksMetricsOptionsMockRecorder[T]
	isgomock struct{}
}

// MockEventBusHooksMetricsOptionsMockRecorder is the mock recorder for MockEventBusHooksMetricsOptions.
type MockEventBusHooksMetricsOptionsMockRecorder[T any] struct {
	mock *MockEventBusHooksMetricsOptions[T]
}

// NewMockEventBusHooksMetricsOptions creates a new mock instance.
func NewMockEventBusHooksMetricsOptions[T any](ctrl *gomock.Controller) *MockEventBusHooksMetricsOptions[T] {
	mock := &MockEventBusHooksMetricsOptions[T]{ctrl: ctrl}
	mock.recorder = &MockEventBusHooksMetricsOptionsMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventBusHooksMetricsOptions[T]) EXPECT() *MockEventBusHooksMetricsOptionsMockRecorder[T] {
	return m.recorder
}

// Close mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) Close(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) Close(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).Close), ctx)
}

// DisableHooks mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) DisableHooks() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "DisableHooks")
}

// DisableHooks indicates an expected call of DisableHooks.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) DisableHooks() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DisableHooks", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).DisableHooks))
}

// EnableHooks mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) EnableHooks() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "EnableHooks")
}

// EnableHooks indicates an expected call of EnableHooks.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) EnableHooks() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnableHooks", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).EnableHooks))
}

// ErrorCount mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) ErrorCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ErrorCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// ErrorCount indicates an expected call of ErrorCount.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) ErrorCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ErrorCount", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).ErrorCount))
}

// GetDefaultTimeout mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) GetDefaultTimeout() time.Duration {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDefaultTimeout")
	ret0, _ := ret[0].(time.Duration)
	return ret0
}

// GetDefaultTimeout indicates an expected call of GetDefaultTimeout.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) GetDefaultTimeout() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDefaultTimeout", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).GetDefaultTimeout))
}

// GetWorkerPoolStats mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) GetWorkerPoolStats() (int, int, int) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkerPoolStats")
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(int)
	return ret0, ret1, ret2
}

// GetWorkerPoolStats indicates an expected call of GetWorkerPoolStats.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) GetWorkerPoolStats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkerPoolStats", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).GetWorkerPoolStats))
}

// HasSubscription mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) HasSubscription() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSubscription")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSubscription indicates an expected call of HasSubscription.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) HasSubscription() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSubscription", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).HasSubscription))
}

// HooksEnabled mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) HooksEnabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HooksEnabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HooksEnabled indicates an expected call of HooksEnabled.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) HooksEnabled() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HooksEnabled", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).HooksEnabled))
}

// IsClosed mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) IsClosed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClosed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsClosed indicates an expected call of IsClosed.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) IsClosed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClosed", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).IsClosed))
}

// Metrics mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) Metrics() types.BusMetrics {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Metrics")
	ret0, _ := ret[0].(types.BusMetrics)
	return ret0
}

// Metrics indicates an expected call of Metrics.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) Metrics() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Metrics", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).Metrics))
}

// ProcessedCount mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) ProcessedCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProcessedCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// ProcessedCount indicates an expected call of ProcessedCount.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) ProcessedCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProcessedCount", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).ProcessedCount))
}

// Publish mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) Publish(ctx context.Context, event T) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Publish", ctx, event)
}

// Publish indicates an expected call of Publish.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) Publish(ctx, event any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).Publish), ctx, event)
}

// PublishedCount mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) PublishedCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishedCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// PublishedCount indicates an expected call of PublishedCount.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) PublishedCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishedCount", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).PublishedCount))
}

// SetAfterHook mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) SetAfterHook(id types.SubscriptionID, hooks ...types.AfterHook[T]) bool {
	m.ctrl.T.Helper()
	varargs := []any{id}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetAfterHook", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SetAfterHook indicates an expected call of SetAfterHook.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) SetAfterHook(id any, hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{id}, hooks...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetAfterHook", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).SetAfterHook), varargs...)
}

// SetBeforeHook mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) SetBeforeHook(id types.SubscriptionID, hooks ...types.BeforeHook[T]) bool {
	m.ctrl.T.Helper()
	varargs := []any{id}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetBeforeHook", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SetBeforeHook indicates an expected call of SetBeforeHook.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) SetBeforeHook(id any, hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{id}, hooks...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBeforeHook", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).SetBeforeHook), varargs...)
}

// SetDefaultTimeout mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) SetDefaultTimeout(timeout time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetDefaultTimeout", timeout)
}

// SetDefaultTimeout indicates an expected call of SetDefaultTimeout.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) SetDefaultTimeout(timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDefaultTimeout", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).SetDefaultTimeout), timeout)
}

// SetErrorHook mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) SetErrorHook(id types.SubscriptionID, hooks ...types.ErrorHook[T]) bool {
	m.ctrl.T.Helper()
	varargs := []any{id}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetErrorHook", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SetErrorHook indicates an expected call of SetErrorHook.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) SetErrorHook(id any, hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{id}, hooks...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetErrorHook", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).SetErrorHook), varargs...)
}

// SetGlobalAfterHook mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) SetGlobalAfterHook(hooks ...types.AfterHook[T]) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SetGlobalAfterHook", varargs...)
}

// SetGlobalAfterHook indicates an expected call of SetGlobalAfterHook.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) SetGlobalAfterHook(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetGlobalAfterHook", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).SetGlobalAfterHook), hooks...)
}

// SetGlobalBeforeHook mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) SetGlobalBeforeHook(hooks ...types.BeforeHook[T]) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SetGlobalBeforeHook", varargs...)
}

// SetGlobalBeforeHook indicates an expected call of SetGlobalBeforeHook.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) SetGlobalBeforeHook(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetGlobalBeforeHook", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).SetGlobalBeforeHook), hooks...)
}

// SetGlobalErrorHook mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) SetGlobalErrorHook(hooks ...types.ErrorHook[T]) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SetGlobalErrorHook", varargs...)
}

// SetGlobalErrorHook indicates an expected call of SetGlobalErrorHook.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) SetGlobalErrorHook(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetGlobalErrorHook", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).SetGlobalErrorHook), hooks...)
}

// Subscribe mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) Subscribe(fn types.SubscriptionFunc[T], opts ...types.SubscribeOption[T]) (types.SubscriptionID, error) {
	m.ctrl.T.Helper()
	varargs := []any{fn}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(types.SubscriptionID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) Subscribe(fn any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{fn}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).Subscribe), varargs...)
}

// SubscriberCount mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) SubscriberCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubscriberCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// SubscriberCount indicates an expected call of SubscriberCount.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) SubscriberCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscriberCount", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).SubscriberCount))
}

// Unsubscribe mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) Unsubscribe(id types.SubscriptionID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unsubscribe", id)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) Unsubscribe(id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).Unsubscribe), id)
}

// UnsubscribeAll mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) UnsubscribeAll() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UnsubscribeAll")
}

// UnsubscribeAll indicates an expected call of UnsubscribeAll.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) UnsubscribeAll() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsubscribeAll", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).UnsubscribeAll))
}

// WaitAsync mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) WaitAsync() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WaitAsync")
}

// WaitAsync indicates an expected call of WaitAsync.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) WaitAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitAsync", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).WaitAsync))
}

// WithAfter mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) WithAfter(hooks ...types.AfterHook[T]) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WithAfter", varargs...)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithAfter indicates an expected call of WithAfter.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) WithAfter(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithAfter", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).WithAfter), hooks...)
}

// WithAsync mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) WithAsync() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithAsync")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithAsync indicates an expected call of WithAsync.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) WithAsync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithAsync", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).WithAsync))
}

// WithBefore mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) WithBefore(hooks ...types.BeforeHook[T]) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WithBefore", varargs...)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithBefore indicates an expected call of WithBefore.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) WithBefore(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithBefore", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).WithBefore), hooks...)
}

// WithOnError mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) WithOnError(hooks ...types.ErrorHook[T]) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range hooks {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WithOnError", varargs...)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithOnError indicates an expected call of WithOnError.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) WithOnError(hooks ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithOnError", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).WithOnError), hooks...)
}

// WithOnce mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) WithOnce() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithOnce")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithOnce indicates an expected call of WithOnce.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) WithOnce() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithOnce", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).WithOnce))
}

// WithSerial mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) WithSerial() types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithSerial")
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithSerial indicates an expected call of WithSerial.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) WithSerial() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithSerial", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).WithSerial))
}

// WithTimeout mocks base method.
func (m *MockEventBusHooksMetricsOptions[T]) WithTimeout(timeout time.Duration) types.SubscribeOption[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithTimeout", timeout)
	ret0, _ := ret[0].(types.SubscribeOption[T])
	return ret0
}

// WithTimeout indicates an expected call of WithTimeout.
func (mr *MockEventBusHooksMetricsOptionsMockRecorder[T]) WithTimeout(timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithTimeout", reflect.TypeOf((*MockEventBusHooksMetricsOptions[T])(nil).WithTimeout), timeout)
}
