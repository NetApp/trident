// Code generated by go-swagger; DO NOT EDIT.

package n_a_s

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new n a s API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for n a s API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	ActiveDirectoryCollectionGet(params *ActiveDirectoryCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryCollectionGetOK, error)

	ActiveDirectoryCreate(params *ActiveDirectoryCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryCreateCreated, error)

	ActiveDirectoryDelete(params *ActiveDirectoryDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryDeleteOK, error)

	ActiveDirectoryGet(params *ActiveDirectoryGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryGetOK, error)

	ActiveDirectoryModify(params *ActiveDirectoryModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryModifyOK, error)

	ActiveDirectoryPreferredDcCollectionGet(params *ActiveDirectoryPreferredDcCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryPreferredDcCollectionGetOK, error)

	ActiveDirectoryPreferredDcCreate(params *ActiveDirectoryPreferredDcCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryPreferredDcCreateCreated, error)

	ActiveDirectoryPreferredDcDelete(params *ActiveDirectoryPreferredDcDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryPreferredDcDeleteOK, error)

	ActiveDirectoryPreferredDcGet(params *ActiveDirectoryPreferredDcGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryPreferredDcGetOK, error)

	AuditCollectionGet(params *AuditCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AuditCollectionGetOK, error)

	AuditCreate(params *AuditCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AuditCreateAccepted, error)

	AuditDelete(params *AuditDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AuditDeleteAccepted, error)

	AuditGet(params *AuditGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AuditGetOK, error)

	AuditModify(params *AuditModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AuditModifyAccepted, error)

	CifsCollectionPerformanceMetricsGet(params *CifsCollectionPerformanceMetricsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsCollectionPerformanceMetricsGetOK, error)

	CifsConnectionCollectionGet(params *CifsConnectionCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsConnectionCollectionGetOK, error)

	CifsDomainCollectionGet(params *CifsDomainCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsDomainCollectionGetOK, error)

	CifsDomainGet(params *CifsDomainGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsDomainGetOK, error)

	CifsDomainPreferredDcCollectionGet(params *CifsDomainPreferredDcCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsDomainPreferredDcCollectionGetOK, error)

	CifsDomainPreferredDcCreate(params *CifsDomainPreferredDcCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsDomainPreferredDcCreateCreated, error)

	CifsDomainPreferredDcDelete(params *CifsDomainPreferredDcDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsDomainPreferredDcDeleteOK, error)

	CifsDomainPreferredDcGet(params *CifsDomainPreferredDcGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsDomainPreferredDcGetOK, error)

	CifsHomedirSearchPathGet(params *CifsHomedirSearchPathGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsHomedirSearchPathGetOK, error)

	CifsOpenFileCollectionGet(params *CifsOpenFileCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsOpenFileCollectionGetOK, error)

	CifsOpenFileDelete(params *CifsOpenFileDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsOpenFileDeleteOK, error)

	CifsOpenFileGet(params *CifsOpenFileGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsOpenFileGetOK, error)

	CifsSearchPathCollectionGet(params *CifsSearchPathCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSearchPathCollectionGetOK, error)

	CifsSearchPathCreate(params *CifsSearchPathCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSearchPathCreateCreated, error)

	CifsSearchPathDelete(params *CifsSearchPathDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSearchPathDeleteOK, error)

	CifsSearchPathModify(params *CifsSearchPathModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSearchPathModifyOK, error)

	CifsServiceCollectionGet(params *CifsServiceCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsServiceCollectionGetOK, error)

	CifsServiceCreate(params *CifsServiceCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsServiceCreateAccepted, error)

	CifsServiceDelete(params *CifsServiceDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsServiceDeleteAccepted, error)

	CifsServiceGet(params *CifsServiceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsServiceGetOK, error)

	CifsServiceModify(params *CifsServiceModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsServiceModifyAccepted, error)

	CifsSessionCollectionGet(params *CifsSessionCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSessionCollectionGetOK, error)

	CifsSessionDelete(params *CifsSessionDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSessionDeleteOK, error)

	CifsSessionGet(params *CifsSessionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSessionGetOK, error)

	CifsShareACLCollectionGet(params *CifsShareACLCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareACLCollectionGetOK, error)

	CifsShareACLCreate(params *CifsShareACLCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareACLCreateCreated, error)

	CifsShareACLDelete(params *CifsShareACLDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareACLDeleteOK, error)

	CifsShareACLGet(params *CifsShareACLGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareACLGetOK, error)

	CifsShareACLModify(params *CifsShareACLModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareACLModifyOK, error)

	CifsShareCollectionGet(params *CifsShareCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareCollectionGetOK, error)

	CifsShareCreate(params *CifsShareCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareCreateCreated, error)

	CifsShareDelete(params *CifsShareDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareDeleteOK, error)

	CifsShareGet(params *CifsShareGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareGetOK, error)

	CifsShareModify(params *CifsShareModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareModifyOK, error)

	CifsSymlinkMappingCollectionGet(params *CifsSymlinkMappingCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSymlinkMappingCollectionGetOK, error)

	CifsSymlinkMappingCreate(params *CifsSymlinkMappingCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSymlinkMappingCreateCreated, error)

	CifsSymlinkMappingDelete(params *CifsSymlinkMappingDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSymlinkMappingDeleteOK, error)

	CifsSymlinkMappingGet(params *CifsSymlinkMappingGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSymlinkMappingGetOK, error)

	CifsSymlinkMappingModify(params *CifsSymlinkMappingModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSymlinkMappingModifyOK, error)

	ClientLockCollectionGet(params *ClientLockCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClientLockCollectionGetOK, error)

	ClientLockDelete(params *ClientLockDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClientLockDeleteOK, error)

	ClientLockGet(params *ClientLockGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClientLockGetOK, error)

	EffectivePermissionGet(params *EffectivePermissionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*EffectivePermissionGetOK, error)

	ExportPolicyCollectionGet(params *ExportPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportPolicyCollectionGetOK, error)

	ExportPolicyCreate(params *ExportPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportPolicyCreateCreated, error)

	ExportPolicyDelete(params *ExportPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportPolicyDeleteOK, error)

	ExportPolicyGet(params *ExportPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportPolicyGetOK, error)

	ExportPolicyModify(params *ExportPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportPolicyModifyOK, error)

	ExportRuleClientsCreate(params *ExportRuleClientsCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleClientsCreateCreated, error)

	ExportRuleClientsDelete(params *ExportRuleClientsDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleClientsDeleteOK, error)

	ExportRuleClientsGet(params *ExportRuleClientsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleClientsGetOK, error)

	ExportRuleCollectionGet(params *ExportRuleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleCollectionGetOK, error)

	ExportRuleCreate(params *ExportRuleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleCreateCreated, error)

	ExportRuleDelete(params *ExportRuleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleDeleteOK, error)

	ExportRuleGet(params *ExportRuleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleGetOK, error)

	ExportRuleModify(params *ExportRuleModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleModifyOK, error)

	FileDirectorySecurityACLCreate(params *FileDirectorySecurityACLCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileDirectorySecurityACLCreateAccepted, error)

	FileDirectorySecurityACLDelete(params *FileDirectorySecurityACLDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileDirectorySecurityACLDeleteAccepted, error)

	FileDirectorySecurityACLModify(params *FileDirectorySecurityACLModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileDirectorySecurityACLModifyAccepted, error)

	FileDirectorySecurityCreate(params *FileDirectorySecurityCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileDirectorySecurityCreateAccepted, error)

	FileDirectorySecurityDelete(params *FileDirectorySecurityDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileDirectorySecurityDeleteOK, error)

	FileDirectorySecurityGet(params *FileDirectorySecurityGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileDirectorySecurityGetOK, error)

	FileDirectorySecurityModify(params *FileDirectorySecurityModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileDirectorySecurityModifyAccepted, error)

	FpolicyCollectionGet(params *FpolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyCollectionGetOK, error)

	FpolicyConnectionCollectionGet(params *FpolicyConnectionCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyConnectionCollectionGetOK, error)

	FpolicyConnectionGet(params *FpolicyConnectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyConnectionGetOK, error)

	FpolicyConnectionModify(params *FpolicyConnectionModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyConnectionModifyOK, error)

	FpolicyCreate(params *FpolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyCreateCreated, error)

	FpolicyDelete(params *FpolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyDeleteOK, error)

	FpolicyEngineCollectionGet(params *FpolicyEngineCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEngineCollectionGetOK, error)

	FpolicyEngineCreate(params *FpolicyEngineCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEngineCreateCreated, error)

	FpolicyEngineDelete(params *FpolicyEngineDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEngineDeleteOK, error)

	FpolicyEngineGet(params *FpolicyEngineGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEngineGetOK, error)

	FpolicyEngineModify(params *FpolicyEngineModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEngineModifyOK, error)

	FpolicyEventCollectionGet(params *FpolicyEventCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEventCollectionGetOK, error)

	FpolicyEventCreate(params *FpolicyEventCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEventCreateCreated, error)

	FpolicyEventDelete(params *FpolicyEventDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEventDeleteOK, error)

	FpolicyEventModify(params *FpolicyEventModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEventModifyOK, error)

	FpolicyEventsGet(params *FpolicyEventsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEventsGetOK, error)

	FpolicyGet(params *FpolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyGetOK, error)

	FpolicyPolicyCollectionGet(params *FpolicyPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyPolicyCollectionGetOK, error)

	FpolicyPolicyCreate(params *FpolicyPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyPolicyCreateCreated, error)

	FpolicyPolicyDelete(params *FpolicyPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyPolicyDeleteOK, error)

	FpolicyPolicyGet(params *FpolicyPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyPolicyGetOK, error)

	FpolicyPolicyModify(params *FpolicyPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyPolicyModifyOK, error)

	GroupPoliciesToBeAppliedModify(params *GroupPoliciesToBeAppliedModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPoliciesToBeAppliedModifyOK, error)

	GroupPolicyObjectCentralAccessPolicyCollectionGet(params *GroupPolicyObjectCentralAccessPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectCentralAccessPolicyCollectionGetOK, error)

	GroupPolicyObjectCentralAccessPolicyGet(params *GroupPolicyObjectCentralAccessPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectCentralAccessPolicyGetOK, error)

	GroupPolicyObjectCentralAccessRuleCollectionGet(params *GroupPolicyObjectCentralAccessRuleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectCentralAccessRuleCollectionGetOK, error)

	GroupPolicyObjectCentralAccessRuleGet(params *GroupPolicyObjectCentralAccessRuleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectCentralAccessRuleGetOK, error)

	GroupPolicyObjectCollectionGet(params *GroupPolicyObjectCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectCollectionGetOK, error)

	GroupPolicyObjectGet(params *GroupPolicyObjectGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectGetOK, error)

	GroupPolicyObjectRestrictedGroupCollectionGet(params *GroupPolicyObjectRestrictedGroupCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectRestrictedGroupCollectionGetOK, error)

	GroupPolicyObjectRestrictedGroupGet(params *GroupPolicyObjectRestrictedGroupGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectRestrictedGroupGetOK, error)

	KerberosInterfaceCollectionGet(params *KerberosInterfaceCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosInterfaceCollectionGetOK, error)

	KerberosInterfaceGet(params *KerberosInterfaceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosInterfaceGetOK, error)

	KerberosInterfaceModify(params *KerberosInterfaceModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosInterfaceModifyOK, error)

	KerberosRealmCollectionGet(params *KerberosRealmCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosRealmCollectionGetOK, error)

	KerberosRealmCreate(params *KerberosRealmCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosRealmCreateCreated, error)

	KerberosRealmDelete(params *KerberosRealmDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosRealmDeleteOK, error)

	KerberosRealmGet(params *KerberosRealmGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosRealmGetOK, error)

	KerberosRealmModify(params *KerberosRealmModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosRealmModifyOK, error)

	LocalCifsGroupCollectionGet(params *LocalCifsGroupCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupCollectionGetOK, error)

	LocalCifsGroupCreate(params *LocalCifsGroupCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupCreateCreated, error)

	LocalCifsGroupDelete(params *LocalCifsGroupDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupDeleteOK, error)

	LocalCifsGroupGet(params *LocalCifsGroupGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupGetOK, error)

	LocalCifsGroupMembersBulkDelete(params *LocalCifsGroupMembersBulkDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupMembersBulkDeleteOK, error)

	LocalCifsGroupMembersCollectionGet(params *LocalCifsGroupMembersCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupMembersCollectionGetOK, error)

	LocalCifsGroupMembersCreate(params *LocalCifsGroupMembersCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupMembersCreateCreated, error)

	LocalCifsGroupMembersDelete(params *LocalCifsGroupMembersDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupMembersDeleteOK, error)

	LocalCifsGroupMembersGet(params *LocalCifsGroupMembersGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupMembersGetOK, error)

	LocalCifsGroupModify(params *LocalCifsGroupModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupModifyOK, error)

	LocalCifsUserCollectionGet(params *LocalCifsUserCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUserCollectionGetOK, error)

	LocalCifsUserCreate(params *LocalCifsUserCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUserCreateCreated, error)

	LocalCifsUserDelete(params *LocalCifsUserDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUserDeleteOK, error)

	LocalCifsUserGet(params *LocalCifsUserGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUserGetOK, error)

	LocalCifsUserModify(params *LocalCifsUserModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUserModifyOK, error)

	LocalCifsUsersAndGroupsImportCreate(params *LocalCifsUsersAndGroupsImportCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUsersAndGroupsImportCreateAccepted, error)

	LocalCifsUsersAndGroupsImportGet(params *LocalCifsUsersAndGroupsImportGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUsersAndGroupsImportGetOK, error)

	LocalCifsUsersAndGroupsImportModify(params *LocalCifsUsersAndGroupsImportModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUsersAndGroupsImportModifyAccepted, error)

	NetbiosCollectionGet(params *NetbiosCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NetbiosCollectionGetOK, error)

	NfsClientsCacheGet(params *NfsClientsCacheGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsClientsCacheGetOK, error)

	NfsClientsCacheModify(params *NfsClientsCacheModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsClientsCacheModifyOK, error)

	NfsClientsGet(params *NfsClientsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsClientsGetOK, error)

	NfsClientsMapGet(params *NfsClientsMapGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsClientsMapGetOK, error)

	NfsCollectionGet(params *NfsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsCollectionGetOK, error)

	NfsCollectionPerformanceMetricsGet(params *NfsCollectionPerformanceMetricsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsCollectionPerformanceMetricsGetOK, error)

	NfsCreate(params *NfsCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsCreateCreated, error)

	NfsDelete(params *NfsDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsDeleteOK, error)

	NfsGet(params *NfsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsGetOK, error)

	NfsModify(params *NfsModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsModifyOK, error)

	PoliciesAndRulesToBeAppliedCollectionGet(params *PoliciesAndRulesToBeAppliedCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PoliciesAndRulesToBeAppliedCollectionGetOK, error)

	PoliciesAndRulesToBeAppliedGet(params *PoliciesAndRulesToBeAppliedGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PoliciesAndRulesToBeAppliedGetOK, error)

	S3AuditCreate(params *S3AuditCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*S3AuditCreateAccepted, error)

	S3AuditDelete(params *S3AuditDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*S3AuditDeleteAccepted, error)

	S3AuditGet(params *S3AuditGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*S3AuditGetOK, error)

	S3AuditModify(params *S3AuditModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*S3AuditModifyAccepted, error)

	ShadowcopyCollectionGet(params *ShadowcopyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShadowcopyCollectionGetOK, error)

	ShadowcopyGet(params *ShadowcopyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShadowcopyGetOK, error)

	ShadowcopyModify(params *ShadowcopyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShadowcopyModifyOK, error)

	ShadowcopySetCollectionGet(params *ShadowcopySetCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShadowcopySetCollectionGetOK, error)

	ShadowcopySetGet(params *ShadowcopySetGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShadowcopySetGetOK, error)

	ShadowcopySetModify(params *ShadowcopySetModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShadowcopySetModifyOK, error)

	UserGroupPrivilegesCollectionGet(params *UserGroupPrivilegesCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserGroupPrivilegesCollectionGetOK, error)

	UserGroupPrivilegesCreate(params *UserGroupPrivilegesCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserGroupPrivilegesCreateCreated, error)

	UserGroupPrivilegesGet(params *UserGroupPrivilegesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserGroupPrivilegesGetOK, error)

	UserGroupPrivilegesModify(params *UserGroupPrivilegesModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserGroupPrivilegesModifyOK, error)

	VscanCollectionGet(params *VscanCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanCollectionGetOK, error)

	VscanConfigDelete(params *VscanConfigDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanConfigDeleteOK, error)

	VscanCreate(params *VscanCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanCreateCreated, error)

	VscanEventCollectionGet(params *VscanEventCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanEventCollectionGetOK, error)

	VscanGet(params *VscanGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanGetOK, error)

	VscanModify(params *VscanModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanModifyOK, error)

	VscanOnAccessCreate(params *VscanOnAccessCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnAccessCreateCreated, error)

	VscanOnAccessDelete(params *VscanOnAccessDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnAccessDeleteOK, error)

	VscanOnAccessGet(params *VscanOnAccessGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnAccessGetOK, error)

	VscanOnAccessModify(params *VscanOnAccessModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnAccessModifyOK, error)

	VscanOnAccessPolicyCollectionGet(params *VscanOnAccessPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnAccessPolicyCollectionGetOK, error)

	VscanOnDemandCreate(params *VscanOnDemandCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnDemandCreateCreated, error)

	VscanOnDemandDelete(params *VscanOnDemandDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnDemandDeleteOK, error)

	VscanOnDemandGet(params *VscanOnDemandGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnDemandGetOK, error)

	VscanOnDemandModify(params *VscanOnDemandModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnDemandModifyOK, error)

	VscanOnDemandPolicyCollectionGet(params *VscanOnDemandPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnDemandPolicyCollectionGetOK, error)

	VscanScannerCollectionGet(params *VscanScannerCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanScannerCollectionGetOK, error)

	VscanScannerCreate(params *VscanScannerCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanScannerCreateCreated, error)

	VscanScannerDelete(params *VscanScannerDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanScannerDeleteOK, error)

	VscanScannerModify(params *VscanScannerModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanScannerModifyOK, error)

	VscanScannerPoolGet(params *VscanScannerPoolGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanScannerPoolGetOK, error)

	VscanServerStatusGet(params *VscanServerStatusGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanServerStatusGetOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
	ActiveDirectoryCollectionGet Retrieves Active Directory accounts for all SVMs.

### Related ONTAP commands
* `vserver active-directory show`
* `vserver active-directory preferred-dc show`
* `vserver active-directory discovered-servers show`
*/
func (a *Client) ActiveDirectoryCollectionGet(params *ActiveDirectoryCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewActiveDirectoryCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "active_directory_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/active-directory",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ActiveDirectoryCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ActiveDirectoryCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ActiveDirectoryCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ActiveDirectoryCreate Creates an Active Directory account for a given SVM.

### Related ONTAP commands
* `vserver active-directory create`
### Important notes
* Active Directory account creation is asynchronous. Response contains Task UUID and Link that can be queried to get the status.
*/
func (a *Client) ActiveDirectoryCreate(params *ActiveDirectoryCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewActiveDirectoryCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "active_directory_create",
		Method:             "POST",
		PathPattern:        "/protocols/active-directory",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ActiveDirectoryCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ActiveDirectoryCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ActiveDirectoryCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ActiveDirectoryDelete Deletes the Active Directory account for a given SVM.

### Related ONTAP commands
* `vserver active-directory delete`
### Important notes
* Active Directory account deletion is asynchronous. Response contains Task UUID and Link that can be queried to get the status.
*/
func (a *Client) ActiveDirectoryDelete(params *ActiveDirectoryDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewActiveDirectoryDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "active_directory_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/active-directory/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ActiveDirectoryDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ActiveDirectoryDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ActiveDirectoryDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ActiveDirectoryGet Retrieves the Active Directory account for a given SVM.

### Related ONTAP commands
* `vserver active-directory show`
* `vserver active-directory preferred-dc show`
* `vserver active-directory discovered-servers show`
* `vserver active-directory discovered-servers reset-servers`
*/
func (a *Client) ActiveDirectoryGet(params *ActiveDirectoryGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewActiveDirectoryGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "active_directory_get",
		Method:             "GET",
		PathPattern:        "/protocols/active-directory/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ActiveDirectoryGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ActiveDirectoryGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ActiveDirectoryGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ActiveDirectoryModify Modifies the Active Directory account for a given SVM.

### Related ONTAP commands
* `vserver active-directory modify`
### Important notes
* Patching Active Directory account is asynchronous. Response contains Task UUID and Link that can be queried to get the status.
*/
func (a *Client) ActiveDirectoryModify(params *ActiveDirectoryModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewActiveDirectoryModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "active_directory_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/active-directory/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ActiveDirectoryModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ActiveDirectoryModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ActiveDirectoryModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ActiveDirectoryPreferredDcCollectionGet Retrieves the Active Directory preferred DC configuration of an SVM.

### Related ONTAP commands
* `vserver active-directory preferred-dc show`
*/
func (a *Client) ActiveDirectoryPreferredDcCollectionGet(params *ActiveDirectoryPreferredDcCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryPreferredDcCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewActiveDirectoryPreferredDcCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "active_directory_preferred_dc_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/active-directory/{svm.uuid}/preferred-domain-controllers",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ActiveDirectoryPreferredDcCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ActiveDirectoryPreferredDcCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ActiveDirectoryPreferredDcCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ActiveDirectoryPreferredDcCreate Creates an Active Directory preferred DC configuration for an SVM.

### Required properties
* `svm.uuid` - Existing SVM in which to create the preferred DC.
* `domain` - Fully Qualified Domain Name.
* `server_ip` - IPv4/IPv6 address of the preferred DC.
#### The following parameters are optional:
- skip_config_validation
### Related ONTAP commands
* `vserver active-directory preferred-dc add`
*/
func (a *Client) ActiveDirectoryPreferredDcCreate(params *ActiveDirectoryPreferredDcCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryPreferredDcCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewActiveDirectoryPreferredDcCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "active_directory_preferred_dc_create",
		Method:             "POST",
		PathPattern:        "/protocols/active-directory/{svm.uuid}/preferred-domain-controllers",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ActiveDirectoryPreferredDcCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ActiveDirectoryPreferredDcCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ActiveDirectoryPreferredDcCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ActiveDirectoryPreferredDcDelete Deletes the Active Directory preferred DC configuration of the specified SVM and domain.

### Related ONTAP commands
* `vserver active-directory preferred-dc delete`
*/
func (a *Client) ActiveDirectoryPreferredDcDelete(params *ActiveDirectoryPreferredDcDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryPreferredDcDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewActiveDirectoryPreferredDcDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "active_directory_preferred_dc_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/active-directory/{svm.uuid}/preferred-domain-controllers/{fqdn}/{server_ip}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ActiveDirectoryPreferredDcDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ActiveDirectoryPreferredDcDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ActiveDirectoryPreferredDcDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ActiveDirectoryPreferredDcGet Retrieves the Active Directory preferred DC configuration of an SVM.

### Related ONTAP commands
* `vserver active-directory preferred-dc show`
*/
func (a *Client) ActiveDirectoryPreferredDcGet(params *ActiveDirectoryPreferredDcGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ActiveDirectoryPreferredDcGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewActiveDirectoryPreferredDcGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "active_directory_preferred_dc_get",
		Method:             "GET",
		PathPattern:        "/protocols/active-directory/{svm.uuid}/preferred-domain-controllers/{fqdn}/{server_ip}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ActiveDirectoryPreferredDcGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ActiveDirectoryPreferredDcGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ActiveDirectoryPreferredDcGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	AuditCollectionGet Retrieves audit configurations.

### Related ONTAP commands
* `vserver audit show`
### Learn more
* [`DOC /protocols/audit`](#docs-NAS-protocols_audit)
*/
func (a *Client) AuditCollectionGet(params *AuditCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AuditCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAuditCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "audit_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/audit",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AuditCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AuditCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AuditCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	AuditCreate Creates an audit configuration.

### Required properties
* `svm.uuid` or `svm.name` - Existing SVM to which audit configuration is to be created.
* `log_path` - Path in the owning SVM namespace that is used to store audit logs.
### Default property values
If not specified in POST, the following default property values are assigned:
* `enabled` - _true_
* `events.authorization_policy` - _false_
* `events.cap_staging` - _false_
* `events.file_share` - _false_
* `events.security_group` - _false_
* `events.user_account` - _false_
* `events.cifs_logon_logoff` - _true_
* `events.file_operations` - _true_
* `log.format` - _evtx_
* `log.retention.count` - _0_
* `log.retention.duration` - _PT0S_
* `log.rotation.size` - _100MB_
* `log.rotation.now` - _false_
* `guarantee` - _true_
### Related ONTAP commands
* `vserver audit create`
* `vserver audit enable`
### Learn more
* [`DOC /protocols/audit`](#docs-NAS-protocols_audit)
*/
func (a *Client) AuditCreate(params *AuditCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AuditCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAuditCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "audit_create",
		Method:             "POST",
		PathPattern:        "/protocols/audit",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AuditCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AuditCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AuditCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	AuditDelete Deletes an audit configuration.

### Related ONTAP commands
* `vserver audit disable`
* `vserver audit delete`
### Learn more
* [`DOC /protocols/audit`](#docs-NAS-protocols_audit)
*/
func (a *Client) AuditDelete(params *AuditDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AuditDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAuditDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "audit_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/audit/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AuditDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AuditDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AuditDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	AuditGet Retrieves an audit configuration for an SVM.

### Related ONTAP commands
* `vserver audit show`
### Learn more
* [`DOC /protocols/audit`](#docs-NAS-protocols_audit)
*/
func (a *Client) AuditGet(params *AuditGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AuditGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAuditGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "audit_get",
		Method:             "GET",
		PathPattern:        "/protocols/audit/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AuditGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AuditGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AuditGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	AuditModify Updates an audit configuration for an SVM.

### Related ONTAP commands
* `vserver audit modify`
### Learn more
* [`DOC /protocols/audit`](#docs-NAS-protocols_audit)
*/
func (a *Client) AuditModify(params *AuditModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AuditModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAuditModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "audit_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/audit/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AuditModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AuditModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AuditModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CifsCollectionPerformanceMetricsGet Retrieves historical performance metrics for the CIFS protocol of an SVM.
*/
func (a *Client) CifsCollectionPerformanceMetricsGet(params *CifsCollectionPerformanceMetricsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsCollectionPerformanceMetricsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsCollectionPerformanceMetricsGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_collection_performance_metrics_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/services/{svm.uuid}/metrics",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsCollectionPerformanceMetricsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsCollectionPerformanceMetricsGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsCollectionPerformanceMetricsGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsConnectionCollectionGet Retrieves the CIFS connection information for all SVMs.

### Related ONTAP commands
  - `vserver cifs connection show`

### Learn more
* [`DOC /protocols/cifs/connections`](#docs-NAS-protocols_cifs_connections)
*/
func (a *Client) CifsConnectionCollectionGet(params *CifsConnectionCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsConnectionCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsConnectionCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_connection_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/connections",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsConnectionCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsConnectionCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsConnectionCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsDomainCollectionGet Retrieves the CIFS domain-related information of all SVMs.

### Related ONTAP commands
* `vserver cifs domain preferred-dc show`
* `vserver cifs domain trusts show`
* `vserver cifs domain discovered-servers show`
* `vserver cifs domain name-mapping-search show`
* `vserver cifs domain schedule show`
### Learn more
* [`DOC /protocols/cifs/domains`](#docs-NAS-protocols_cifs_domains)
*/
func (a *Client) CifsDomainCollectionGet(params *CifsDomainCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsDomainCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsDomainCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_domain_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/domains",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsDomainCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsDomainCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsDomainCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsDomainGet Retrieves the CIFS domain-related information of the specified SVM.

### Important notes
GET operation with query parameter `rediscover_trusts` and `reset_discovered_servers` returns available CIFS domain configurations and also triggers trusts rediscovery and discovered servers reset asynchronously for that SVM.
### Related ONTAP commands
* `vserver cifs domain preferred-dc show`
* `vserver cifs domain trusts show`
* `vserver cifs domain discovered-servers show`
* `vserver cifs domain name-mapping-search show`
* `vserver cifs domain schedule show`
### Learn more
* [`DOC /protocols/cifs/domains/{svm.uuid}`](#docs-NAS-protocols_cifs_domains_{svm.uuid})
*/
func (a *Client) CifsDomainGet(params *CifsDomainGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsDomainGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsDomainGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_domain_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/domains/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsDomainGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsDomainGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsDomainGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsDomainPreferredDcCollectionGet Retrieves the CIFS domain preferred DC configuration of an SVM.

### Related ONTAP commands
* `vserver cifs domain preferred-dc show`
* `vserver cifs domain preferred-dc check`
### Learn more
* [`DOC /protocols/cifs/domains/{svm.uuid}/preferred-domain-controllers`](#docs-NAS-protocols_cifs_domains_{svm.uuid}_preferred-domain-controllers)
*/
func (a *Client) CifsDomainPreferredDcCollectionGet(params *CifsDomainPreferredDcCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsDomainPreferredDcCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsDomainPreferredDcCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_domain_preferred_dc_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/domains/{svm.uuid}/preferred-domain-controllers",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsDomainPreferredDcCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsDomainPreferredDcCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsDomainPreferredDcCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsDomainPreferredDcCreate Creates a CIFS preferred DC configuration for an SVM.

### Important notes
* In the case of bulk POST requests, the create operation should be performed serially since there can be interdependence between records. In order to avoid issues, it is advisable to always use the query parameter "serial_records=true".
### Required properties
* `svm.uuid` - Existing SVM in which to create the preferred-dc.
* `domain` - Fully Qualified Domain Name.
* `server_ip` - IPv4/IPv6 address of the Preferred Domain Controller.
#### The following parameters are optional:
- skip_config_validation
### Related ONTAP commands
* `vserver cifs domain preferred-dc add`
### Learn more
* [`DOC /protocols/cifs/domains/{svm.uuid}/preferred-domain-controllers`](#docs-NAS-protocols_cifs_domains_{svm.uuid}_preferred-domain-controllers)
*/
func (a *Client) CifsDomainPreferredDcCreate(params *CifsDomainPreferredDcCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsDomainPreferredDcCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsDomainPreferredDcCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_domain_preferred_dc_create",
		Method:             "POST",
		PathPattern:        "/protocols/cifs/domains/{svm.uuid}/preferred-domain-controllers",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsDomainPreferredDcCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsDomainPreferredDcCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsDomainPreferredDcCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsDomainPreferredDcDelete Deletes the CIFS domain preferred DC configuration of the specified SVM and domain.

### Related ONTAP commands
* `vserver cifs domain preferred-dc delete`
### Learn more
* [`DOC /protocols/cifs/domains/{svm.uuid}/preferred-domain-controllers`](#docs-NAS-protocols_cifs_domains_{svm.uuid}_preferred-domain-controllers)
*/
func (a *Client) CifsDomainPreferredDcDelete(params *CifsDomainPreferredDcDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsDomainPreferredDcDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsDomainPreferredDcDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_domain_preferred_dc_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/cifs/domains/{svm.uuid}/preferred-domain-controllers/{fqdn}/{server_ip}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsDomainPreferredDcDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsDomainPreferredDcDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsDomainPreferredDcDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsDomainPreferredDcGet Retrieves the CIFS domain preferred DC configuration of an SVM.

### Related ONTAP commands
* `vserver cifs domain preferred-dc show`
* `vserver cifs domain preferred-dc check`
### Learn more
* [`DOC /protocols/cifs/domains/{svm.uuid}/preferred-domain-controllers`](#docs-NAS-protocols_cifs_domains_{svm.uuid}_preferred-domain-controllers)
*/
func (a *Client) CifsDomainPreferredDcGet(params *CifsDomainPreferredDcGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsDomainPreferredDcGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsDomainPreferredDcGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_domain_preferred_dc_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/domains/{svm.uuid}/preferred-domain-controllers/{fqdn}/{server_ip}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsDomainPreferredDcGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsDomainPreferredDcGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsDomainPreferredDcGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsHomedirSearchPathGet Retrieves a CIFS home directory search path of an SVM.

### Related ONTAP commands
* `cifs server home-directory search-path show`
### Learn more
* [`DOC /protocols/cifs/home-directory/search-paths`](#docs-NAS-protocols_cifs_home-directory_search-paths)
*/
func (a *Client) CifsHomedirSearchPathGet(params *CifsHomedirSearchPathGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsHomedirSearchPathGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsHomedirSearchPathGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_homedir_search_path_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/home-directory/search-paths/{svm.uuid}/{index}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsHomedirSearchPathGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsHomedirSearchPathGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsHomedirSearchPathGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CifsOpenFileCollectionGet Retrieves CIFS Open Files
*/
func (a *Client) CifsOpenFileCollectionGet(params *CifsOpenFileCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsOpenFileCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsOpenFileCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_open_file_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/session/files",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsOpenFileCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsOpenFileCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsOpenFileCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsOpenFileDelete Closes open files identified by svm.uuid, file.identifier, connection.identifier and session_id.

### Learn more
* [`DOC /protocols/cifs/session/files`](#docs-NAS-protocols_cifs_session_files)
*/
func (a *Client) CifsOpenFileDelete(params *CifsOpenFileDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsOpenFileDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsOpenFileDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_open_file_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/cifs/session/files/{node.uuid}/{svm.uuid}/{identifier}/{connection.identifier}/{session.identifier}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsOpenFileDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsOpenFileDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsOpenFileDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CifsOpenFileGet Retrieves specific CIFS Open File
*/
func (a *Client) CifsOpenFileGet(params *CifsOpenFileGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsOpenFileGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsOpenFileGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_open_file_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/session/files/{node.uuid}/{svm.uuid}/{identifier}/{connection.identifier}/{session.identifier}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsOpenFileGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsOpenFileGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsOpenFileGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsSearchPathCollectionGet Retrieves CIFS home directory search paths.

### Related ONTAP commands
* `cifs server home-directory search-path show`
### Learn more
* [`DOC /protocols/cifs/home-directory/search-paths`](#docs-NAS-protocols_cifs_home-directory_search-paths)
*/
func (a *Client) CifsSearchPathCollectionGet(params *CifsSearchPathCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSearchPathCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsSearchPathCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_search_path_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/home-directory/search-paths",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsSearchPathCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsSearchPathCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsSearchPathCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsSearchPathCreate Creates a home directory search path.

### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the home directory search path.
* `path` - Path in the owning SVM namespace that is used to search for home directories.
### Related ONTAP commands
* `cifs server home-directory search-path add`
### Learn more
* [`DOC /protocols/cifs/home-directory/search-paths`](#docs-NAS-protocols_cifs_home-directory_search-paths)
*/
func (a *Client) CifsSearchPathCreate(params *CifsSearchPathCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSearchPathCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsSearchPathCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_search_path_create",
		Method:             "POST",
		PathPattern:        "/protocols/cifs/home-directory/search-paths",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsSearchPathCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsSearchPathCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsSearchPathCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsSearchPathDelete Deletes a CIFS home directory search path.

### Related ONTAP commands
* `cifs server home-directory search-path remove`
### Learn more
* [`DOC /protocols/cifs/home-directory/search-paths`](#docs-NAS-protocols_cifs_home-directory_search-paths)
*/
func (a *Client) CifsSearchPathDelete(params *CifsSearchPathDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSearchPathDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsSearchPathDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_search_path_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/cifs/home-directory/search-paths/{svm.uuid}/{index}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsSearchPathDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsSearchPathDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsSearchPathDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsSearchPathModify Reorders a CIFS home directory search path.

### Related ONTAP commands
* `cifs server home-directory search-path reorder`
### Learn more
* [`DOC /protocols/cifs/home-directory/search-paths`](#docs-NAS-protocols_cifs_home-directory_search-paths)
*/
func (a *Client) CifsSearchPathModify(params *CifsSearchPathModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSearchPathModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsSearchPathModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_search_path_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/cifs/home-directory/search-paths/{svm.uuid}/{index}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsSearchPathModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsSearchPathModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsSearchPathModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsServiceCollectionGet Retrieves CIFS servers.

### Expensive properties
There is an added computational cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
* `statistics.*`
* `metric.*`
### Related ONTAP commands
* `vserver cifs server show`
* `vserver cifs server options show`
* `vserver cifs server security show`
### Learn more
* [`DOC /protocols/cifs/services`](#docs-NAS-protocols_cifs_services)
*/
func (a *Client) CifsServiceCollectionGet(params *CifsServiceCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsServiceCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsServiceCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_service_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/services",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsServiceCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsServiceCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsServiceCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsServiceCreate Creates a CIFS server. Each SVM can have one CIFS server.</br>

### Important notes
- The CIFS server name might or might not be the same as the SVM name.
- The CIFS server name can contain up to 15 characters.
- The CIFS server name does not support the following characters: @ # * ( ) = + [ ] | ; : " , < >  / ?
### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the CIFS server.
* `name` -  Name of the CIFS server.
* `ad_domain.fqdn` - Fully qualified domain name of the Windows Active Directory to which this CIFS server belongs.
* `ad_domain.user` - User account with the access to add the CIFS server to the Active Directory.
* `ad_domain.password` - Account password used to add this CIFS server to the Active Directory.
### Recommended optional properties
* `comment` - Add a text comment of up to 48 characters about the CIFS server.
* `netbios.aliases` - Add a comma-delimited list of one or more NetBIOS aliases for the CIFS server.
* `netbios.wins_servers` - Add a list of Windows Internet Name Server (WINS) addresses that manage and map the NetBIOS name of the CIFS server to their network IP addresses. The IP addresses must be IPv4 addresses.
### Default property values
If not specified in POST, the following default property values are assigned:
* `ad_domain.organizational_unit` - _CN=Computers_
* `enabled` - _true_
* `restrict_anonymous` - _no_enumeration_
* `smb_signing` - _false_
* `smb_encryption` - _false_
* `encrypt_dc_connection` - _false_
* `kdc_encryption` - _false_
* `default_unix_user` - _pcuser_
* `netbios_enabled` - _false_ However, if either "netbios.wins-server" or "netbios.aliases" is set during POST and if `netbios_enabled` is not specified then `netbios_enabled` is set to true.
* `aes_netlogon_enabled` - _false_
* `try_ldap_channel_binding` - _true_
* `ldap_referral_enabled` - _false_
### Related ONTAP commands
* `vserver cifs server create`
* `vserver cifs server options modify`
* `vserver cifs security modify`
* `vserver cifs server add-netbios-aliases`
### Learn more
* [`DOC /protocols/cifs/services`](#docs-NAS-protocols_cifs_services)
*/
func (a *Client) CifsServiceCreate(params *CifsServiceCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsServiceCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsServiceCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_service_create",
		Method:             "POST",
		PathPattern:        "/protocols/cifs/services",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsServiceCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsServiceCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsServiceCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsServiceDelete Deletes a CIFS server and related CIFS configurations.<br/>

If "force" field is set along with user login credentials, the local CIFS configuration will be deleted irrespective of any communication errors. The default value for this field is false.
If "force" field alone is set without passing the user login credentials, the local CIFS configuration will be deleted by not making any request to Active Directory, but the option will be enable only for the VseverDR enabled SVMs. The default value for this field is false.
### Related ONTAP commands
* `vserver cifs server delete`
* `vserver cifs remove-netbios-aliases`
### Learn more
* [`DOC /protocols/cifs/services`](#docs-NAS-protocols_cifs_services)
*/
func (a *Client) CifsServiceDelete(params *CifsServiceDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsServiceDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsServiceDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_service_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/cifs/services/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsServiceDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsServiceDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsServiceDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsServiceGet Retrieves a CIFS server.

### Related ONTAP commands
* `vserver cifs server show`
* `vserver cifs server options show`
* `vserver cifs server security show`
### Learn more
* [`DOC /protocols/cifs/services`](#docs-NAS-protocols_cifs_services)
*/
func (a *Client) CifsServiceGet(params *CifsServiceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsServiceGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsServiceGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_service_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/services/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsServiceGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsServiceGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsServiceGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsServiceModify Updates both the mandatory and optional parameters of the CIFS configuration. Ensure the CIFS server is administratively disabled when renaming the CIFS server or modifying the <i>ad_domain</i> properties.

### Related ONTAP commands
* `vserver cifs server modify`
* `vserver cifs server options modify`
* `vserver cifs security modify`
* `vserver cifs server add-netbios-aliases`
* `vserver cifs server remove-netbios-aliases`
### Learn more
* [`DOC /protocols/cifs/services`](#docs-NAS-protocols_cifs_services)
*/
func (a *Client) CifsServiceModify(params *CifsServiceModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsServiceModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsServiceModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_service_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/cifs/services/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsServiceModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsServiceModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsServiceModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsSessionCollectionGet Retrieves the CIFS sessions information for all SVMs.

### Related ONTAP commands
  - `vserver cifs session show -active-volumes`

### Learn more
* [`DOC /protocols/cifs/sessions`](#docs-NAS-protocols_cifs_sessions)
*/
func (a *Client) CifsSessionCollectionGet(params *CifsSessionCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSessionCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsSessionCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_session_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/sessions",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsSessionCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsSessionCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsSessionCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsSessionDelete Deletes SMB session information on a node for an SVM.

* To delete the specific SMB session information, pass the relavant SMB session's identifier and connection Id.
* To delete all the SMB session information on specific node and SVM, pass the both SMB session's identifier and connection Id as zero(0)
* To delete all the SMB session information on specific connection, pass the specific SMB session's Identifier value as zero(0).
* To delete all the SMB session information on specific Identifier alone is not allowed.
### Learn more
* [`DOC /protocols/cifs/sessions`](#docs-NAS-protocols_cifs_sessions)
*/
func (a *Client) CifsSessionDelete(params *CifsSessionDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSessionDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsSessionDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_session_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/cifs/sessions/{node.uuid}/{svm.uuid}/{identifier}/{connection_id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsSessionDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsSessionDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsSessionDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsSessionGet Retrieves specific SMB session information for a specific SMB connection in a node on an SVM.

### Learn more
* [`DOC /protocols/cifs/sessions`](#docs-NAS-protocols_cifs_sessions)
*/
func (a *Client) CifsSessionGet(params *CifsSessionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSessionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsSessionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_session_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/sessions/{node.uuid}/{svm.uuid}/{identifier}/{connection_id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsSessionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsSessionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsSessionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsShareACLCollectionGet Retrieves the share-level ACL on a CIFS share.

### Related ONTAP commands
* `vserver cifs share access-control show`
### Learn more
* [`DOC /protocols/cifs/shares/{svm.uuid}/{share}/acls`](#docs-NAS-protocols_cifs_shares_{svm.uuid}_{share}_acls)
*/
func (a *Client) CifsShareACLCollectionGet(params *CifsShareACLCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareACLCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsShareACLCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_share_acl_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/shares/{svm.uuid}/{share}/acls",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsShareACLCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsShareACLCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsShareACLCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsShareACLCreate Creates a share-level ACL on a CIFS share.

### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the share acl.
* `share` - Existing CIFS share in which to create the share acl.
* `user_or_group` - Existing user or group name for which the acl is added on the CIFS share.
* `permission` - Access rights that a user or group has on the defined CIFS share.
### Default property values
* `type` - _windows_
### Related ONTAP commands
* `vserver cifs share access-control create`
### Learn more
* [`DOC /protocols/cifs/shares/{svm.uuid}/{share}/acls`](#docs-NAS-protocols_cifs_shares_{svm.uuid}_{share}_acls)
*/
func (a *Client) CifsShareACLCreate(params *CifsShareACLCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareACLCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsShareACLCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_share_acl_create",
		Method:             "POST",
		PathPattern:        "/protocols/cifs/shares/{svm.uuid}/{share}/acls",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsShareACLCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsShareACLCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsShareACLCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsShareACLDelete Deletes a share-level ACL on a CIFS share.

### Related ONTAP commands
* `vserver cifs share access-control delete`
### Learn more
* [`DOC /protocols/cifs/shares/{svm.uuid}/{share}/acls`](#docs-NAS-protocols_cifs_shares_{svm.uuid}_{share}_acls)
*/
func (a *Client) CifsShareACLDelete(params *CifsShareACLDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareACLDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsShareACLDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_share_acl_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/cifs/shares/{svm.uuid}/{share}/acls/{user_or_group}/{type}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsShareACLDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsShareACLDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsShareACLDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsShareACLGet Retrieves the share-level ACL on CIFS share for a specified user or group.

### Related ONTAP commands
* `vserver cifs share access-control show`
### Learn more
* [`DOC /protocols/cifs/shares/{svm.uuid}/{share}/acls`](#docs-NAS-protocols_cifs_shares_{svm.uuid}_{share}_acls)
*/
func (a *Client) CifsShareACLGet(params *CifsShareACLGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareACLGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsShareACLGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_share_acl_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/shares/{svm.uuid}/{share}/acls/{user_or_group}/{type}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsShareACLGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsShareACLGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsShareACLGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsShareACLModify Updates a share-level ACL on a CIFS share.

### Related ONTAP commands
* `vserver cifs share access-control modify`
### Learn more
* [`DOC /protocols/cifs/shares/{svm.uuid}/{share}/acls`](#docs-NAS-protocols_cifs_shares_{svm.uuid}_{share}_acls)
*/
func (a *Client) CifsShareACLModify(params *CifsShareACLModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareACLModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsShareACLModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_share_acl_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/cifs/shares/{svm.uuid}/{share}/acls/{user_or_group}/{type}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsShareACLModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsShareACLModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsShareACLModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsShareCollectionGet Retrieves CIFS shares.

### Related ONTAP commands
* `vserver cifs share show`
* `vserver cifs share properties show`
### Learn more
* [`DOC /protocols/cifs/shares`](#docs-NAS-protocols_cifs_shares)
*/
func (a *Client) CifsShareCollectionGet(params *CifsShareCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsShareCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_share_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/shares",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsShareCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsShareCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsShareCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsShareCreate Creates a CIFS share.

### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the CIFS share.
* `name` - Name of the CIFS share.
* `path` - Path in the owning SVM namespace that is shared through this share.
### Recommended optional properties
* `comment` - Optionally choose to add a text comment of up to 256 characters about the CIFS share.
* `acls` - Optionally choose to add share permissions that users and groups have on the CIFS share.
### Default property values
If not specified in POST, the following default property values are assigned:
* `home_directory` - _false_
* `oplocks` - _true_
* `access_based_enumeration` - _false_
* `change_notify` - _true_
* `encryption` - _false_
* `unix_symlink` - _local_
### Related ONTAP commands
* `vserver cifs share create`
* `vserver cifs share properties add`
* `vserver cifs share access-control create`
### Learn more
* [`DOC /protocols/cifs/shares`](#docs-NAS-protocols_cifs_shares)
*/
func (a *Client) CifsShareCreate(params *CifsShareCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsShareCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_share_create",
		Method:             "POST",
		PathPattern:        "/protocols/cifs/shares",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsShareCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsShareCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsShareCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsShareDelete Deletes a CIFS share.

### Related ONTAP commands
* `vserver cifs share delete`
### Learn more
* [`DOC /protocols/cifs/shares`](#docs-NAS-protocols_cifs_shares)
*/
func (a *Client) CifsShareDelete(params *CifsShareDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsShareDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_share_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/cifs/shares/{svm.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsShareDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsShareDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsShareDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsShareGet Retrieves a CIFS share.

### Related ONTAP commands
* `vserver cifs share show`
* `vserver cifs share properties show`
### Learn more
* [`DOC /protocols/cifs/shares`](#docs-NAS-protocols_cifs_shares)
*/
func (a *Client) CifsShareGet(params *CifsShareGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsShareGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_share_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/shares/{svm.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsShareGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsShareGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsShareGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsShareModify Updates a CIFS share.

### Related ONTAP commands
* `vserver cifs share modify`
* `vserver cifs share properties add`
* `vserver cifs share properties remove`
### Learn more
* [`DOC /protocols/cifs/shares`](#docs-NAS-protocols_cifs_shares)
*/
func (a *Client) CifsShareModify(params *CifsShareModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsShareModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsShareModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_share_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/cifs/shares/{svm.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsShareModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsShareModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsShareModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsSymlinkMappingCollectionGet Retrieves UNIX symbolic link mappings for CIFS clients.

### Related ONTAP commands
* `vserver cifs symlink show`
### Learn more
* [`DOC /protocols/cifs/unix-symlink-mapping`](#docs-NAS-protocols_cifs_unix-symlink-mapping)
*/
func (a *Client) CifsSymlinkMappingCollectionGet(params *CifsSymlinkMappingCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSymlinkMappingCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsSymlinkMappingCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_symlink_mapping_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/unix-symlink-mapping",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsSymlinkMappingCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsSymlinkMappingCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsSymlinkMappingCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsSymlinkMappingCreate Creates a UNIX symbolic link mapping for a CIFS client.

### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the CIFS unix-symlink-mapping.
* `unix_path` - UNIX path to which the CIFS symlink mapping to be created.
* `target.share` - CIFS share name on the destination CIFS server to which the UNIX symbolic link is pointing.
* `target.path` - CIFS path on the destination to which the symbolic link maps.
### Default property values
* `target.server` - _Local_NetBIOS_Server_Name_
* `locality` - _local_
* `home_directory` - _false_
### Related ONTAP commands
* `vserver cifs symlink create`
### Learn more
* [`DOC /protocols/cifs/unix-symlink-mapping`](#docs-NAS-protocols_cifs_unix-symlink-mapping)
*/
func (a *Client) CifsSymlinkMappingCreate(params *CifsSymlinkMappingCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSymlinkMappingCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsSymlinkMappingCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_symlink_mapping_create",
		Method:             "POST",
		PathPattern:        "/protocols/cifs/unix-symlink-mapping",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsSymlinkMappingCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsSymlinkMappingCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsSymlinkMappingCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsSymlinkMappingDelete Deletes the UNIX symbolic link mapping for CIFS clients.

### Related ONTAP commands
* `vserver cifs symlink delete`
### Learn more
* [`DOC /protocols/cifs/unix-symlink-mapping`](#docs-NAS-protocols_cifs_unix-symlink-mapping)
*/
func (a *Client) CifsSymlinkMappingDelete(params *CifsSymlinkMappingDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSymlinkMappingDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsSymlinkMappingDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_symlink_mapping_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/cifs/unix-symlink-mapping/{svm.uuid}/{unix_path}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsSymlinkMappingDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsSymlinkMappingDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsSymlinkMappingDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsSymlinkMappingGet Retrieves a UNIX symbolic link mapping for CIFS clients.

### Related ONTAP commands
* `vserver cifs symlink show`
### Learn more
* [`DOC /protocols/cifs/unix-symlink-mapping`](#docs-NAS-protocols_cifs_unix-symlink-mapping)
*/
func (a *Client) CifsSymlinkMappingGet(params *CifsSymlinkMappingGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSymlinkMappingGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsSymlinkMappingGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_symlink_mapping_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/unix-symlink-mapping/{svm.uuid}/{unix_path}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsSymlinkMappingGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsSymlinkMappingGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsSymlinkMappingGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CifsSymlinkMappingModify Updates the UNIX symbolic link mapping for CIFS clients.

### Related ONTAP commands
* `vserver cifs symlink modify`
### Learn more
* [`DOC /protocols/cifs/unix-symlink-mapping`](#docs-NAS-protocols_cifs_unix-symlink-mapping)
*/
func (a *Client) CifsSymlinkMappingModify(params *CifsSymlinkMappingModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CifsSymlinkMappingModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCifsSymlinkMappingModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cifs_symlink_mapping_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/cifs/unix-symlink-mapping/{svm.uuid}/{unix_path}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CifsSymlinkMappingModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CifsSymlinkMappingModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CifsSymlinkMappingModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ClientLockCollectionGet Retrieves locks details.

### Related ONTAP commands
* `vserver locks  show`
*/
func (a *Client) ClientLockCollectionGet(params *ClientLockCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClientLockCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClientLockCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "client_lock_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/locks",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClientLockCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClientLockCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClientLockCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ClientLockDelete Deletes locks of given parameter.

### Related ONTAP commands
* `vserver locks break`
*/
func (a *Client) ClientLockDelete(params *ClientLockDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClientLockDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClientLockDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "client_lock_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/locks/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClientLockDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClientLockDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClientLockDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ClientLockGet Retrieves the lock for a specific UUID.

### Related ONTAP commands
* `vserver locks show`
*/
func (a *Client) ClientLockGet(params *ClientLockGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClientLockGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClientLockGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "client_lock_get",
		Method:             "GET",
		PathPattern:        "/protocols/locks/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClientLockGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClientLockGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClientLockGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	EffectivePermissionGet Retrieves effective security permissions on a file.

### Related ONTAP commands
* `vserver security file-directory show-effective-permissions`
*/
func (a *Client) EffectivePermissionGet(params *EffectivePermissionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*EffectivePermissionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEffectivePermissionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "effective_permission_get",
		Method:             "GET",
		PathPattern:        "/protocols/file-security/effective-permissions/{svm.uuid}/{path}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &EffectivePermissionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EffectivePermissionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*EffectivePermissionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExportPolicyCollectionGet Retrieves export policies.

### Related ONTAP commands
* `vserver export-policy show`
* `vserver export-policy rule show`
### Learn more
* [`DOC /protocols/nfs/export-policies`](#docs-NAS-protocols_nfs_export-policies)
*/
func (a *Client) ExportPolicyCollectionGet(params *ExportPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportPolicyCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportPolicyCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "export_policy_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/export-policies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportPolicyCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportPolicyCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExportPolicyCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExportPolicyCreate Creates an export policy. An SVM can have any number of export policies to define rules for which clients can access data exported by the SVM. A policy with no rules prohibits access.

### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create an export policy.
* `name`  - Name of the export policy.
### Recommended optional properties
* `rules`  - Rule(s) of an export policy. Used to create the export rule and populate the export policy with export rules in a single request.
### Related ONTAP commands
* `vserver export-policy create`
* `vserver export-policy rule create`
### Learn more
* [`DOC /protocols/nfs/export-policies`](#docs-NAS-protocols_nfs_export-policies)
*/
func (a *Client) ExportPolicyCreate(params *ExportPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportPolicyCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportPolicyCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "export_policy_create",
		Method:             "POST",
		PathPattern:        "/protocols/nfs/export-policies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportPolicyCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportPolicyCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExportPolicyCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExportPolicyDelete Deletes an export policy.

### Related ONTAP commands
* `vserver export-policy delete`
### Learn more
* [`DOC /protocols/nfs/export-policies`](#docs-NAS-protocols_nfs_export-policies)
*/
func (a *Client) ExportPolicyDelete(params *ExportPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportPolicyDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportPolicyDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "export_policy_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/nfs/export-policies/{id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportPolicyDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportPolicyDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExportPolicyDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExportPolicyGet Retrieves an export policy.

### Related ONTAP commands
* `vserver export-policy show`
* `vserver export-policy rule show`
### Learn more
* [`DOC /protocols/nfs/export-policies`](#docs-NAS-protocols_nfs_export-policies)
*/
func (a *Client) ExportPolicyGet(params *ExportPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportPolicyGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportPolicyGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "export_policy_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/export-policies/{id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportPolicyGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportPolicyGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExportPolicyGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExportPolicyModify Updates the properties of an export policy to change an export policy name or replace all export policy rules.

### Related ONTAP commands
* `vserver export-policy rename`
* `vserver export-policy rule delete`
* `vserver export-policy rule create`
### Learn more
* [`DOC /protocols/nfs/export-policies`](#docs-NAS-protocols_nfs_export-policies)
*/
func (a *Client) ExportPolicyModify(params *ExportPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportPolicyModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportPolicyModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "export_policy_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/nfs/export-policies/{id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportPolicyModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportPolicyModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExportPolicyModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExportRuleClientsCreate Creates an export policy rule client

### Required properties
* `policy.id` - Existing export policy that contains export policy rules for the client being added.
* `index`  - Existing export policy rule for which to create an export client.
* `match`  - Base name for the export policy client.
### Related ONTAP commands
* `vserver export-policy rule add-clientmatches`
### Learn more
* [`DOC /protocols/nfs/export-policies`](#docs-NAS-protocols_nfs_export-policies)
*/
func (a *Client) ExportRuleClientsCreate(params *ExportRuleClientsCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleClientsCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportRuleClientsCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "export_rule_clients_create",
		Method:             "POST",
		PathPattern:        "/protocols/nfs/export-policies/{policy.id}/rules/{index}/clients",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportRuleClientsCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportRuleClientsCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExportRuleClientsCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExportRuleClientsDelete Deletes an export policy client

### Related ONTAP commands
* `vserver export-policy rule remove-clientmatches`
### Learn more
* [`DOC /protocols/nfs/export-policies`](#docs-NAS-protocols_nfs_export-policies)
*/
func (a *Client) ExportRuleClientsDelete(params *ExportRuleClientsDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleClientsDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportRuleClientsDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "export_rule_clients_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/nfs/export-policies/{policy.id}/rules/{index}/clients/{match}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportRuleClientsDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportRuleClientsDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExportRuleClientsDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExportRuleClientsGet Retrieves export policy rule clients.

### Learn more
* [`DOC /protocols/nfs/export-policies`](#docs-NAS-protocols_nfs_export-policies)
*/
func (a *Client) ExportRuleClientsGet(params *ExportRuleClientsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleClientsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportRuleClientsGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "export_rule_clients_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/export-policies/{policy.id}/rules/{index}/clients",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportRuleClientsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportRuleClientsGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExportRuleClientsGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExportRuleCollectionGet Retrieves export policy rules.

### Related ONTAP commands
* `vserver export-policy rule show`
### Learn more
* [`DOC /protocols/nfs/export-policies`](#docs-NAS-protocols_nfs_export-policies)
*/
func (a *Client) ExportRuleCollectionGet(params *ExportRuleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportRuleCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "export_rule_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/export-policies/{policy.id}/rules",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportRuleCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportRuleCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExportRuleCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExportRuleCreate Creates an export policy rule.

### Required properties
* `policy.id`  - Existing export policy for which to create an export rule.
* `clients.match`  - List of clients (hostnames, ipaddresses, netgroups, domains) to which the export rule applies.
* `ro_rule`  - Used to specify the security type for read-only access to volumes that use the export rule.
* `rw_rule`  - Used to specify the security type for read-write access to volumes that use the export rule.
### Default property values
If not specified in POST, the following default property values are assigned:
* `protocols` - _any_
* `anonymous_user` - _none_
* `superuser` - _any_
* `allow_device_creation` - _true_
* `ntfs_unix_security` - _fail_
* `chown_mode` - _restricted_
* `allow_suid` - _true_
### Related ONTAP commands
* `vserver export-policy rule create`
### Learn more
* [`DOC /protocols/nfs/export-policies`](#docs-NAS-protocols_nfs_export-policies)
*/
func (a *Client) ExportRuleCreate(params *ExportRuleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportRuleCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "export_rule_create",
		Method:             "POST",
		PathPattern:        "/protocols/nfs/export-policies/{policy.id}/rules",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportRuleCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportRuleCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExportRuleCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExportRuleDelete Deletes an export policy rule.

### Related ONTAP commands
* `vserver export-policy rule delete`
### Learn more
* [`DOC /protocols/nfs/export-policies`](#docs-NAS-protocols_nfs_export-policies)
*/
func (a *Client) ExportRuleDelete(params *ExportRuleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportRuleDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "export_rule_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/nfs/export-policies/{policy.id}/rules/{index}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportRuleDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportRuleDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExportRuleDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExportRuleGet Retrieves an export policy rule

### Related ONTAP commands
* `vserver export-policy rule show`
### Learn more
* [`DOC /protocols/nfs/export-policies`](#docs-NAS-protocols_nfs_export-policies)
*/
func (a *Client) ExportRuleGet(params *ExportRuleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportRuleGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "export_rule_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/export-policies/{policy.id}/rules/{index}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportRuleGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportRuleGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExportRuleGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExportRuleModify Updates the properties of an export policy rule to change an export policy rule's index or fields.

### Related ONTAP commands
* `vserver export-policy rule modify`
* `vserver export-policy rule setindex`
### Learn more
* [`DOC /protocols/nfs/export-policies`](#docs-NAS-protocols_nfs_export-policies)
*/
func (a *Client) ExportRuleModify(params *ExportRuleModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExportRuleModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportRuleModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "export_rule_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/nfs/export-policies/{policy.id}/rules/{index}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportRuleModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportRuleModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExportRuleModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FileDirectorySecurityACLCreate Adds the new SACL/DACL ACE.

You must keep the following points in mind while using these endpoints:
* SLAG applies to all files and/or directories in a volume hence, inheritance is not required to be propagated.
* Set access_control field to slag while adding SLAG ACE.
* Set access_control field to file_directory while adding file-directory ACE. By Default access_control field is set to file_directory.
* For SLAG, valid apply_to combinations are "this-folder, sub-folders", "files", "this-folder, sub-folders, files".
### Related ONTAP commands
* `vserver security file-directory ntfs dacl add`
* `vserver security file-directory ntfs sacl add`
*/
func (a *Client) FileDirectorySecurityACLCreate(params *FileDirectorySecurityACLCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileDirectorySecurityACLCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFileDirectorySecurityACLCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "file_directory_security_acl_create",
		Method:             "POST",
		PathPattern:        "/protocols/file-security/permissions/{svm.uuid}/{path}/acl",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FileDirectorySecurityACLCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FileDirectorySecurityACLCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FileDirectorySecurityACLCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FileDirectorySecurityACLDelete Deletes the SACL/DACL ACL

You must keep the following points in mind while using these endpoints:
* SLAG applies to all files and/or directories in a volume hence, inheritance is not required to be propagated.
* Set access_control field to slag while deleting SLAG ACE.
* Set access_control field to file_directory while deleting file-directory ACE. By Default access_control field is set to file_directory.
* For SLAG, valid apply_to combinations are "this-folder, sub-folders", "files", "this-folder, sub-folders, files".
### Related ONTAP commands
* `vserver security file-directory ntfs dacl remove`
* `vserver security file-directory ntfs sacl remove`
*/
func (a *Client) FileDirectorySecurityACLDelete(params *FileDirectorySecurityACLDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileDirectorySecurityACLDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFileDirectorySecurityACLDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "file_directory_security_acl_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/file-security/permissions/{svm.uuid}/{path}/acl/{user}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FileDirectorySecurityACLDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FileDirectorySecurityACLDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FileDirectorySecurityACLDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FileDirectorySecurityACLModify Updates the SACLs/DACLs

You must keep the following points in mind while using these endpoints:
* SLAG applies to all files and/or directories in a volume hence, inheritance is not required to be propagated.
* Set access_control field to slag while updating SLAG ACE.
* Set access_control field to file_directory while updating file-directory ACE. By Default access_control field is set to file_directory.
* For SLAG, valid apply_to combinations are "this-folder, sub-folders", "files", "this-folder, sub-folders, files".
### Related ONTAP commands
* `vserver security file-directory ntfs dacl modify`
* `vserver security file-directory ntfs sacl modify`
*/
func (a *Client) FileDirectorySecurityACLModify(params *FileDirectorySecurityACLModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileDirectorySecurityACLModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFileDirectorySecurityACLModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "file_directory_security_acl_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/file-security/permissions/{svm.uuid}/{path}/acl/{user}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FileDirectorySecurityACLModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FileDirectorySecurityACLModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FileDirectorySecurityACLModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FileDirectorySecurityCreate Applies an SD  to the given path.

You must keep the following points in mind while using these endpoints:
* Either SLAG ACL/s or file-directory ACL/s can be configured in one API call. Both cannot be configured in the same API call.
* SLAG applies to all files and/or directories in a volume hence, inheritance is not required to be propagated.
* Set access_control field to slag while configuring SLAG ACLs.
* Set access_control field to file_directory while configuring file-directory ACLs. By Default access_control field is set to file_directory.
* For SLAG, valid apply_to combinations are "this-folder, sub-folders", "files", "this-folder, sub-folders, files".
### Related ONTAP commands
* `vserver security file-directory ntfs create`
* `vserver security file-directory ntfs dacl add`
* `vserver security file-directory ntfs sacl add`
* `vserver security file-directory policy create`
* `vserver security file-directory policy task add`
* `vserver security file-directory apply`
*/
func (a *Client) FileDirectorySecurityCreate(params *FileDirectorySecurityCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileDirectorySecurityCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFileDirectorySecurityCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "file_directory_security_create",
		Method:             "POST",
		PathPattern:        "/protocols/file-security/permissions/{svm.uuid}/{path}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FileDirectorySecurityCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FileDirectorySecurityCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FileDirectorySecurityCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FileDirectorySecurityDelete Remove all SLAG ACLs for specified path. Bulk deletion is supported only for SLAG

# Related ONTAP Commands
* `vserver security file-directory remove-slag`
*/
func (a *Client) FileDirectorySecurityDelete(params *FileDirectorySecurityDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileDirectorySecurityDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFileDirectorySecurityDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "file_directory_security_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/file-security/permissions/{svm.uuid}/{path}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FileDirectorySecurityDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FileDirectorySecurityDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FileDirectorySecurityDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FileDirectorySecurityGet Retrieves  file permissions

### Related ONTAP commands
* `vserver security file-directory show`
*/
func (a *Client) FileDirectorySecurityGet(params *FileDirectorySecurityGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileDirectorySecurityGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFileDirectorySecurityGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "file_directory_security_get",
		Method:             "GET",
		PathPattern:        "/protocols/file-security/permissions/{svm.uuid}/{path}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FileDirectorySecurityGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FileDirectorySecurityGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FileDirectorySecurityGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FileDirectorySecurityModify Updates SD specific Information. For example, owner, group and control-flags. SD specific information of SLAG ACLs is not modifiable.

### Related ONTAP commands
* `vserver security file-directory ntfs modify`
*/
func (a *Client) FileDirectorySecurityModify(params *FileDirectorySecurityModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileDirectorySecurityModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFileDirectorySecurityModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "file_directory_security_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/file-security/permissions/{svm.uuid}/{path}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FileDirectorySecurityModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FileDirectorySecurityModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FileDirectorySecurityModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyCollectionGet Retrieves an FPolicy configuration.

### Related ONTAP commands
* `fpolicy show`
* `fpolicy policy show`
* `fpolicy policy scope show`
* `fpolicy policy event show`
* `fpolicy policy external-engine show`
### Learn more
* [`DOC /protocols/fpolicy`](#docs-NAS-protocols_fpolicy)
*/
func (a *Client) FpolicyCollectionGet(params *FpolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/fpolicy",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyConnectionCollectionGet Retrieves the statuses of FPolicy servers.

### Related ONTAP commands
* `vserver fpolicy show-engine`
* `vserver fpolicy show-passthrough-read-connection`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/connections`](#docs-NAS-protocols_fpolicy_{svm.uuid}_connections)
*/
func (a *Client) FpolicyConnectionCollectionGet(params *FpolicyConnectionCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyConnectionCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyConnectionCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_connection_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/connections",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyConnectionCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyConnectionCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyConnectionCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyConnectionGet Retrieves the status of an FPolicy server.

### Related ONTAP commands
* `vserver fpolicy show-engine`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/connections`](#docs-NAS-protocols_fpolicy_{svm.uuid}_connections)
*/
func (a *Client) FpolicyConnectionGet(params *FpolicyConnectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyConnectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyConnectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_connection_get",
		Method:             "GET",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/connections/{node.uuid}/{policy.name}/{server}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyConnectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyConnectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyConnectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyConnectionModify Updates the status of an FPolicy server.

### Related ONTAP commands
* `vserver fpolicy engine-connect`
* `vserver fpolicy engine-disconnect`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/connections`](#docs-NAS-protocols_fpolicy_{svm.uuid}_connections)
*/
func (a *Client) FpolicyConnectionModify(params *FpolicyConnectionModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyConnectionModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyConnectionModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_connection_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/connections/{node.uuid}/{policy.name}/{server}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyConnectionModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyConnectionModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyConnectionModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyCreate Creates an FPolicy configuration.

### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the FPolicy configuration.
### Recommended optional properties
* `engines` -  External server to which the notifications will be sent.
* `events` - File operations to monitor.
* `policies` - Policy configuration which acts as a container for FPolicy event and FPolicy engine.
* `scope` - Scope of the policy. Can be limited to exports, volumes, shares or file extensions.
### Default property values
If not specified in POST, the following default property values are assigned:
* `engines.type` - _synchronous_
* `policies.engine` - _native_
* `policies.mandatory` -  _true_
* `events.volume_monitoring` - _false_
* `events.file_operations.*` - _false_
* `events.filters.*` - _false_
### Related ONTAP commands
* `fpolicy policy event create`
* `fpolicy policy external-engine create`
* `fpolicy policy create`
* `fpolicy policy scope create`
* `fpolicy enable`
### Learn more
* [`DOC /protocols/fpolicy`](#docs-NAS-protocols_fpolicy)
*/
func (a *Client) FpolicyCreate(params *FpolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_create",
		Method:             "POST",
		PathPattern:        "/protocols/fpolicy",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyDelete Deletes the FPolicy configuration for the specified SVM. Before deleting the FPolicy configuration, ensure that all policies belonging to the SVM are disabled.

### Related ONTAP commands
* `fpolicy delete`
* `fpolicy policy scope delete`
* `fpolicy policy delete`
* `fpolicy policy event delete`
* `fpolicy policy external-engine delete`
### Learn more
* [`DOC /protocols/fpolicy`](#docs-NAS-protocols_fpolicy)
*/
func (a *Client) FpolicyDelete(params *FpolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyEngineCollectionGet Retrieves FPolicy engine configurations of all the engines for a specified SVM. ONTAP allows creation of cluster-level FPolicy engines that act as a template for all the SVMs belonging to the cluster. These cluster-level FPolicy engines are also retrieved for the specified SVM.

### Related ONTAP commands
* `fpolicy policy external-engine show`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/engines`](#docs-NAS-protocols_fpolicy_{svm.uuid}_engines)
*/
func (a *Client) FpolicyEngineCollectionGet(params *FpolicyEngineCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEngineCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyEngineCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_engine_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/engines",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyEngineCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyEngineCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyEngineCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyEngineCreate Creates an FPolicy engine configuration for a specified SVM. FPolicy engine creation is allowed only on data SVMs.

### Required properties
* `svm.uuid` - Existing SVM in which to create the FPolicy engine.
* `name` - Name of external engine.
* `port` - Port number of the FPolicy server application.
* `primary_servers` - List of primary FPolicy servers to which the node will send notifications.
### Recommended optional properties
* `secondary_servers` - It is recommended to configure secondary FPolicy server to which the node will send notifications when the primary server is down.
### Default property values
* `type` - _synchronous_
* `format` - _xml_
### Related ONTAP commands
* `fpolicy policy external-engine create`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/engines`](#docs-NAS-protocols_fpolicy_{svm.uuid}_engines)
*/
func (a *Client) FpolicyEngineCreate(params *FpolicyEngineCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEngineCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyEngineCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_engine_create",
		Method:             "POST",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/engines",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyEngineCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyEngineCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyEngineCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyEngineDelete Deletes the FPolicy external engine configuration. Deletion of an FPolicy engine that is attached to one or more FPolicy policies is not allowed.

### Related ONTAP commands
* `fpolicy policy external-engine modify`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/engines`](#docs-NAS-protocols_fpolicy_{svm.uuid}_engines)
*/
func (a *Client) FpolicyEngineDelete(params *FpolicyEngineDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEngineDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyEngineDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_engine_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/engines/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyEngineDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyEngineDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyEngineDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyEngineGet Retrieves a particular FPolicy engine configuration of a specifed SVM. A cluster-level FPolicy engine configuration cannot be retrieved for a data SVM.

### Related ONTAP commands
* `fpolicy policy external-engine show`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/engines`](#docs-NAS-protocols_fpolicy_{svm.uuid}_engines)
*/
func (a *Client) FpolicyEngineGet(params *FpolicyEngineGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEngineGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyEngineGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_engine_get",
		Method:             "GET",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/engines/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyEngineGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyEngineGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyEngineGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyEngineModify Updates a specific FPolicy engine configuration of an SVM. Modification of an FPolicy engine that is attached to one or more enabled FPolicy policies is not allowed.

### Related ONTAP commands
* `fpolicy policy external-engine modify`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/engines`](#docs-NAS-protocols_fpolicy_{svm.uuid}_engines)
*/
func (a *Client) FpolicyEngineModify(params *FpolicyEngineModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEngineModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyEngineModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_engine_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/engines/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyEngineModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyEngineModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyEngineModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyEventCollectionGet Retrieves FPolicy event configurations for all events for a specified SVM. ONTAP allows the creation of cluster-level FPolicy events that act as a template for all the data SVMs belonging to the cluster. These cluster-level FPolicy events are also retrieved for the specified SVM.

### Related ONTAP commands
* `fpolicy policy event show`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/events`](#docs-NAS-protocols_fpolicy_{svm.uuid}_events)
*/
func (a *Client) FpolicyEventCollectionGet(params *FpolicyEventCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEventCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyEventCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_event_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/events",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyEventCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyEventCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyEventCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyEventCreate Creates an FPolicy event configuration for a specified SVM. FPolicy event creation is allowed only on data SVMs. When a protocol is specified, you must specify a file operation or a file operation and filters.

### Required properties
* `svm.uuid` - Existing SVM in which to create the FPolicy event.
* `name` - Name of the FPolicy event.
### Recommended optional properties
* `file-operations` - List of file operations to monitor.
* `protocol` - Protocol for which the file operations should be monitored.
* `filters` - List of filters for the specified file operations.
### Default property values
If not specified in POST, the following default property values are assigned:
* `file_operations.*` - _false_
* `filters.*` - _false_
* `volume-monitoring` - _false_
### Related ONTAP commands
* `fpolicy policy event create`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/events`](#docs-NAS-protocols_fpolicy_{svm.uuid}_events)
*/
func (a *Client) FpolicyEventCreate(params *FpolicyEventCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEventCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyEventCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_event_create",
		Method:             "POST",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/events",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyEventCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyEventCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyEventCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyEventDelete Deletes a specific FPolicy event configuration for an SVM. A cluster-level FPolicy event configuration cannot be modified for a data SVM through REST. An FPolicy event that is attached to an FPolicy policy cannot be deleted.

### Related ONTAP commands
* `fpolicy policy event delete`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/events`](#docs-NAS-protocols_fpolicy_{svm.uuid}_events)
*/
func (a *Client) FpolicyEventDelete(params *FpolicyEventDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEventDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyEventDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_event_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/events/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyEventDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyEventDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyEventDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyEventModify Updates a specific FPolicy event configuration for an SVM. A cluster-level FPolicy event configuration cannot be modified for a data SVM through REST. When the file operations and filters fields are modified, the previous values are retained and new values are added to the list of previous values. To remove a particular file operation or filter, set its value to false in the request.

### Related ONTAP commands
* `fpolicy policy event modify`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/events`](#docs-NAS-protocols_fpolicy_{svm.uuid}_events)
*/
func (a *Client) FpolicyEventModify(params *FpolicyEventModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEventModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyEventModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_event_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/events/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyEventModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyEventModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyEventModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyEventsGet Retrieves a specific FPolicy event configuration for an SVM. A cluster-level FPolicy event configuration cannot be retrieved for a data SVM through a REST API.

### Related ONTAP commands
* `fpolicy policy event show`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/events`](#docs-NAS-protocols_fpolicy_{svm.uuid}_events)
*/
func (a *Client) FpolicyEventsGet(params *FpolicyEventsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyEventsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyEventsGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_events_get",
		Method:             "GET",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/events/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyEventsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyEventsGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyEventsGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyGet Retrieves an FPolicy configuration of an SVM.

### Related ONTAP commands
* `fpolicy show`
* `fpolicy policy show`
* `fpolicy policy scope show`
* `fpolicy policy event show`
* `fpolicy policy external-engine show`
### Learn more
* [`DOC /protocols/fpolicy`](#docs-NAS-protocols_fpolicy)
*/
func (a *Client) FpolicyGet(params *FpolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_get",
		Method:             "GET",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyPolicyCollectionGet Retrieves the FPolicy policy configuration of an SVM. ONTAP allows the creation of a cluster level FPolicy policy that acts as a template for all the data SVMs belonging to the cluster. This cluster level FPolicy policy is also retrieved for the specified SVM.

### Related ONTAP commands
* `fpolicy policy show`
* `fpolicy policy scope show`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/policies`](#docs-NAS-protocols_fpolicy_{svm.uuid}_policies)
*/
func (a *Client) FpolicyPolicyCollectionGet(params *FpolicyPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyPolicyCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyPolicyCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_policy_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/policies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyPolicyCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyPolicyCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyPolicyCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyPolicyCreate Creates an FPolicy policy configuration for the specified SVM. To create an FPolicy policy, you must specify the policy scope and the FPolicy events to be monitored.

</br>Important notes:
* A single policy can monitor multiple events.
* An FPolicy engine is an optional field whose default value is set to native. A native engine can be used to simply block the file access based on the file extensions specified in the policy scope.
* To enable a policy, the policy priority  must be specified. If the priority is not specified, the policy is created but it is not enabled.
* The "mandatory" field, if set to true, blocks the file access when the primary or secondary FPolicy servers are down.
### Required properties
* `svm.uuid` - Existing SVM in which to create the FPolicy policy.
* `events` - Name of the events to monitior.
* `name` - Name of the FPolicy policy.
* `scope` - Scope of the policy. Can be limited to exports, volumes, shares or file extensions.
* `priority`- Priority of the policy (ranging from 1 to 10).
### Default property values
* `mandatory` - _true_
* `engine` - _native_
### Related ONTAP commands
* `fpolicy policy scope create`
* `fpolicy policy create`
* `fpolicy enable`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/policies`](#docs-NAS-protocols_fpolicy_{svm.uuid}_policies)
*/
func (a *Client) FpolicyPolicyCreate(params *FpolicyPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyPolicyCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyPolicyCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_policy_create",
		Method:             "POST",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/policies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyPolicyCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyPolicyCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyPolicyCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyPolicyDelete Deletes a particular FPolicy policy configuration for a specified SVM. To delete a policy, you must first disable the policy.

### Related ONTAP commands
* `fpolicy policy scope delete`
* `fpolicy policy delete`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/policies`](#docs-NAS-protocols_fpolicy_{svm.uuid}_policies)
*/
func (a *Client) FpolicyPolicyDelete(params *FpolicyPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyPolicyDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyPolicyDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_policy_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/policies/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyPolicyDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyPolicyDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyPolicyDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyPolicyGet Retrieves a particular FPolicy policy configuration for a specified SVM. Cluster-level FPolicy policy configuration details cannot be retrieved for a data SVM.

### Related ONTAP commands
* `fpolicy policy show`
* `fpolicy policy scope show`
* `fpolicy show`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/policies`](#docs-NAS-protocols_fpolicy_{svm.uuid}_policies)
*/
func (a *Client) FpolicyPolicyGet(params *FpolicyPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyPolicyGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyPolicyGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_policy_get",
		Method:             "GET",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/policies/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyPolicyGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyPolicyGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyPolicyGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	FpolicyPolicyModify Updates a particular FPolicy policy configuration for a specified SVM. PATCH can be used to enable or disable the policy. When enabling a policy, you must specify the policy priority. The policy priority of the policy is not required when disabling the policy. If the policy is enabled, the FPolicy policy engine cannot be modified.

### Related ONTAP commands
* `fpolicy policy modify`
* `fpolicy policy scope modify`
* `fpolicy enable`
* `fpolicy disable`
### Learn more
* [`DOC /protocols/fpolicy/{svm.uuid}/policies`](#docs-NAS-protocols_fpolicy_{svm.uuid}_policies)
*/
func (a *Client) FpolicyPolicyModify(params *FpolicyPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FpolicyPolicyModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFpolicyPolicyModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "fpolicy_policy_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/fpolicy/{svm.uuid}/policies/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FpolicyPolicyModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FpolicyPolicyModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FpolicyPolicyModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GroupPoliciesToBeAppliedModify Will create a background task to update the GPO settings for specified SVM.

### Related ONTAP commands
* `vserver cifs group-policy update`
*/
func (a *Client) GroupPoliciesToBeAppliedModify(params *GroupPoliciesToBeAppliedModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPoliciesToBeAppliedModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGroupPoliciesToBeAppliedModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "group_policies_to_be_applied_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/cifs/group-policies/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GroupPoliciesToBeAppliedModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GroupPoliciesToBeAppliedModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GroupPoliciesToBeAppliedModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GroupPolicyObjectCentralAccessPolicyCollectionGet Retrieves applied central access policies for specified SVM.

### Related ONTAP commands
* `vserver cifs group-policy central-access-policy show-applied`
*/
func (a *Client) GroupPolicyObjectCentralAccessPolicyCollectionGet(params *GroupPolicyObjectCentralAccessPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectCentralAccessPolicyCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGroupPolicyObjectCentralAccessPolicyCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "group_policy_object_central_access_policy_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/group-policies/{svm.uuid}/central-access-policies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GroupPolicyObjectCentralAccessPolicyCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GroupPolicyObjectCentralAccessPolicyCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GroupPolicyObjectCentralAccessPolicyCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GroupPolicyObjectCentralAccessPolicyGet Retrieves applied central access policy for specified SVM.

### Related ONTAP commands
* `vserver cifs group-policy central-access-policy show-applied`
*/
func (a *Client) GroupPolicyObjectCentralAccessPolicyGet(params *GroupPolicyObjectCentralAccessPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectCentralAccessPolicyGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGroupPolicyObjectCentralAccessPolicyGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "group_policy_object_central_access_policy_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/group-policies/{svm.uuid}/central-access-policies/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GroupPolicyObjectCentralAccessPolicyGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GroupPolicyObjectCentralAccessPolicyGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GroupPolicyObjectCentralAccessPolicyGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GroupPolicyObjectCentralAccessRuleCollectionGet Retrieves applied central access rules for specified SVM.

### Related ONTAP commands
* `vserver cifs group-policy central-access-rule show-applied`
*/
func (a *Client) GroupPolicyObjectCentralAccessRuleCollectionGet(params *GroupPolicyObjectCentralAccessRuleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectCentralAccessRuleCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGroupPolicyObjectCentralAccessRuleCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "group_policy_object_central_access_rule_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/group-policies/{svm.uuid}/central-access-rules",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GroupPolicyObjectCentralAccessRuleCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GroupPolicyObjectCentralAccessRuleCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GroupPolicyObjectCentralAccessRuleCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GroupPolicyObjectCentralAccessRuleGet Retrieves applied central access rule for specified SVM.

### Related ONTAP commands
* `vserver cifs group-policy central-access-rule show-applied`
*/
func (a *Client) GroupPolicyObjectCentralAccessRuleGet(params *GroupPolicyObjectCentralAccessRuleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectCentralAccessRuleGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGroupPolicyObjectCentralAccessRuleGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "group_policy_object_central_access_rule_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/group-policies/{svm.uuid}/central-access-rules/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GroupPolicyObjectCentralAccessRuleGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GroupPolicyObjectCentralAccessRuleGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GroupPolicyObjectCentralAccessRuleGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GroupPolicyObjectCollectionGet Retrieves applied group policy objects for specified SVM.

### Related ONTAP commands
* `vserver cifs group-policy show-applied`
*/
func (a *Client) GroupPolicyObjectCollectionGet(params *GroupPolicyObjectCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGroupPolicyObjectCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "group_policy_object_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/group-policies/{svm.uuid}/objects",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GroupPolicyObjectCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GroupPolicyObjectCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GroupPolicyObjectCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GroupPolicyObjectGet Retrieves applied group policy object for specified SVM.

### Related ONTAP commands
* `vserver cifs group-policy show-applied`
*/
func (a *Client) GroupPolicyObjectGet(params *GroupPolicyObjectGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGroupPolicyObjectGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "group_policy_object_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/group-policies/{svm.uuid}/objects/{index}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GroupPolicyObjectGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GroupPolicyObjectGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GroupPolicyObjectGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GroupPolicyObjectRestrictedGroupCollectionGet Retrieves applied policies of restricted groups for specified SVM.

### Related ONTAP commands
* `vserver cifs group-policy restricted-group show-applied`
*/
func (a *Client) GroupPolicyObjectRestrictedGroupCollectionGet(params *GroupPolicyObjectRestrictedGroupCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectRestrictedGroupCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGroupPolicyObjectRestrictedGroupCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "group_policy_object_restricted_group_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/group-policies/{svm.uuid}/restricted-groups",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GroupPolicyObjectRestrictedGroupCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GroupPolicyObjectRestrictedGroupCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GroupPolicyObjectRestrictedGroupCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GroupPolicyObjectRestrictedGroupGet Retrieves applied policy of restricted group for specified SVM.

### Related ONTAP commands
* `vserver cifs group-policy restricted-group show-applied`
*/
func (a *Client) GroupPolicyObjectRestrictedGroupGet(params *GroupPolicyObjectRestrictedGroupGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GroupPolicyObjectRestrictedGroupGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGroupPolicyObjectRestrictedGroupGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "group_policy_object_restricted_group_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/group-policies/{svm.uuid}/restricted-groups/{policy_index}/{group_name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GroupPolicyObjectRestrictedGroupGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GroupPolicyObjectRestrictedGroupGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GroupPolicyObjectRestrictedGroupGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	KerberosInterfaceCollectionGet Retrieves Kerberos interfaces.

### Related ONTAP commands
* `vserver nfs kerberos interface show`
### Learn more
* [`DOC /protocols/nfs/kerberos/interfaces`](#docs-NAS-protocols_nfs_kerberos_interfaces)
*/
func (a *Client) KerberosInterfaceCollectionGet(params *KerberosInterfaceCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosInterfaceCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKerberosInterfaceCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "kerberos_interface_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/kerberos/interfaces",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &KerberosInterfaceCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*KerberosInterfaceCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*KerberosInterfaceCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	KerberosInterfaceGet Retrieves a Kerberos interface.

### Related ONTAP commands
* `vserver nfs kerberos interface show`
### Learn more
* [`DOC /protocols/nfs/kerberos/interfaces`](#docs-NAS-protocols_nfs_kerberos_interfaces)
*/
func (a *Client) KerberosInterfaceGet(params *KerberosInterfaceGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosInterfaceGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKerberosInterfaceGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "kerberos_interface_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/kerberos/interfaces/{interface.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &KerberosInterfaceGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*KerberosInterfaceGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*KerberosInterfaceGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	KerberosInterfaceModify Updates the properties of a Kerberos interface.

### Related ONTAP commands
* `vserver nfs kerberos interface modify`
* `vserver nfs kerberos interface enable`
* `vserver nfs kerberos interface disable`
### Learn more
* [`DOC /protocols/nfs/kerberos/interfaces`](#docs-NAS-protocols_nfs_kerberos_interfaces)
*/
func (a *Client) KerberosInterfaceModify(params *KerberosInterfaceModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosInterfaceModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKerberosInterfaceModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "kerberos_interface_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/nfs/kerberos/interfaces/{interface.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &KerberosInterfaceModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*KerberosInterfaceModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*KerberosInterfaceModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	KerberosRealmCollectionGet Retrieves Kerberos realms.

### Related ONTAP commands
* `vserver nfs kerberos realm show`
### Learn more
* [`DOC /protocols/nfs/kerberos/realms`](#docs-NAS-protocols_nfs_kerberos_realms)
*/
func (a *Client) KerberosRealmCollectionGet(params *KerberosRealmCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosRealmCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKerberosRealmCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "kerberos_realm_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/kerberos/realms",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &KerberosRealmCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*KerberosRealmCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*KerberosRealmCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	KerberosRealmCreate Creates a Kerberos realm.

### Required properties
* `svm.uuid` or `svm.name` - Existing SVM on which to create the Kerberos realm.
* `name` - Base name for the Kerberos realm.
* `kdc.vendor` - Vendor of the Key Distribution Center (KDC) server for this Kerberos realm. If the configuration uses a Microsoft Active Directory domain for authentication, this field nust be `microsoft`.
* `kdc.ip` - IP address of the KDC server for this Kerberos realm.
### Recommended optional properties
* `ad_server.name` - Host name of the Active Directory Domain Controller (DC). This is a mandatory parameter if the kdc-vendor is `microsoft`.
* `ad_server.address` - IP address of the Active Directory Domain Controller (DC). This is a mandatory parameter if the kdc-vendor is `microsoft`.
### Default property values
If not specified in POST, the following default property value is assigned:
* `kdc.port` - _88_
### Related ONTAP commands
* `vserver nfs kerberos realm create`
### Learn more
* [`DOC /protocols/nfs/kerberos/realms`](#docs-NAS-protocols_nfs_kerberos_realms)
*/
func (a *Client) KerberosRealmCreate(params *KerberosRealmCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosRealmCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKerberosRealmCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "kerberos_realm_create",
		Method:             "POST",
		PathPattern:        "/protocols/nfs/kerberos/realms",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &KerberosRealmCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*KerberosRealmCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*KerberosRealmCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	KerberosRealmDelete Deletes a Kerberos realm.

* `vserver nfs kerberos realm delete`
### Learn more
* [`DOC /protocols/nfs/kerberos/realms`](#docs-NAS-protocols_nfs_kerberos_realms)
*/
func (a *Client) KerberosRealmDelete(params *KerberosRealmDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosRealmDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKerberosRealmDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "kerberos_realm_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/nfs/kerberos/realms/{svm.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &KerberosRealmDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*KerberosRealmDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*KerberosRealmDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	KerberosRealmGet Retrieves a Kerberos realm.

* `vserver nfs kerberos realm show`
### Learn more
* [`DOC /protocols/nfs/kerberos/realms`](#docs-NAS-protocols_nfs_kerberos_realms)
*/
func (a *Client) KerberosRealmGet(params *KerberosRealmGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosRealmGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKerberosRealmGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "kerberos_realm_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/kerberos/realms/{svm.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &KerberosRealmGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*KerberosRealmGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*KerberosRealmGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	KerberosRealmModify Updates the properties of a Kerberos realm.

* `vserver nfs kerberos realm modify`
### Learn more
* [`DOC /protocols/nfs/kerberos/realms`](#docs-NAS-protocols_nfs_kerberos_realms)
*/
func (a *Client) KerberosRealmModify(params *KerberosRealmModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*KerberosRealmModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKerberosRealmModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "kerberos_realm_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/nfs/kerberos/realms/{svm.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &KerberosRealmModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*KerberosRealmModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*KerberosRealmModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsGroupCollectionGet Retrieves the local groups for all of the SVMs.

### Advanced properties
* `members`
### Related ONTAP commands
* `vserver cifs users-and-groups local-group show`
* `vserver cifs users-and-groups local-group show-members`
### Learn more
* [`DOC /protocols/cifs/local-groups`](#docs-NAS-protocols_cifs_local-groups)
*/
func (a *Client) LocalCifsGroupCollectionGet(params *LocalCifsGroupCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsGroupCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_group_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/local-groups",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsGroupCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsGroupCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsGroupCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsGroupCreate Creates the local group configuration for the specified SVM.

### Important notes
* The group name can contain up to 256 characters.
* The group name cannot be terminated by a period.
* The group name does not support any of the following characters: \" / ? [ ] , : | < > + = ; ? * @ or ASCII characters in the range 1-31.
### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the local group.
* `name` - Name of the local group.
### Related ONTAP commands
* `vserver cifs users-and-groups local-group create`
### Learn more
* [`DOC /protocols/cifs/local-groups`](#docs-NAS-protocols_cifs_local-groups)
*/
func (a *Client) LocalCifsGroupCreate(params *LocalCifsGroupCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsGroupCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_group_create",
		Method:             "POST",
		PathPattern:        "/protocols/cifs/local-groups",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsGroupCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsGroupCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsGroupCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsGroupDelete Deletes a local group configuration for the specified SVM.

### Related ONTAP commands
* `vserver cifs users-and-groups local-group delete`
### Learn more
* [`DOC /protocols/cifs/local-groups`](#docs-NAS-protocols_cifs_local-groups)
*/
func (a *Client) LocalCifsGroupDelete(params *LocalCifsGroupDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsGroupDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_group_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/cifs/local-groups/{svm.uuid}/{sid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsGroupDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsGroupDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsGroupDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsGroupGet Retrieves local group information for the specified group and SVM.

### Advanced properties
* `members`
### Related ONTAP commands
* `vserver cifs users-and-groups local-group show`
* `vserver cifs users-and-groups local-group show-members`
### Learn more
* [`DOC /protocols/cifs/local-groups`](#docs-NAS-protocols_cifs_local-groups)
*/
func (a *Client) LocalCifsGroupGet(params *LocalCifsGroupGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsGroupGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_group_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/local-groups/{svm.uuid}/{sid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsGroupGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsGroupGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsGroupGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsGroupMembersBulkDelete Deletes the local users, Active Directory users and/or Active Directory groups from the specified local group and SVM.

### Related ONTAP commands
* `vserver cifs users-and-groups local-group remove-members`
### Learn more
* [`DOC /protocols/cifs/local-groups/{svm.uuid}/{local_cifs_group.sid}/members`](#docs-NAS-protocols_cifs_local-groups_{svm.uuid}_{local_cifs_group.sid}_members)
*/
func (a *Client) LocalCifsGroupMembersBulkDelete(params *LocalCifsGroupMembersBulkDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupMembersBulkDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsGroupMembersBulkDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_group_members_bulk_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/cifs/local-groups/{svm.uuid}/{local_cifs_group.sid}/members",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsGroupMembersBulkDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsGroupMembersBulkDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsGroupMembersBulkDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsGroupMembersCollectionGet Retrieves local users, Active Directory users and Active Directory groups which are members of the specified local group and SVM.

### Related ONTAP commands
* `vserver cifs users-and-groups local-group show-members`
### Learn more
* [`DOC /protocols/cifs/local-groups/{svm.uuid}/{local_cifs_group.sid}/members`](#docs-NAS-protocols_cifs_local-groups_{svm.uuid}_{local_cifs_group.sid}_members)
*/
func (a *Client) LocalCifsGroupMembersCollectionGet(params *LocalCifsGroupMembersCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupMembersCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsGroupMembersCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_group_members_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/local-groups/{svm.uuid}/{local_cifs_group.sid}/members",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsGroupMembersCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsGroupMembersCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsGroupMembersCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsGroupMembersCreate Adds local users, Active Directory users and Active Directory groups to the specified local group and SVM.

### Important note
* Specified members are appended to the existing list of members.
### Required properties
* `svm.uuid` or `svm.name` - Existing SVM for which members are added to local group.
* `local_cifs_group.sid` -  Security ID of the local group to which members are added.
* `name` or `records` - Local users, Active Directory users, or Active Directory groups to be added to a particular local group.
### Related ONTAP commands
* `vserver cifs users-and-groups local-group add-members`
### Learn more
* [`DOC /protocols/cifs/local-groups/{svm.uuid}/{local_cifs_group.sid}/members`](#docs-NAS-protocols_cifs_local-groups_{svm.uuid}_{local_cifs_group.sid}_members)
*/
func (a *Client) LocalCifsGroupMembersCreate(params *LocalCifsGroupMembersCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupMembersCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsGroupMembersCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_group_members_create",
		Method:             "POST",
		PathPattern:        "/protocols/cifs/local-groups/{svm.uuid}/{local_cifs_group.sid}/members",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsGroupMembersCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsGroupMembersCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsGroupMembersCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsGroupMembersDelete Deletes the local user, Active Directory user and/or Active Directory group from the specified local group and SVM.

### Related ONTAP commands
* `vserver cifs users-and-groups local-group remove-members`
### Learn more
* [`DOC /protocols/cifs/local-groups/{svm.uuid}/{local_cifs_group.sid}/members`](#docs-NAS-protocols_cifs_local-groups_{svm.uuid}_{local_cifs_group.sid}_members)
*/
func (a *Client) LocalCifsGroupMembersDelete(params *LocalCifsGroupMembersDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupMembersDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsGroupMembersDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_group_members_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/cifs/local-groups/{svm.uuid}/{local_cifs_group.sid}/members/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsGroupMembersDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsGroupMembersDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsGroupMembersDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsGroupMembersGet Retrieves local user, Active Directory user and Active Directory group which is member of the specified local group and SVM.

### Related ONTAP commands
* `vserver cifs users-and-groups local-group show-members`
### Learn more
* [`DOC /protocols/cifs/local-groups/{svm.uuid}/{local_cifs_group.sid}/members`](#docs-NAS-protocols_cifs_local-groups_{svm.uuid}_{local_cifs_group.sid}_members)
*/
func (a *Client) LocalCifsGroupMembersGet(params *LocalCifsGroupMembersGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupMembersGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsGroupMembersGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_group_members_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/local-groups/{svm.uuid}/{local_cifs_group.sid}/members/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsGroupMembersGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsGroupMembersGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsGroupMembersGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsGroupModify Updates the local group information of the specified group in the specified SVM. This API can also be used to rename a local group.

### Related ONTAP commands
* `vserver cifs users-and-groups local-group modify`
* `vserver cifs users-and-groups local-group rename`
### Learn more
* [`DOC /protocols/cifs/local-groups`](#docs-NAS-protocols_cifs_local-groups)
*/
func (a *Client) LocalCifsGroupModify(params *LocalCifsGroupModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsGroupModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsGroupModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_group_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/cifs/local-groups/{svm.uuid}/{sid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsGroupModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsGroupModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsGroupModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsUserCollectionGet Retrieves local users for all of the SVMs. Local groups to which this user belongs to are also displayed.

### Advanced properties
* `membership`
### Related ONTAP commands
* `vserver cifs users-and-groups local-user show`
* `vserver cifs users-and-groups local-user show-membership`
### Learn more
* [`DOC /protocols/cifs/local-users`](#docs-NAS-protocols_cifs_local-users)
*/
func (a *Client) LocalCifsUserCollectionGet(params *LocalCifsUserCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUserCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsUserCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_user_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/local-users",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsUserCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsUserCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsUserCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsUserCreate Creates the local user configuration for an SVM.<br/>

### Important notes
* The user name can contain up to 20 characters.
* The user name cannot be terminated by a period.
* The user name does not support any of the following characters: \" / ? [ ] , : | < > + = ; ? * @ or ASCII characters in the range 1-31.
* The password must be at least six characters in length and must not contain the user account name.
* The password must contain characters from three of the following four categories:
  - English uppercase characters (A through Z)
  - English lowercase characters (a through z)
  - Base 10 digits (0 through 9)
  - Special characters: ~ ! @ \# 0 ^ & * _ - + = ` ? | ( ) [ ] : ; \" \' < > , . ? /

### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the local user.
* `name` - Name of the local user.
* `password` - Password for the local user.
### Default property values
If not specified in POST, the following default property value is assigned:
* `account_disabled` - false
### Related ONTAP commands
* `vserver cifs users-and-groups local-user create`
### Learn more
* [`DOC /protocols/cifs/local-users`](#docs-NAS-protocols_cifs_local-users)
*/
func (a *Client) LocalCifsUserCreate(params *LocalCifsUserCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUserCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsUserCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_user_create",
		Method:             "POST",
		PathPattern:        "/protocols/cifs/local-users",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsUserCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsUserCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsUserCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsUserDelete Deletes a local user configuration for the specified SVM.

### Related ONTAP commands
* `vserver cifs users-and-groups local-user delete`
### Learn more
* [`DOC /protocols/cifs/local-users`](#docs-NAS-protocols_cifs_local-users)
*/
func (a *Client) LocalCifsUserDelete(params *LocalCifsUserDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUserDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsUserDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_user_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/cifs/local-users/{svm.uuid}/{sid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsUserDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsUserDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsUserDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsUserGet Retrieves local user information for the specified user and SVM.

### Advanced properties
* `membership`
### Related ONTAP commands
* `vserver cifs users-and-groups local-user show`
* `vserver cifs users-and-groups local-user show-membership`
### Learn more
* [`DOC /protocols/cifs/local-users`](#docs-NAS-protocols_cifs_local-users)
*/
func (a *Client) LocalCifsUserGet(params *LocalCifsUserGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUserGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsUserGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_user_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/local-users/{svm.uuid}/{sid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsUserGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsUserGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsUserGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsUserModify Updates local user information for the specified user and SVM. The PATCH endpoint is also used to rename a user and to set the password for the user.

### Related ONTAP commands
* `vserver cifs users-and-groups local-user modify`
* `vserver cifs users-and-groups local-user rename`
* `vserver cifs users-and-groups local-user set-password`
### Learn more
* [`DOC /protocols/cifs/local-users`](#docs-NAS-protocols_cifs_local-users)
*/
func (a *Client) LocalCifsUserModify(params *LocalCifsUserModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUserModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsUserModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_user_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/cifs/local-users/{svm.uuid}/{sid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsUserModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsUserModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsUserModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsUsersAndGroupsImportCreate Loads CIFS local users,groups and group memberships file from the specified URL.<br/>

### Important notes
Existing CIFS local users, groups, and group memberships will be replaced with the contents of the file.
### Required properties
- import_uri.path
- decryption_password
### Optional properties
- import_uri.username
- import_uri.password
### Related ONTAP commands
* `vserver cifs users-and-groups import load-from-uri`
*/
func (a *Client) LocalCifsUsersAndGroupsImportCreate(params *LocalCifsUsersAndGroupsImportCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUsersAndGroupsImportCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsUsersAndGroupsImportCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_users_and_groups_import_create",
		Method:             "POST",
		PathPattern:        "/protocols/cifs/users-and-groups/bulk-import/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsUsersAndGroupsImportCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsUsersAndGroupsImportCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsUsersAndGroupsImportCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsUsersAndGroupsImportGet Retrieves information about the import operation status of the CIFS local users,

groups, and group memberships.
### Related ONTAP commands
* `vserver cifs users-and-groups import get-status`
*/
func (a *Client) LocalCifsUsersAndGroupsImportGet(params *LocalCifsUsersAndGroupsImportGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUsersAndGroupsImportGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsUsersAndGroupsImportGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_users_and_groups_import_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/users-and-groups/bulk-import/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsUsersAndGroupsImportGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsUsersAndGroupsImportGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsUsersAndGroupsImportGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	LocalCifsUsersAndGroupsImportModify Upload the status of the bulk-import of the specified SVM to the specified URI.

### Important notes
* Only the status of the last bulk-import will be uploaded and not the status of the previous bulk-imports.
### Required properties
- status_uri.path - URI to which the status needs to be uploaded.
### Optional properties
- status_uri.username - Username of the specified URI.
- status_uri.password - Password of the specified URI.
### Related ONTAP commands
* `vserver cifs users-and-groups import get-status`
*/
func (a *Client) LocalCifsUsersAndGroupsImportModify(params *LocalCifsUsersAndGroupsImportModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalCifsUsersAndGroupsImportModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalCifsUsersAndGroupsImportModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_cifs_users_and_groups_import_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/cifs/users-and-groups/bulk-import/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalCifsUsersAndGroupsImportModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalCifsUsersAndGroupsImportModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalCifsUsersAndGroupsImportModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	NetbiosCollectionGet Retrieves NetBIOS information.

### Related ONTAP commands
* ` vserver cifs nbstat`
### Learn more
* [`DOC /protocols/cifs/netbios`](#docs-NAS-protocols_cifs_netbios)
*/
func (a *Client) NetbiosCollectionGet(params *NetbiosCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NetbiosCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNetbiosCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "netbios_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/netbios",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NetbiosCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NetbiosCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NetbiosCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
NfsClientsCacheGet Retrieves the NFS connected-client cache settings of the cluster.
*/
func (a *Client) NfsClientsCacheGet(params *NfsClientsCacheGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsClientsCacheGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsClientsCacheGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nfs_clients_cache_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/connected-client-settings",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NfsClientsCacheGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsClientsCacheGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NfsClientsCacheGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
NfsClientsCacheModify Updates the properties of the NFS connected-client cache settings.
*/
func (a *Client) NfsClientsCacheModify(params *NfsClientsCacheModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsClientsCacheModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsClientsCacheModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nfs_clients_cache_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/nfs/connected-client-settings",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NfsClientsCacheModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsClientsCacheModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NfsClientsCacheModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	NfsClientsGet Retrieves the NFS configuration of SVMs.

### Expensive properties
export_policy.id is expensive field. It is not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
* `export_policy.id`
*/
func (a *Client) NfsClientsGet(params *NfsClientsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsClientsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsClientsGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nfs_clients_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/connected-clients",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NfsClientsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsClientsGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NfsClientsGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
NfsClientsMapGet Retrieves NFS clients information.
*/
func (a *Client) NfsClientsMapGet(params *NfsClientsMapGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsClientsMapGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsClientsMapGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nfs_clients_map_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/connected-client-maps",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NfsClientsMapGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsClientsMapGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NfsClientsMapGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	NfsCollectionGet Retrieves the NFS configuration of SVMs.

### Expensive properties
There is an added computational cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
* `statistics.*`
* `metric.*`
### Advanced properties
* `security.rpcsec_context_idle`
* `security.ntfs_unix_security`
* `security.chown_mode`
* `security.nt_acl_display_permission`
* `protocol.v3_features.ejukebox_enabled`
* `protocol.v3_features.connection_drop`
* `protocol.v3_features.fsid_change`
* `protocol.v3_features.mount_daemon_port`
* `protocol.v3_features.network_lock_manager_port`
* `protocol.v3_features.network_status_monitor_port`
* `protocol.v3_features.rquota_daemon_port`
* `protocol.v41_features.implementation_domain`
* `protocol.v41_features.implementation_name`
* `protocol.v40_features.acl_max_aces`
* `windows.map_unknown_uid_to_default_user`
* `exports.netgroup_trust_any_nsswitch_no_match`
* `credential_cache.negative_ttl`
* `transport.tcp_max_transfer_size`
* `root.*`
* `protocol.v41_features.trunking_enabled`
* `protocol.v42_features.seclabel_enabled`
* `protocol.v42_features.sparsefile_ops_enabled`
* `protocol.v42_features.xattrs_enabled`
### Diagnostic properties
* `credential_cache.transient_error_ttl`
* `access_cache_config.ttl_failure`
### Related ONTAP commands
* `vserver nfs show`
* `vserver nfs status`
### Learn more
* [`DOC /protocols/nfs/services`](#docs-NAS-protocols_nfs_services)
*/
func (a *Client) NfsCollectionGet(params *NfsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nfs_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/services",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NfsCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NfsCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
NfsCollectionPerformanceMetricsGet Retrieves historical performance metrics for the NFS protocol of an SVM.
*/
func (a *Client) NfsCollectionPerformanceMetricsGet(params *NfsCollectionPerformanceMetricsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsCollectionPerformanceMetricsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsCollectionPerformanceMetricsGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nfs_collection_performance_metrics_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/services/{svm.uuid}/metrics",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NfsCollectionPerformanceMetricsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsCollectionPerformanceMetricsGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NfsCollectionPerformanceMetricsGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	NfsCreate Creates an NFS configuration for an SVM.

### Required properties
* `svm.uuid` or `svm.name` - Existing SVM for which to create the NFS configuration.
### Default property values
If not specified in POST, the following default property values are assigned:
* `enabled` - _true_
* `state` - online
* `transport.udp_enabled` - _true_
* `transport.tcp_enabled` - _true_
* `transport.rdma_enabled` - _true_
* `protocol.v3_enabled` - _true_
* `protocol.v3_64bit_identifiers_enabled` - _false_
* `protocol.v4_id_domain` - defaultv4iddomain.com
* `protocol.v4_64bit_identifiers_enabled` - _true_
* `protocol.v4_enabled` - _false_
* `protocol.v41_enabled` - _false_
* `protocol.v40_features.acl_enabled` - _false_
* `protocol.v40_features.read_delegation_enabled` - _false_
* `protocol.v40_features.write_delegation_enabled` - _false_
* `protocol.v41_features.acl_enabled` - _false_
* `protocol.v41_features.read_delegation_enabled` - _false_
* `protocol.v41_features.write_delegation_enabled` - _false_
* `protocol.v41_features.pnfs_enabled` - _false_
* `vstorage_enabled` - _false_
* `rquota_enabled` - _false_
* `showmount_enabled` - _true_
* `auth_sys_extended_groups_enabled` - _false_
* `extended_groups_limit` - _32_
* `qtree.export_enabled` - _false_
* `qtree.validate_export` - _true_
* `access_cache_config.ttl_positive` - _60_
* `access_cache_config.ttl_negative` - _30_
* `access_cache_config.ttl_failure` - _1_
* `access_cache_config.harvest_timeout` - _3600_
* `access_cache_config.isDnsTTLEnabled` - _false_
* `file_session_io_grouping_count` - _5000_
* `file_session_io_grouping_duration` - _120_
* `security.nt_acl_display_permission` - _false_
* `exports.netgroup_trust_any_nsswitch_no_match` - _false_
* `exports.name_service_lookup_protocol` - _udp_
* `security.permitted_encryption_types` - [aes-256,aes-128,des3,des]
* `security.rpcsec_context_idle` - _0_
* `security.chown_mode` - _use_export_policy_
* `security.ntfs_unix_security` - _use_export_policy_
* `windows.v3_ms_dos_client_enabled` - _false_
* `windows.default_user` - ""
* `windows.map_unknown_uid_to_default_user` - _true_
* `credential_cache.positive_ttl` - _86400000_
* `credential_cache.negative_ttl` - _7200000_
* `credential_cache.transient_error_ttl` - _30000_
* `protocol.v40_features.acl_preserve` - _true_
* `protocol.v41_features.implementation_domain` - 'netapp.com'
* `protocol.v40_features.acl_max_aces` - _400_
* `protocol.v3_features.ejukebox_enabled` - _true_
* `protocol.v3_features.connection_drop` - _true_
* `protocol.v3_features.fsid_change` - _true_
* `protocol.v3_features.mount_daemon_port` - _635_
* `protocol.v3_features.network_lock_manager_port` - _4045_
* `protocol.v3_features.network_status_monitor_port` - _4046_
* `protocol.v3_features.rquota_daemon_port` - _4046_
* `protocol.v3_features.mount_root_only` - _true_
* `transport.tcp_max_transfer_size` - _65536_
* `root.ignore_nt_acl` - _false_
* `root.skip_write_permission_check` - _false_
### Related ONTAP commands
* `vserver nfs create`
* `export-policy access-cache config show`
### Learn more
* [`DOC /protocols/nfs/services`](#docs-NAS-protocols_nfs_services)
*/
func (a *Client) NfsCreate(params *NfsCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nfs_create",
		Method:             "POST",
		PathPattern:        "/protocols/nfs/services",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NfsCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NfsCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	NfsDelete Deletes the NFS configuration of an SVM.

### Related ONTAP commands
* `vserver nfs delete`
### Learn more
* [`DOC /protocols/nfs/services`](#docs-NAS-protocols_nfs_services)
*/
func (a *Client) NfsDelete(params *NfsDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nfs_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/nfs/services/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NfsDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NfsDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	NfsGet Retrieves the NFS configuration of an SVM.

### Related ONTAP commands
* `vserver nfs show`
* `vserver nfs status`
### Learn more
* [`DOC /protocols/nfs/services`](#docs-NAS-protocols_nfs_services)
*/
func (a *Client) NfsGet(params *NfsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nfs_get",
		Method:             "GET",
		PathPattern:        "/protocols/nfs/services/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NfsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NfsGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	NfsModify Updates the NFS configuration of an SVM.

### Related ONTAP commands
* `vserver nfs modify`
* `vserver nfs on`
* `vserver nfs off`
* `vserver nfs start`
* `vserver nfs stop`
### Learn more
* [`DOC /protocols/nfs/services`](#docs-NAS-protocols_nfs_services)
*/
func (a *Client) NfsModify(params *NfsModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NfsModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nfs_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/nfs/services/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NfsModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NfsModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	PoliciesAndRulesToBeAppliedCollectionGet Retrieves group policy objects that are yet to be applied for all SVMs.

### Related ONTAP commands
* `vserver cifs group-policy show-defined`
*/
func (a *Client) PoliciesAndRulesToBeAppliedCollectionGet(params *PoliciesAndRulesToBeAppliedCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PoliciesAndRulesToBeAppliedCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoliciesAndRulesToBeAppliedCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "policies_and_rules_to_be_applied_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/group-policies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoliciesAndRulesToBeAppliedCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PoliciesAndRulesToBeAppliedCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PoliciesAndRulesToBeAppliedCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	PoliciesAndRulesToBeAppliedGet Retrieves group policy objects that are yet to be applied for specified SVM.

### Related ONTAP commands
* `vserver cifs group-policy show-defined`
*/
func (a *Client) PoliciesAndRulesToBeAppliedGet(params *PoliciesAndRulesToBeAppliedGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PoliciesAndRulesToBeAppliedGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoliciesAndRulesToBeAppliedGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "policies_and_rules_to_be_applied_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/group-policies/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PoliciesAndRulesToBeAppliedGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PoliciesAndRulesToBeAppliedGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PoliciesAndRulesToBeAppliedGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	S3AuditCreate Creates an S3 audit configuration.

### Required properties
* `log_path` - Path in the owning SVM namespace that is used to store audit logs.
### Default property values
If not specified in POST, the following default property values are assigned:
* `enabled` - _true_
* `events.data` - _true_
* `events.management` - _false_
* `log.format` - _json_
* `log.retention.count` - _0_
* `log.retention.duration` - _PT0S_
* `log.rotation.size` - _100MB_
* `log.rotation.now` - _false_
### Related ONTAP commands
* `vserver object-store-server audit create`
* `vserver object-store-server audit enable`
### Learn more
* [`DOC /protocols/audit/{svm.uuid}/object-store`](#docs-NAS-protocols_audit_{svm.uuid}_object-store)
*/
func (a *Client) S3AuditCreate(params *S3AuditCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*S3AuditCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewS3AuditCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "s3_audit_create",
		Method:             "POST",
		PathPattern:        "/protocols/audit/{svm.uuid}/object-store",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &S3AuditCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*S3AuditCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*S3AuditCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	S3AuditDelete Deletes an S3 audit configuration.

### Related ONTAP commands
* `vserver object-store-server audit disable`
* `vserver object-store-server audit delete`
### Learn more
* [`DOC /protocols/audit/{svm.uuid}/object-store`](#docs-NAS-protocols_audit_{svm.uuid}_object-store)
*/
func (a *Client) S3AuditDelete(params *S3AuditDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*S3AuditDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewS3AuditDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "s3_audit_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/audit/{svm.uuid}/object-store",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &S3AuditDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*S3AuditDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*S3AuditDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	S3AuditGet Retrieves S3 audit configurations.

### Related ONTAP commands
* `vserver object-store-server audit show`
### Learn more
* [`DOC /protocols/audit/{svm.uuid}/object-store`](#docs-NAS-protocols_audit_{svm.uuid}_object-store)
*/
func (a *Client) S3AuditGet(params *S3AuditGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*S3AuditGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewS3AuditGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "s3_audit_get",
		Method:             "GET",
		PathPattern:        "/protocols/audit/{svm.uuid}/object-store",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &S3AuditGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*S3AuditGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*S3AuditGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	S3AuditModify Updates an S3 audit configuration for an SVM.

### Important notes
* `events` - Not specifying either data or management is equivalent to setting it to false.
### Related ONTAP commands
* `vserver object-store-server audit modify`
### Learn more
* [`DOC /protocols/audit/{svm.uuid}/object-store`](#docs-NAS-protocols_audit_{svm.uuid}_object-store)
*/
func (a *Client) S3AuditModify(params *S3AuditModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*S3AuditModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewS3AuditModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "s3_audit_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/audit/{svm.uuid}/object-store",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &S3AuditModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*S3AuditModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*S3AuditModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ShadowcopyCollectionGet Retrieves Shadowcopies

### Related ONTAP commands
* `vserver cifs shadowcopy show-shares`
### Learn more
* [`DOC /protocols/cifs/shadow-copies`](#docs-NAS-protocols_cifs_shadow-copies)
*/
func (a *Client) ShadowcopyCollectionGet(params *ShadowcopyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShadowcopyCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewShadowcopyCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "shadowcopy_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/shadow-copies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ShadowcopyCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ShadowcopyCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ShadowcopyCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ShadowcopyGet Retrieves a Shadowcopy

### Related ONTAP commands
* `vserver cifs shadowcopy show-shares`
### Learn more
* [`DOC /protocols/cifs/shadow-copies`](#docs-NAS-protocols_cifs_shadow-copies)
*/
func (a *Client) ShadowcopyGet(params *ShadowcopyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShadowcopyGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewShadowcopyGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "shadowcopy_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/shadow-copies/{client_uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ShadowcopyGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ShadowcopyGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ShadowcopyGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ShadowcopyModify Specify list Files to be added as a part of Shadowcopy creation

### Learn more
* [`DOC /protocols/cifs/shadow-copies`](#docs-NAS-protocols_cifs_shadow-copies)
*/
func (a *Client) ShadowcopyModify(params *ShadowcopyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShadowcopyModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewShadowcopyModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "shadowcopy_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/cifs/shadow-copies/{client_uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ShadowcopyModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ShadowcopyModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ShadowcopyModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ShadowcopySetCollectionGet Retrieves Shadowcopy Sets.

### Related ONTAP commands
* `vserver cifs shadowcopy show-sets`
### Learn more
* [`DOC /protocols/cifs/shadow-copies`](#docs-NAS-protocols_cifs_shadow-copies)
*/
func (a *Client) ShadowcopySetCollectionGet(params *ShadowcopySetCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShadowcopySetCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewShadowcopySetCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "shadowcopy_set_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/shadowcopy-sets",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ShadowcopySetCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ShadowcopySetCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ShadowcopySetCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ShadowcopySetGet Retrieves a Shadowcopy set

### Related ONTAP commands
* `vserver cifs shadowcopy show-sets`
### Learn more
* [`DOC /protocols/cifs/shadow-copies`](#docs-NAS-protocols_cifs_shadow-copies)
*/
func (a *Client) ShadowcopySetGet(params *ShadowcopySetGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShadowcopySetGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewShadowcopySetGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "shadowcopy_set_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/shadowcopy-sets/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ShadowcopySetGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ShadowcopySetGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ShadowcopySetGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ShadowcopySetModify Updates a Shadowcopy set

### Learn more
* [`DOC /protocols/cifs/shadowcopy`](#docs-NAS-protocols_cifs_shadowcopy)
*/
func (a *Client) ShadowcopySetModify(params *ShadowcopySetModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShadowcopySetModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewShadowcopySetModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "shadowcopy_set_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/cifs/shadowcopy-sets/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ShadowcopySetModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ShadowcopySetModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ShadowcopySetModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UserGroupPrivilegesCollectionGet Retrieves privileges of the specified local or Active Directory user or group and SVM.

### Related ONTAP commands
* `vserver cifs users-and-groups privilege show`
### Learn more
* [`DOC /protocols/cifs/users-and-groups/privileges`](#docs-NAS-protocols_cifs_users-and-groups_privileges)
*/
func (a *Client) UserGroupPrivilegesCollectionGet(params *UserGroupPrivilegesCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserGroupPrivilegesCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserGroupPrivilegesCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "user_group_privileges_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/users-and-groups/privileges",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UserGroupPrivilegesCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UserGroupPrivilegesCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UserGroupPrivilegesCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UserGroupPrivilegesCreate Adds privileges to the specified local or Active Directory user or group and SVM.

### Important note
* Specified privileges are appended to the existing list of privileges.
### Required properties
* `svm.uuid` or `svm.name` - Existing SVM for which privileges are added to user or group.
* `name` - Exising local or Active Directory user or group for which privileges are to be added.
* `privileges` - List of privileges to be added to a user or group.
### Related ONTAP commands
* `vserver cifs users-and-groups privilege add-privilege`
### Learn more
* [`DOC /protocols/cifs/users-and-groups/privileges`](#docs-NAS-protocols_cifs_users-and-groups_privileges)
*/
func (a *Client) UserGroupPrivilegesCreate(params *UserGroupPrivilegesCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserGroupPrivilegesCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserGroupPrivilegesCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "user_group_privileges_create",
		Method:             "POST",
		PathPattern:        "/protocols/cifs/users-and-groups/privileges",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UserGroupPrivilegesCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UserGroupPrivilegesCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UserGroupPrivilegesCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UserGroupPrivilegesGet Retrieves privileges of the specified local or Active Directory user or group and SVM.

### Related ONTAP commands
* `vserver cifs users-and-groups privilege show`
### Learn more
* [`DOC /protocols/cifs/users-and-groups/privileges`](#docs-NAS-protocols_cifs_users-and-groups_privileges)
*/
func (a *Client) UserGroupPrivilegesGet(params *UserGroupPrivilegesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserGroupPrivilegesGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserGroupPrivilegesGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "user_group_privileges_get",
		Method:             "GET",
		PathPattern:        "/protocols/cifs/users-and-groups/privileges/{svm.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UserGroupPrivilegesGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UserGroupPrivilegesGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UserGroupPrivilegesGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UserGroupPrivilegesModify Updates privileges of the specified local or Active Directory user or group and SVM.

### Important note
* Specified privileges will replace all the existing privileges associated with the user or group.
* To reset privileges associated with the user or group, specify the privileges list as empty.
### Related ONTAP commands
* `vserver cifs users-and-groups privilege reset-privilege`
### Learn more
* [`DOC /protocols/cifs/users-and-groups/privileges`](#docs-NAS-protocols_cifs_users-and-groups_privileges)
*/
func (a *Client) UserGroupPrivilegesModify(params *UserGroupPrivilegesModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserGroupPrivilegesModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserGroupPrivilegesModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "user_group_privileges_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/cifs/users-and-groups/privileges/{svm.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UserGroupPrivilegesModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UserGroupPrivilegesModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UserGroupPrivilegesModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanCollectionGet Retrieves the Vscan configuration.

This includes scanner-pools, On-Access policies, On-Demand policies, and information about whether a Vscan is enabled or disabled on an SVM.<br/>
Important notes:
* You can enable only one Vscan configuration at a time for an SVM.
* You can only query using `svm.uuid` or `svm.name`.
### Related ONTAP commands
* `vserver vscan show`
* `vserver vscan scanner-pool show`
* `vserver vscan scanner-pool servers show`
* `vserver vscan scanner-pool privileged-users show`
* `vserver vscan on-access-policy show`
* `vserver vscan on-access-policy file-ext-to-exclude show`
* `vserver vscan on-access-policy file-ext-to-include show`
* `vserver vscan on-access-policy paths-to-exclude show`
* `vserver vscan on-demand-task show`
### Learn more
* [`DOC /protocols/vscan`](#docs-NAS-protocols_vscan)
* [`DOC /protocols/vscan/{svm.uuid}/scanner-pools`](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools)
*/
func (a *Client) VscanCollectionGet(params *VscanCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/vscan",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanConfigDelete Deletes a Vscan configuration.<br/>

Important notes:
* The Vscan DELETE endpoint deletes all of the Vscan configuration of an SVM. It first disables the Vscan and then deletes all of the SVM scanner-pools, On-Access policies, and On-Demand policies.
* Disable the active Vscan On-Access policy on an SVM before performing the Vscan delete operation on that SVM.
### Related ONTAP commands
* `vserver vscan scanner-pool delete`
* `vserver vscan on-access-policy delete`
* `vserver vscan on-demand-policy delete`
### Learn more
* [`DOC /protocols/vscan`](#docs-NAS-protocols_vscan)
* [`DOC /protocols/vscan/{svm.uuid}/scanner-pools`](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools)
*/
func (a *Client) VscanConfigDelete(params *VscanConfigDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanConfigDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanConfigDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_config_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/vscan/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanConfigDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanConfigDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanConfigDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanCreate Creates a Vscan configuration, which includes a list of scanner-pools, Vscan On-Access policies and Vscan On-Demand policies. Defines whether the Vscan configuration you create is enabled or disabled for a specified SVM.<br/>

Important notes:
* You can enable only one Vscan configuration at a time for an SVM.
* There needs to be at least one active scanner-pool and one enabled On-Access policy to enable Vscan successfully.
* By default, a Vscan is enabled when its created.
* By default, the Vscan On-Access policies created from this endpoint are in the disabled state. You can use the On-Access policy PATCH endpoint to enable a particular On-Access policy. In ONTAP 9.6, only one Vscan On-Access policy can be enabled and only one Vscan On-Demand policy can be scheduled on an SVM.
### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the Vscan configuration.
### Recommended optional properties
* `scanner_pools` - There must be at least one active scanner-pool for Vscan configuration. Created either through Vscan POST operation or scanner-pools POST operation.
### Default property values
If not specified in POST, the following default property value is assigned:
* `enabled` - _true_
### Related ONTAP commands
* `vserver vscan enable`
* `vserver vscan scanner-pool create`
* `vserver vscan scanner-pool apply-policy`
* `vserver vscan scanner-pool servers add`
* `vserver vscan scanner-pool privileged-users add`
* `vserver vscan on-access-policy create`
* `vserver vscan on-access-policy file-ext-to-exclude add`
* `vserver vscan on-access-policy file-ext-to-include add`
* `vserver vscan on-access-policy paths-to-exclude add`
* `vserver vscan on-demand-task create`
### Learn more
* [`DOC /protocols/vscan`](#docs-NAS-protocols_vscan)
* [`DOC /protocols/vscan/{svm.uuid}/scanner-pools`](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools)
*/
func (a *Client) VscanCreate(params *VscanCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_create",
		Method:             "POST",
		PathPattern:        "/protocols/vscan",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanEventCollectionGet Retrieves Vscan events, which are generated by the cluster to capture important events.

### Related ONTAP commands
* `vserver vscan show-events`
*/
func (a *Client) VscanEventCollectionGet(params *VscanEventCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanEventCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanEventCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_event_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/vscan/{svm.uuid}/events",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanEventCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanEventCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanEventCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanGet Retrieves the Vscan configuration for a specified SVM.

This includes scanner-pools, On-Access policies, On-Demand policies, and information about whether a Vscan is enabled or disabled on an SVM.<br/>
Important note:
* You can enable only one Vscan configuration at a time for an SVM.
### Related ONTAP commands
* `vserver vscan show`
* `vserver vscan scanner-pool show`
* `vserver vscan scanner-pool servers show`
* `vserver vscan scanner-pool privileged-users show`
* `vserver vscan on-access-policy show`
* `vserver vscan on-access-policy file-ext-to-exclude show`
* `vserver vscan on-access-policy file-ext-to-include show`
* `vserver vscan on-access-policy paths-to-exclude show`
* `vserver vscan on-demand-task show`
### Learn more
* [`DOC /protocols/vscan`](#docs-NAS-protocols_vscan)
* [`DOC /protocols/vscan/{svm.uuid}/scanner-pools`](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools)
*/
func (a *Client) VscanGet(params *VscanGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_get",
		Method:             "GET",
		PathPattern:        "/protocols/vscan/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanModify Updates the Vscan configuration of an SVM. Allows you to either enable or disable a Vscan, and allows you to clear the Vscan cache that stores the past scanning data for an SVM.<br/>

Important note:
* The Vscan PATCH endpoint does not allow you to modify scanner-pools, On-Demand policies or On-Access policies. Those modifications can only be done through their respective endpoints.
### Related ONTAP commands
* `vserver vscan enable`
* `vserver vscan disable`
* `vserver vscan reset`
### Learn more
* [`DOC /protocols/vscan`](#docs-NAS-protocols_vscan)
* [`DOC /protocols/vscan/{svm.uuid}/scanner-pools`](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools)
*/
func (a *Client) VscanModify(params *VscanModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/vscan/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanOnAccessCreate Creates a Vscan On-Access policy. Created only on a data SVM.

</b>Important notes:
* You must enable the policy on an SVM before its files can be scanned.
* You can enable only one On-Access policy at a time on an SVM. By default, the policy is enabled on creation. * If the Vscan On-Access policy has been created successfully on an SVM but cannot be enabled due to an error, the Vscan On-Access policy configurations are saved. The Vscan On-Access policy is then enabled using the PATCH operation.
### Required properties
* `svm.uuid` - Existing SVM in which to create the Vscan On-Access policy.
* `name` - Name of the Vscan On-Access policy. Maximum length is 256 characters.
### Default property values
If not specified in POST, the following default property values are assigned:
* `enabled` - _true_
* `mandatory` - _true_
* `include_extensions` - _*_
* `max_file_size` - _2147483648_
* `only_execute_access` - _false_
* `scan_readonly_volumes` - _false_
* `scan_without_extension` - _true_
### Related ONTAP commands
* `vserver vscan on-access-policy create`
* `vserver vscan on-access-policy enable`
* `vserver vscan on-access-policy disable`
* `vserver vscan on-access-policy file-ext-to-include add`
* `vserver vscan on-access-policy file-ext-to-exclude add`
* `vserver vscan on-access-policy paths-to-exclude add`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/on-access-policies`](#docs-NAS-protocols_vscan_{svm.uuid}_on-access-policies)
*/
func (a *Client) VscanOnAccessCreate(params *VscanOnAccessCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnAccessCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanOnAccessCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_on_access_create",
		Method:             "POST",
		PathPattern:        "/protocols/vscan/{svm.uuid}/on-access-policies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanOnAccessCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanOnAccessCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanOnAccessCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanOnAccessDelete Deletes the anti-virus On-Access policy configuration.

### Related ONTAP commands
* `vserver vscan on-access-policy delete`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/on-access-policies`](#docs-NAS-protocols_vscan_{svm.uuid}_on-access-policies)
*/
func (a *Client) VscanOnAccessDelete(params *VscanOnAccessDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnAccessDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanOnAccessDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_on_access_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/vscan/{svm.uuid}/on-access-policies/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanOnAccessDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanOnAccessDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanOnAccessDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanOnAccessGet Retrieves the Vscan On-Access policy configuration of an SVM.

### Related ONTAP commands
* `vserver vscan on-access-policy show`
* `vserver vscan on-access-policy file-ext-to-include show`
* `vserver vscan on-access-policy file-ext-to-exclude show`
* `vserver vscan on-access-policy paths-to-exclude show`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/on-access-policies`](#docs-NAS-protocols_vscan_{svm.uuid}_on-access-policies)
*/
func (a *Client) VscanOnAccessGet(params *VscanOnAccessGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnAccessGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanOnAccessGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_on_access_get",
		Method:             "GET",
		PathPattern:        "/protocols/vscan/{svm.uuid}/on-access-policies/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanOnAccessGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanOnAccessGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanOnAccessGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanOnAccessModify Updates the Vscan On-Access policy configuration and/or enables/disables the Vscan On-Access policy of an SVM. You cannot modify the configurations for an On-Access policy associated with an administrative SVM, although you can encable and disable the policy associated with an administrative SVM.

### Related ONTAP commands
* `vserver vscan on-access-policy modify`
* `vserver vscan on-access-policy enable`
* `vserver vscan on-access-policy disable`
* `vserver vscan on-access-policy file-ext-to-include add`
* `vserver vscan on-access-policy file-ext-to-exclude add`
* `vserver vscan on-access-policy paths-to-exclude add`
* `vserver vscan on-access-policy file-ext-to-include remove`
* `vserver vscan on-access-policy file-ext-to-exclude remove`
* `vserver vscan on-access-policy paths-to-exclude remove`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/on-access-policies`](#docs-NAS-protocols_vscan_{svm.uuid}_on-access-policies)
*/
func (a *Client) VscanOnAccessModify(params *VscanOnAccessModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnAccessModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanOnAccessModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_on_access_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/vscan/{svm.uuid}/on-access-policies/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanOnAccessModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanOnAccessModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanOnAccessModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanOnAccessPolicyCollectionGet Retrieves the Vscan On-Access policy.

### Related ONTAP commands
* `vserver vscan on-access-policy show`
* `vserver vscan on-access-policy file-ext-to-include show`
* `vserver vscan on-access-policy file-ext-to-exclude show`
* `vserver vscan on-access-policy paths-to-exclude show`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/on-access-policies`](#docs-NAS-protocols_vscan_{svm.uuid}_on-access-policies)
*/
func (a *Client) VscanOnAccessPolicyCollectionGet(params *VscanOnAccessPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnAccessPolicyCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanOnAccessPolicyCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_on_access_policy_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/vscan/{svm.uuid}/on-access-policies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanOnAccessPolicyCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanOnAccessPolicyCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanOnAccessPolicyCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanOnDemandCreate Creates a Vscan On-Demand policy. Created only on a data SVM.

</br> Important notes:
  - Only one policy can be scheduled at a time on an SVM. Use schedule name or schedule uuid to schedule an On-Demand policy.
  - Scanning must be enabled on the SVM before the policy is scheduled to run.
  - The exclude_extensions setting overrides the include_extensions setting. Set scan_without_extension to true to scan files without extensions.

### Required properties
* `svm.uuid` - Existing SVM in which to create the Vscan On-Demand policy.
* `name` - Name of the Vscan On-Demand policy. Maximum length is 256 characters.
* `log_path` - Path from the Vserver root where the On-Demand policy report is created.
* `scan_paths` - List of paths that need to be scanned.
### Recommended optional properties
* `schedule` - Scan schedule. It is recommended to set the schedule property, as it dictates when to scan for viruses.
### Default property values
If not specified in POST, the following default property values are assigned:
* `include_extensions` - _*_
* `max_file_size` - _10737418240_
* `scan_without_extension` - _true_
### Related ONTAP commands
* `vserver vscan on-demand-task create`
* `vserver vscan on-demand-task schedule`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/on-demand-policies`](#docs-NAS-protocols_vscan_{svm.uuid}_on-demand-policies)
*/
func (a *Client) VscanOnDemandCreate(params *VscanOnDemandCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnDemandCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanOnDemandCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_on_demand_create",
		Method:             "POST",
		PathPattern:        "/protocols/vscan/{svm.uuid}/on-demand-policies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanOnDemandCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanOnDemandCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanOnDemandCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanOnDemandDelete Deletes the Vscan On-Demand configuration.

### Related ONTAP commands
* `vserver vscan on-demand-task delete`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/on-demand-policies`](#docs-NAS-protocols_vscan_{svm.uuid}_on-demand-policies)
*/
func (a *Client) VscanOnDemandDelete(params *VscanOnDemandDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnDemandDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanOnDemandDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_on_demand_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/vscan/{svm.uuid}/on-demand-policies/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanOnDemandDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanOnDemandDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanOnDemandDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanOnDemandGet Retrieves the Vscan On-Demand configuration of an SVM.

### Related ONTAP commands
* `vserver vscan on-demand-task show`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/on-demand-policies`](#docs-NAS-protocols_vscan_{svm.uuid}_on-demand-policies)
*/
func (a *Client) VscanOnDemandGet(params *VscanOnDemandGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnDemandGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanOnDemandGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_on_demand_get",
		Method:             "GET",
		PathPattern:        "/protocols/vscan/{svm.uuid}/on-demand-policies/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanOnDemandGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanOnDemandGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanOnDemandGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanOnDemandModify Updates the Vscan On-Demand policy configuration of an SVM. Use schedule name or schedule UUID to schedule an On-Demand scan.

### Related ONTAP commands
* `vserver vscan on-demand-task modify`
* `vserver vscan on-demand-task schedule`
* `vserver vscan on-demand-task unschedule`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/on-demand-policies`](#docs-NAS-protocols_vscan_{svm.uuid}_on-demand-policies)
*/
func (a *Client) VscanOnDemandModify(params *VscanOnDemandModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnDemandModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanOnDemandModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_on_demand_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/vscan/{svm.uuid}/on-demand-policies/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanOnDemandModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanOnDemandModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanOnDemandModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanOnDemandPolicyCollectionGet Retrieves the Vscan On-Demand policy.

### Related ONTAP commands
* `vserver vscan on-demand-task show`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/on-demand-policies`](#docs-NAS-protocols_vscan_{svm.uuid}_on-demand-policies)
*/
func (a *Client) VscanOnDemandPolicyCollectionGet(params *VscanOnDemandPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanOnDemandPolicyCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanOnDemandPolicyCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_on_demand_policy_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/vscan/{svm.uuid}/on-demand-policies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanOnDemandPolicyCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanOnDemandPolicyCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanOnDemandPolicyCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanScannerCollectionGet Retrieves the Vscan scanner-pool configuration of an SVM.

### Related ONTAP commands
* `vserver vscan scanner-pool show`
* `vserver vscan scanner-pool privileged-users show`
* `vserver vscan scanner-pool servers show`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/scanner-pools`](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools)
*/
func (a *Client) VscanScannerCollectionGet(params *VscanScannerCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanScannerCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanScannerCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_scanner_collection_get",
		Method:             "GET",
		PathPattern:        "/protocols/vscan/{svm.uuid}/scanner-pools",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanScannerCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanScannerCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanScannerCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanScannerCreate Creates a Vscan scanner-pool configuration for a specified SVM. You can create a scanner-pool with all fields specified or only mandatory fields specified.<br/>

Important notes:
* A scanner-pool must have servers and privileged users specified.
* If the role or cluster is not specified, the scanner-pool is created on the local cluster with the role set as primary.
*`Only one of the fields cluster-uuid or cluster-name is required.
### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the Vscan configuration.
* `name` - Scanner-pool name.
* `privileged_users` - List of privileged users.
* `servers` - List of server IP addresses or FQDNs.
### Recommended optional properties
* `role` - Setting a role for a scanner-pool is recommended.
* `cluster` - Passing the cluster name or UUID (or both) in a multi-cluster environment is recommended.
### Default property values
If not specified in POST, the following default property values are assigned:
* `role` - _primary_
* `cluster.name` - Local cluster name.
* `cluster.uuid` - Local cluster UUID.
### Related ONTAP commands
* `vserver vscan scanner-pool create`
* `vserver vscan scanner-pool apply-policy`
* `vserver vscan scanner-pool privileged-users add`
* `vserver vscan scanner-pool servers add`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/scanner-pools`](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools)
*/
func (a *Client) VscanScannerCreate(params *VscanScannerCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanScannerCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanScannerCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_scanner_create",
		Method:             "POST",
		PathPattern:        "/protocols/vscan/{svm.uuid}/scanner-pools",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanScannerCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanScannerCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanScannerCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanScannerDelete Deletes a Vscan scanner-pool configuration.<br/>

Important notes:
* The Vscan scanner-pool DELETE endpoint deletes all of the Vscan scanner-pools for a specified SVM.
* If a Vscan is enabled, it requires at least one scanner-pool to be in the active state. Therefore, disable Vscan on the specified SVM so all the scanner-pools configured on that SVM can be deleted.
### Related ONTAP commands
* `vserver vscan scanner-pool delete`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/scanner-pools`](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools)
*/
func (a *Client) VscanScannerDelete(params *VscanScannerDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanScannerDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanScannerDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_scanner_delete",
		Method:             "DELETE",
		PathPattern:        "/protocols/vscan/{svm.uuid}/scanner-pools/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanScannerDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanScannerDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanScannerDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanScannerModify Updates the Vscan scanner-pool configuration of an SVM.<br/>

Important notes:
* Along with servers and privileged-users, the role of a scanner-pool can also be updated with the cluster on which a scanner-pool is allowed.
* If role is specified and cluster isn't, then role is applied to the local cluster.
### Related ONTAP commands
* `vserver vscan scanner-pool modify`
* `vserver vscan scanner-pool apply-policy`
* `vserver vscan scanner-pool privileged-users add`
* `vserver vscan scanner-pool privileged-users remove`
* `vserver vscan scanner-pool servers remove`
* `vserver vscan scanner-pool servers add`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/scanner-pools`](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools)
*/
func (a *Client) VscanScannerModify(params *VscanScannerModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanScannerModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanScannerModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_scanner_modify",
		Method:             "PATCH",
		PathPattern:        "/protocols/vscan/{svm.uuid}/scanner-pools/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanScannerModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanScannerModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanScannerModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanScannerPoolGet Retrieves the configuration of a specified scanner-pool of an SVM.

### Related ONTAP commands
* `vserver vscan scanner-pool show`
* `vserver vscan scanner-pool privileged-users show`
* `vserver vscan scanner-pool servers show`
### Learn more
* [`DOC /protocols/vscan/{svm.uuid}/scanner-pools`](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools)
*/
func (a *Client) VscanScannerPoolGet(params *VscanScannerPoolGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanScannerPoolGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanScannerPoolGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_scanner_pool_get",
		Method:             "GET",
		PathPattern:        "/protocols/vscan/{svm.uuid}/scanner-pools/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanScannerPoolGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanScannerPoolGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanScannerPoolGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	VscanServerStatusGet Retrieves a Vscan server status.

### Related ONTAP commands
* `vserver vscan connection-status show-all`
### Learn more
* [`DOC /protocols/vscan/server-status`](#docs-NAS-protocols_vscan_server-status)
*/
func (a *Client) VscanServerStatusGet(params *VscanServerStatusGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VscanServerStatusGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVscanServerStatusGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "vscan_server_status_get",
		Method:             "GET",
		PathPattern:        "/protocols/vscan/server-status",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VscanServerStatusGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VscanServerStatusGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VscanServerStatusGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
