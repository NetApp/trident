// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NodeResponse node response
//
// swagger:model node_response
type NodeResponse struct {

	// links
	Links *NodeResponseLinks `json:"_links,omitempty"`

	// num records
	NumRecords int64 `json:"num_records,omitempty"`

	// records
	Records []*NodeResponseRecordsItems0 `json:"records,omitempty"`
}

// Validate validates this node response
func (m *NodeResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecords(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponse) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponse) validateRecords(formats strfmt.Registry) error {
	if swag.IsZero(m.Records) { // not required
		return nil
	}

	for i := 0; i < len(m.Records); i++ {
		if swag.IsZero(m.Records[i]) { // not required
			continue
		}

		if m.Records[i] != nil {
			if err := m.Records[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("records" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this node response based on the context it is used
func (m *NodeResponse) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecords(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponse) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponse) contextValidateRecords(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Records); i++ {

		if m.Records[i] != nil {
			if err := m.Records[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("records" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponse) UnmarshalBinary(b []byte) error {
	var res NodeResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseLinks node response links
//
// swagger:model NodeResponseLinks
type NodeResponseLinks struct {

	// next
	Next *Href `json:"next,omitempty"`

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this node response links
func (m *NodeResponseLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNext(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseLinks) validateNext(formats strfmt.Registry) error {
	if swag.IsZero(m.Next) { // not required
		return nil
	}

	if m.Next != nil {
		if err := m.Next.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "next")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response links based on the context it is used
func (m *NodeResponseLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNext(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseLinks) contextValidateNext(ctx context.Context, formats strfmt.Registry) error {

	if m.Next != nil {
		if err := m.Next.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "next")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseLinks) UnmarshalBinary(b []byte) error {
	var res NodeResponseLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0 Complete node information
//
// swagger:model NodeResponseRecordsItems0
type NodeResponseRecordsItems0 struct {

	// links
	Links *NodeResponseRecordsItems0Links `json:"_links,omitempty"`

	// cluster interface
	ClusterInterface *NodeResponseRecordsItems0ClusterInterface `json:"cluster_interface,omitempty"`

	// cluster interfaces
	// Read Only: true
	ClusterInterfaces []*NodeResponseRecordsItems0ClusterInterfacesItems0 `json:"cluster_interfaces,omitempty"`

	// controller
	Controller *NodeResponseRecordsItems0Controller `json:"controller,omitempty"`

	// The current or "wall clock" time of the node in ISO-8601 date, time, and time zone format.
	// The ISO-8601 date and time are localized based on the ONTAP cluster's timezone setting.
	//
	// Example: 2019-04-17T11:49:26-04:00
	// Read Only: true
	// Format: date-time
	Date *strfmt.DateTime `json:"date,omitempty"`

	// external cache
	ExternalCache *NodeResponseRecordsItems0ExternalCache `json:"external_cache,omitempty"`

	// ha
	Ha *NodeResponseRecordsItems0Ha `json:"ha,omitempty"`

	// hw assist
	HwAssist *NodeResponseRecordsItems0HwAssist `json:"hw_assist,omitempty"`

	// Specifies whether or not the node is in spares low condition.
	// Read Only: true
	IsSparesLow *bool `json:"is_spares_low,omitempty"`

	// location
	// Example: rack 2 row 5
	Location string `json:"location,omitempty"`

	// management interface
	ManagementInterface *NodeResponseRecordsItems0ManagementInterface `json:"management_interface,omitempty"`

	// management interfaces
	// Read Only: true
	ManagementInterfaces []*NodeResponseRecordsItems0ManagementInterfacesItems0 `json:"management_interfaces,omitempty"`

	// Possible values:
	// * <i>available</i> - A node is detected on the internal cluster network and can be added to the cluster.  Nodes that have a membership of "available" are not returned when a GET request is called when the cluster exists. Provide a query on the "membership" property for <i>available</i> to scan for nodes on the cluster network. Nodes that have a membership of "available" are returned automatically before a cluster is created.
	// * <i>joining</i> - Joining nodes are in the process of being added to the cluster. The node might be progressing through the steps to become a member or might have failed. The job to add the node or create the cluster provides details on the current progress of the node.
	// * <i>member</i> - Nodes that are members have successfully joined the cluster.
	//
	// Read Only: true
	// Enum: [available joining member]
	Membership string `json:"membership,omitempty"`

	// metric
	Metric *NodeResponseRecordsItems0Metric `json:"metric,omitempty"`

	// metrocluster
	Metrocluster *NodeResponseRecordsItems0Metrocluster `json:"metrocluster,omitempty"`

	// model
	// Example: FAS3070
	// Read Only: true
	Model string `json:"model,omitempty"`

	// name
	// Example: node-01
	Name string `json:"name,omitempty"`

	// nvram
	Nvram *NodeResponseRecordsItems0Nvram `json:"nvram,omitempty"`

	// Owner of the node.
	// Example: Example Corp
	Owner string `json:"owner,omitempty"`

	// serial number
	// Example: 4048820-60-9
	// Read Only: true
	SerialNumber string `json:"serial_number,omitempty"`

	// service processor
	ServiceProcessor *NodeResponseRecordsItems0ServiceProcessor `json:"service_processor,omitempty"`

	// State of the node:
	// * <i>up</i> - Node is up and operational.
	// * <i>booting</i> - Node is booting up.
	// * <i>down</i> - Node has stopped or is dumping core.
	// * <i>taken_over</i> - Node has been taken over by its HA partner and is not yet waiting for giveback.
	// * <i>waiting_for_giveback</i> - Node has been taken over by its HA partner and is waiting for the HA partner to giveback disks.
	// * <i>degraded</i> - Node has one or more critical services offline.
	// * <i>unknown</i> - Node or its HA partner cannot be contacted and there is no information on the node's state.
	//
	// Read Only: true
	// Enum: [up booting down taken_over waiting_for_giveback degraded unknown]
	State string `json:"state,omitempty"`

	// statistics
	Statistics *NodeResponseRecordsItems0Statistics `json:"statistics,omitempty"`

	// The storage configuration in the system. Possible values:
	// * <i>mixed_path</i>
	// * <i>single_path</i>
	// * <i>multi_path</i>
	// * <i>quad_path</i>
	// * <i>mixed_path_ha</i>
	// * <i>single_path_ha</i>
	// * <i>multi_path_ha</i>
	// * <i>quad_path_ha</i>
	// * <i>unknown</i>
	//
	// Read Only: true
	// Enum: [unknown single_path multi_path mixed_path quad_path single_path_ha multi_path_ha mixed_path_ha quad_path_ha]
	StorageConfiguration string `json:"storage_configuration,omitempty"`

	// system id
	// Example: 0537035403
	// Read Only: true
	SystemID string `json:"system_id,omitempty"`

	// OEM system machine type.
	// Example: 7Y56-CTOWW1
	// Read Only: true
	SystemMachineType string `json:"system_machine_type,omitempty"`

	// The total time, in seconds, that the node has been up.
	// Example: 300536
	// Read Only: true
	Uptime int64 `json:"uptime,omitempty"`

	// uuid
	// Example: 4ea7a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`

	// OEM vendor serial number.
	// Example: 791603000068
	// Read Only: true
	VendorSerialNumber string `json:"vendor_serial_number,omitempty"`

	// version
	Version *NodeResponseRecordsItems0Version `json:"version,omitempty"`

	// vm
	VM *NodeResponseRecordsItems0VM `json:"vm,omitempty"`
}

// Validate validates this node response records items0
func (m *NodeResponseRecordsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterInterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateController(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalCache(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHa(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHwAssist(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementInterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMembership(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetrocluster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNvram(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceProcessor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVM(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateClusterInterface(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterInterface) { // not required
		return nil
	}

	if m.ClusterInterface != nil {
		if err := m.ClusterInterface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateClusterInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.ClusterInterfaces); i++ {
		if swag.IsZero(m.ClusterInterfaces[i]) { // not required
			continue
		}

		if m.ClusterInterfaces[i] != nil {
			if err := m.ClusterInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cluster_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateController(formats strfmt.Registry) error {
	if swag.IsZero(m.Controller) { // not required
		return nil
	}

	if m.Controller != nil {
		if err := m.Controller.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateDate(formats strfmt.Registry) error {
	if swag.IsZero(m.Date) { // not required
		return nil
	}

	if err := validate.FormatOf("date", "body", "date-time", m.Date.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateExternalCache(formats strfmt.Registry) error {
	if swag.IsZero(m.ExternalCache) { // not required
		return nil
	}

	if m.ExternalCache != nil {
		if err := m.ExternalCache.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external_cache")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateHa(formats strfmt.Registry) error {
	if swag.IsZero(m.Ha) { // not required
		return nil
	}

	if m.Ha != nil {
		if err := m.Ha.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateHwAssist(formats strfmt.Registry) error {
	if swag.IsZero(m.HwAssist) { // not required
		return nil
	}

	if m.HwAssist != nil {
		if err := m.HwAssist.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateManagementInterface(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementInterface) { // not required
		return nil
	}

	if m.ManagementInterface != nil {
		if err := m.ManagementInterface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateManagementInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.ManagementInterfaces); i++ {
		if swag.IsZero(m.ManagementInterfaces[i]) { // not required
			continue
		}

		if m.ManagementInterfaces[i] != nil {
			if err := m.ManagementInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("management_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var nodeResponseRecordsItems0TypeMembershipPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["available","joining","member"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0TypeMembershipPropEnum = append(nodeResponseRecordsItems0TypeMembershipPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// membership
	// Membership
	// available
	// END DEBUGGING
	// NodeResponseRecordsItems0MembershipAvailable captures enum value "available"
	NodeResponseRecordsItems0MembershipAvailable string = "available"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// membership
	// Membership
	// joining
	// END DEBUGGING
	// NodeResponseRecordsItems0MembershipJoining captures enum value "joining"
	NodeResponseRecordsItems0MembershipJoining string = "joining"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// membership
	// Membership
	// member
	// END DEBUGGING
	// NodeResponseRecordsItems0MembershipMember captures enum value "member"
	NodeResponseRecordsItems0MembershipMember string = "member"
)

// prop value enum
func (m *NodeResponseRecordsItems0) validateMembershipEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0TypeMembershipPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0) validateMembership(formats strfmt.Registry) error {
	if swag.IsZero(m.Membership) { // not required
		return nil
	}

	// value enum
	if err := m.validateMembershipEnum("membership", "body", m.Membership); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateMetric(formats strfmt.Registry) error {
	if swag.IsZero(m.Metric) { // not required
		return nil
	}

	if m.Metric != nil {
		if err := m.Metric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateMetrocluster(formats strfmt.Registry) error {
	if swag.IsZero(m.Metrocluster) { // not required
		return nil
	}

	if m.Metrocluster != nil {
		if err := m.Metrocluster.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metrocluster")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateNvram(formats strfmt.Registry) error {
	if swag.IsZero(m.Nvram) { // not required
		return nil
	}

	if m.Nvram != nil {
		if err := m.Nvram.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvram")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateServiceProcessor(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceProcessor) { // not required
		return nil
	}

	if m.ServiceProcessor != nil {
		if err := m.ServiceProcessor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor")
			}
			return err
		}
	}

	return nil
}

var nodeResponseRecordsItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["up","booting","down","taken_over","waiting_for_giveback","degraded","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0TypeStatePropEnum = append(nodeResponseRecordsItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// state
	// State
	// up
	// END DEBUGGING
	// NodeResponseRecordsItems0StateUp captures enum value "up"
	NodeResponseRecordsItems0StateUp string = "up"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// state
	// State
	// booting
	// END DEBUGGING
	// NodeResponseRecordsItems0StateBooting captures enum value "booting"
	NodeResponseRecordsItems0StateBooting string = "booting"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// state
	// State
	// down
	// END DEBUGGING
	// NodeResponseRecordsItems0StateDown captures enum value "down"
	NodeResponseRecordsItems0StateDown string = "down"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// state
	// State
	// taken_over
	// END DEBUGGING
	// NodeResponseRecordsItems0StateTakenOver captures enum value "taken_over"
	NodeResponseRecordsItems0StateTakenOver string = "taken_over"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// state
	// State
	// waiting_for_giveback
	// END DEBUGGING
	// NodeResponseRecordsItems0StateWaitingForGiveback captures enum value "waiting_for_giveback"
	NodeResponseRecordsItems0StateWaitingForGiveback string = "waiting_for_giveback"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// state
	// State
	// degraded
	// END DEBUGGING
	// NodeResponseRecordsItems0StateDegraded captures enum value "degraded"
	NodeResponseRecordsItems0StateDegraded string = "degraded"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// state
	// State
	// unknown
	// END DEBUGGING
	// NodeResponseRecordsItems0StateUnknown captures enum value "unknown"
	NodeResponseRecordsItems0StateUnknown string = "unknown"
)

// prop value enum
func (m *NodeResponseRecordsItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

var nodeResponseRecordsItems0TypeStorageConfigurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unknown","single_path","multi_path","mixed_path","quad_path","single_path_ha","multi_path_ha","mixed_path_ha","quad_path_ha"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0TypeStorageConfigurationPropEnum = append(nodeResponseRecordsItems0TypeStorageConfigurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// storage_configuration
	// StorageConfiguration
	// unknown
	// END DEBUGGING
	// NodeResponseRecordsItems0StorageConfigurationUnknown captures enum value "unknown"
	NodeResponseRecordsItems0StorageConfigurationUnknown string = "unknown"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// storage_configuration
	// StorageConfiguration
	// single_path
	// END DEBUGGING
	// NodeResponseRecordsItems0StorageConfigurationSinglePath captures enum value "single_path"
	NodeResponseRecordsItems0StorageConfigurationSinglePath string = "single_path"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// storage_configuration
	// StorageConfiguration
	// multi_path
	// END DEBUGGING
	// NodeResponseRecordsItems0StorageConfigurationMultiPath captures enum value "multi_path"
	NodeResponseRecordsItems0StorageConfigurationMultiPath string = "multi_path"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// storage_configuration
	// StorageConfiguration
	// mixed_path
	// END DEBUGGING
	// NodeResponseRecordsItems0StorageConfigurationMixedPath captures enum value "mixed_path"
	NodeResponseRecordsItems0StorageConfigurationMixedPath string = "mixed_path"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// storage_configuration
	// StorageConfiguration
	// quad_path
	// END DEBUGGING
	// NodeResponseRecordsItems0StorageConfigurationQuadPath captures enum value "quad_path"
	NodeResponseRecordsItems0StorageConfigurationQuadPath string = "quad_path"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// storage_configuration
	// StorageConfiguration
	// single_path_ha
	// END DEBUGGING
	// NodeResponseRecordsItems0StorageConfigurationSinglePathHa captures enum value "single_path_ha"
	NodeResponseRecordsItems0StorageConfigurationSinglePathHa string = "single_path_ha"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// storage_configuration
	// StorageConfiguration
	// multi_path_ha
	// END DEBUGGING
	// NodeResponseRecordsItems0StorageConfigurationMultiPathHa captures enum value "multi_path_ha"
	NodeResponseRecordsItems0StorageConfigurationMultiPathHa string = "multi_path_ha"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// storage_configuration
	// StorageConfiguration
	// mixed_path_ha
	// END DEBUGGING
	// NodeResponseRecordsItems0StorageConfigurationMixedPathHa captures enum value "mixed_path_ha"
	NodeResponseRecordsItems0StorageConfigurationMixedPathHa string = "mixed_path_ha"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// storage_configuration
	// StorageConfiguration
	// quad_path_ha
	// END DEBUGGING
	// NodeResponseRecordsItems0StorageConfigurationQuadPathHa captures enum value "quad_path_ha"
	NodeResponseRecordsItems0StorageConfigurationQuadPathHa string = "quad_path_ha"
)

// prop value enum
func (m *NodeResponseRecordsItems0) validateStorageConfigurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0TypeStorageConfigurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0) validateStorageConfiguration(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageConfiguration) { // not required
		return nil
	}

	// value enum
	if err := m.validateStorageConfigurationEnum("storage_configuration", "body", m.StorageConfiguration); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateVM(formats strfmt.Registry) error {
	if swag.IsZero(m.VM) { // not required
		return nil
	}

	if m.VM != nil {
		if err := m.VM.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vm")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 based on the context it is used
func (m *NodeResponseRecordsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterInterface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateController(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExternalCache(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHa(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHwAssist(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsSparesLow(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementInterface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMembership(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetrocluster(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNvram(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServiceProcessor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStorageConfiguration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSystemID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSystemMachineType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUptime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVendorSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVM(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateClusterInterface(ctx context.Context, formats strfmt.Registry) error {

	if m.ClusterInterface != nil {
		if err := m.ClusterInterface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateClusterInterfaces(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cluster_interfaces", "body", []*NodeResponseRecordsItems0ClusterInterfacesItems0(m.ClusterInterfaces)); err != nil {
		return err
	}

	for i := 0; i < len(m.ClusterInterfaces); i++ {

		if m.ClusterInterfaces[i] != nil {
			if err := m.ClusterInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cluster_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateController(ctx context.Context, formats strfmt.Registry) error {

	if m.Controller != nil {
		if err := m.Controller.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "date", "body", m.Date); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateExternalCache(ctx context.Context, formats strfmt.Registry) error {

	if m.ExternalCache != nil {
		if err := m.ExternalCache.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external_cache")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateHa(ctx context.Context, formats strfmt.Registry) error {

	if m.Ha != nil {
		if err := m.Ha.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateHwAssist(ctx context.Context, formats strfmt.Registry) error {

	if m.HwAssist != nil {
		if err := m.HwAssist.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateIsSparesLow(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "is_spares_low", "body", m.IsSparesLow); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateManagementInterface(ctx context.Context, formats strfmt.Registry) error {

	if m.ManagementInterface != nil {
		if err := m.ManagementInterface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateManagementInterfaces(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "management_interfaces", "body", []*NodeResponseRecordsItems0ManagementInterfacesItems0(m.ManagementInterfaces)); err != nil {
		return err
	}

	for i := 0; i < len(m.ManagementInterfaces); i++ {

		if m.ManagementInterfaces[i] != nil {
			if err := m.ManagementInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("management_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateMembership(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "membership", "body", string(m.Membership)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateMetric(ctx context.Context, formats strfmt.Registry) error {

	if m.Metric != nil {
		if err := m.Metric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateMetrocluster(ctx context.Context, formats strfmt.Registry) error {

	if m.Metrocluster != nil {
		if err := m.Metrocluster.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metrocluster")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateModel(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "model", "body", string(m.Model)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateNvram(ctx context.Context, formats strfmt.Registry) error {

	if m.Nvram != nil {
		if err := m.Nvram.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvram")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serial_number", "body", string(m.SerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateServiceProcessor(ctx context.Context, formats strfmt.Registry) error {

	if m.ServiceProcessor != nil {
		if err := m.ServiceProcessor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {
		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateStorageConfiguration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "storage_configuration", "body", string(m.StorageConfiguration)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateSystemID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "system_id", "body", string(m.SystemID)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateSystemMachineType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "system_machine_type", "body", string(m.SystemMachineType)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateUptime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uptime", "body", int64(m.Uptime)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", strfmt.UUID(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateVendorSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "vendor_serial_number", "body", string(m.VendorSerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {
		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateVM(ctx context.Context, formats strfmt.Registry) error {

	if m.VM != nil {
		if err := m.VM.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vm")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ClusterInterface The cluster network IP address of the node to be added.
//
// swagger:model NodeResponseRecordsItems0ClusterInterface
type NodeResponseRecordsItems0ClusterInterface struct {

	// ip
	IP *NodeSetupIP `json:"ip,omitempty"`
}

// Validate validates this node response records items0 cluster interface
func (m *NodeResponseRecordsItems0ClusterInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterface) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 cluster interface based on the context it is used
func (m *NodeResponseRecordsItems0ClusterInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterface) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterface) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ClusterInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ClusterInterfacesItems0 Network interface
//
// swagger:model NodeResponseRecordsItems0ClusterInterfacesItems0
type NodeResponseRecordsItems0ClusterInterfacesItems0 struct {

	// links
	Links *NodeResponseRecordsItems0ClusterInterfacesItems0Links `json:"_links,omitempty"`

	// ip
	IP *NodeResponseRecordsItems0ClusterInterfacesItems0IP `json:"ip,omitempty"`

	// The name of the interface. If only the name is provided, the SVM scope
	// must be provided by the object this object is embedded in.
	//
	// Example: lif1
	Name string `json:"name,omitempty"`

	// The UUID that uniquely identifies the interface.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this node response records items0 cluster interfaces items0
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 cluster interfaces items0 based on the context it is used
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ClusterInterfacesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ClusterInterfacesItems0IP IP information
//
// swagger:model NodeResponseRecordsItems0ClusterInterfacesItems0IP
type NodeResponseRecordsItems0ClusterInterfacesItems0IP struct {

	// address
	Address IPAddressReadonly `json:"address,omitempty"`
}

// Validate validates this node response records items0 cluster interfaces items0 IP
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0IP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0IP) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.Address) { // not required
		return nil
	}

	if err := m.Address.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 cluster interfaces items0 IP based on the context it is used
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0IP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0IP) contextValidateAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Address.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0IP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0IP) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ClusterInterfacesItems0IP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ClusterInterfacesItems0Links node response records items0 cluster interfaces items0 links
//
// swagger:model NodeResponseRecordsItems0ClusterInterfacesItems0Links
type NodeResponseRecordsItems0ClusterInterfacesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this node response records items0 cluster interfaces items0 links
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 cluster interfaces items0 links based on the context it is used
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0Links) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ClusterInterfacesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0Controller Controller information
//
// swagger:model NodeResponseRecordsItems0Controller
type NodeResponseRecordsItems0Controller struct {

	// Type of the system board. This is defined by vendor.
	// Example: System Board XXVIII
	// Read Only: true
	Board string `json:"board,omitempty"`

	// cpu
	CPU *NodeResponseRecordsItems0ControllerCPU `json:"cpu,omitempty"`

	// failed fan
	FailedFan *NodeResponseRecordsItems0ControllerFailedFan `json:"failed_fan,omitempty"`

	// failed power supply
	FailedPowerSupply *NodeResponseRecordsItems0ControllerFailedPowerSupply `json:"failed_power_supply,omitempty"`

	// A list of Flash-Cache devices. Only returned when requested by name.
	// Read Only: true
	FlashCache []*NodeResponseRecordsItems0ControllerFlashCacheItems0 `json:"flash_cache,omitempty"`

	// List of FRUs on the node. Only returned when requested by name.
	Frus []*NodeResponseRecordsItems0ControllerFrusItems0 `json:"frus,omitempty"`

	// Memory available on the node, in bytes.
	// Example: 1024000000
	// Read Only: true
	MemorySize int64 `json:"memory_size,omitempty"`

	// Specifies whether the hardware is currently operating outside of its recommended temperature range. The hardware shuts down if the temperature exceeds critical thresholds.
	// Read Only: true
	// Enum: [over normal]
	OverTemperature string `json:"over_temperature,omitempty"`
}

// Validate validates this node response records items0 controller
func (m *NodeResponseRecordsItems0Controller) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCPU(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailedFan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailedPowerSupply(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlashCache(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverTemperature(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Controller) validateCPU(formats strfmt.Registry) error {
	if swag.IsZero(m.CPU) { // not required
		return nil
	}

	if m.CPU != nil {
		if err := m.CPU.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "cpu")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0Controller) validateFailedFan(formats strfmt.Registry) error {
	if swag.IsZero(m.FailedFan) { // not required
		return nil
	}

	if m.FailedFan != nil {
		if err := m.FailedFan.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_fan")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0Controller) validateFailedPowerSupply(formats strfmt.Registry) error {
	if swag.IsZero(m.FailedPowerSupply) { // not required
		return nil
	}

	if m.FailedPowerSupply != nil {
		if err := m.FailedPowerSupply.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_power_supply")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0Controller) validateFlashCache(formats strfmt.Registry) error {
	if swag.IsZero(m.FlashCache) { // not required
		return nil
	}

	for i := 0; i < len(m.FlashCache); i++ {
		if swag.IsZero(m.FlashCache[i]) { // not required
			continue
		}

		if m.FlashCache[i] != nil {
			if err := m.FlashCache[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "flash_cache" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Controller) validateFrus(formats strfmt.Registry) error {
	if swag.IsZero(m.Frus) { // not required
		return nil
	}

	for i := 0; i < len(m.Frus); i++ {
		if swag.IsZero(m.Frus[i]) { // not required
			continue
		}

		if m.Frus[i] != nil {
			if err := m.Frus[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "frus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var nodeResponseRecordsItems0ControllerTypeOverTemperaturePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["over","normal"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ControllerTypeOverTemperaturePropEnum = append(nodeResponseRecordsItems0ControllerTypeOverTemperaturePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Controller
	// NodeResponseRecordsItems0Controller
	// over_temperature
	// OverTemperature
	// over
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerOverTemperatureOver captures enum value "over"
	NodeResponseRecordsItems0ControllerOverTemperatureOver string = "over"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Controller
	// NodeResponseRecordsItems0Controller
	// over_temperature
	// OverTemperature
	// normal
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerOverTemperatureNormal captures enum value "normal"
	NodeResponseRecordsItems0ControllerOverTemperatureNormal string = "normal"
)

// prop value enum
func (m *NodeResponseRecordsItems0Controller) validateOverTemperatureEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ControllerTypeOverTemperaturePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0Controller) validateOverTemperature(formats strfmt.Registry) error {
	if swag.IsZero(m.OverTemperature) { // not required
		return nil
	}

	// value enum
	if err := m.validateOverTemperatureEnum("controller"+"."+"over_temperature", "body", m.OverTemperature); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 controller based on the context it is used
func (m *NodeResponseRecordsItems0Controller) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBoard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCPU(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailedFan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailedPowerSupply(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlashCache(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFrus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMemorySize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOverTemperature(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Controller) contextValidateBoard(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"board", "body", string(m.Board)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Controller) contextValidateCPU(ctx context.Context, formats strfmt.Registry) error {

	if m.CPU != nil {
		if err := m.CPU.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "cpu")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0Controller) contextValidateFailedFan(ctx context.Context, formats strfmt.Registry) error {

	if m.FailedFan != nil {
		if err := m.FailedFan.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_fan")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0Controller) contextValidateFailedPowerSupply(ctx context.Context, formats strfmt.Registry) error {

	if m.FailedPowerSupply != nil {
		if err := m.FailedPowerSupply.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_power_supply")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0Controller) contextValidateFlashCache(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"flash_cache", "body", []*NodeResponseRecordsItems0ControllerFlashCacheItems0(m.FlashCache)); err != nil {
		return err
	}

	for i := 0; i < len(m.FlashCache); i++ {

		if m.FlashCache[i] != nil {
			if err := m.FlashCache[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "flash_cache" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Controller) contextValidateFrus(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Frus); i++ {

		if m.Frus[i] != nil {
			if err := m.Frus[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "frus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Controller) contextValidateMemorySize(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"memory_size", "body", int64(m.MemorySize)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Controller) contextValidateOverTemperature(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"over_temperature", "body", string(m.OverTemperature)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Controller) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Controller) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0Controller
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ControllerCPU CPU information.
//
// swagger:model NodeResponseRecordsItems0ControllerCPU
type NodeResponseRecordsItems0ControllerCPU struct {

	// Number of CPUs on the node.
	// Example: 20
	// Read Only: true
	Count int64 `json:"count,omitempty"`

	// Firmware release number. Defined by the CPU manufacturer.
	// Read Only: true
	FirmwareRelease string `json:"firmware_release,omitempty"`

	// CPU type on the node.
	// Read Only: true
	Processor string `json:"processor,omitempty"`
}

// Validate validates this node response records items0 controller CPU
func (m *NodeResponseRecordsItems0ControllerCPU) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this node response records items0 controller CPU based on the context it is used
func (m *NodeResponseRecordsItems0ControllerCPU) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFirmwareRelease(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProcessor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerCPU) contextValidateCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"cpu"+"."+"count", "body", int64(m.Count)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerCPU) contextValidateFirmwareRelease(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"cpu"+"."+"firmware_release", "body", string(m.FirmwareRelease)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerCPU) contextValidateProcessor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"cpu"+"."+"processor", "body", string(m.Processor)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerCPU) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerCPU) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ControllerCPU
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ControllerFailedFan node response records items0 controller failed fan
//
// swagger:model NodeResponseRecordsItems0ControllerFailedFan
type NodeResponseRecordsItems0ControllerFailedFan struct {

	// Specifies a count of the number of chassis fans that are not operating within the recommended RPM range.
	// Example: 1
	// Read Only: true
	Count int64 `json:"count,omitempty"`

	// message
	Message *NodeResponseRecordsItems0ControllerFailedFanMessage `json:"message,omitempty"`
}

// Validate validates this node response records items0 controller failed fan
func (m *NodeResponseRecordsItems0ControllerFailedFan) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMessage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFailedFan) validateMessage(formats strfmt.Registry) error {
	if swag.IsZero(m.Message) { // not required
		return nil
	}

	if m.Message != nil {
		if err := m.Message.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_fan" + "." + "message")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 controller failed fan based on the context it is used
func (m *NodeResponseRecordsItems0ControllerFailedFan) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFailedFan) contextValidateCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"failed_fan"+"."+"count", "body", int64(m.Count)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFailedFan) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if m.Message != nil {
		if err := m.Message.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_fan" + "." + "message")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFailedFan) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFailedFan) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ControllerFailedFan
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ControllerFailedFanMessage node response records items0 controller failed fan message
//
// swagger:model NodeResponseRecordsItems0ControllerFailedFanMessage
type NodeResponseRecordsItems0ControllerFailedFanMessage struct {

	// Error code describing the current condition of chassis fans.
	// Example: 111411207
	// Read Only: true
	Code string `json:"code,omitempty"`

	// Message describing the current condition of chassis fans. It is only of use when `failed_fan.count` is not zero.
	// Example: There are no failed fans.
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this node response records items0 controller failed fan message
func (m *NodeResponseRecordsItems0ControllerFailedFanMessage) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this node response records items0 controller failed fan message based on the context it is used
func (m *NodeResponseRecordsItems0ControllerFailedFanMessage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFailedFanMessage) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"failed_fan"+"."+"message"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFailedFanMessage) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"failed_fan"+"."+"message"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFailedFanMessage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFailedFanMessage) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ControllerFailedFanMessage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ControllerFailedPowerSupply node response records items0 controller failed power supply
//
// swagger:model NodeResponseRecordsItems0ControllerFailedPowerSupply
type NodeResponseRecordsItems0ControllerFailedPowerSupply struct {

	// Number of failed power supply units.
	// Example: 1
	// Read Only: true
	Count int64 `json:"count,omitempty"`

	// message
	Message *NodeResponseRecordsItems0ControllerFailedPowerSupplyMessage `json:"message,omitempty"`
}

// Validate validates this node response records items0 controller failed power supply
func (m *NodeResponseRecordsItems0ControllerFailedPowerSupply) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMessage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFailedPowerSupply) validateMessage(formats strfmt.Registry) error {
	if swag.IsZero(m.Message) { // not required
		return nil
	}

	if m.Message != nil {
		if err := m.Message.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_power_supply" + "." + "message")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 controller failed power supply based on the context it is used
func (m *NodeResponseRecordsItems0ControllerFailedPowerSupply) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFailedPowerSupply) contextValidateCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"failed_power_supply"+"."+"count", "body", int64(m.Count)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFailedPowerSupply) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if m.Message != nil {
		if err := m.Message.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_power_supply" + "." + "message")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFailedPowerSupply) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFailedPowerSupply) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ControllerFailedPowerSupply
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ControllerFailedPowerSupplyMessage node response records items0 controller failed power supply message
//
// swagger:model NodeResponseRecordsItems0ControllerFailedPowerSupplyMessage
type NodeResponseRecordsItems0ControllerFailedPowerSupplyMessage struct {

	// Error code describing the current condition of power supply.
	// Example: 111411208
	// Read Only: true
	Code string `json:"code,omitempty"`

	// Message describing the state of any power supplies that are currently degraded. It is only of use when `failed_power_supply.count` is not zero.
	// Example: There are no failed power supplies.
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this node response records items0 controller failed power supply message
func (m *NodeResponseRecordsItems0ControllerFailedPowerSupplyMessage) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this node response records items0 controller failed power supply message based on the context it is used
func (m *NodeResponseRecordsItems0ControllerFailedPowerSupplyMessage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFailedPowerSupplyMessage) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"failed_power_supply"+"."+"message"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFailedPowerSupplyMessage) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"failed_power_supply"+"."+"message"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFailedPowerSupplyMessage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFailedPowerSupplyMessage) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ControllerFailedPowerSupplyMessage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ControllerFlashCacheItems0 node response records items0 controller flash cache items0
//
// swagger:model NodeResponseRecordsItems0ControllerFlashCacheItems0
type NodeResponseRecordsItems0ControllerFlashCacheItems0 struct {

	// Size in bytes
	// Example: 1024000000000
	// Read Only: true
	Capacity int64 `json:"capacity,omitempty"`

	// device id
	// Example: 0
	// Read Only: true
	DeviceID int64 `json:"device_id,omitempty"`

	// firmware file
	// Example: X9170_O000Z6300NVM
	// Read Only: true
	FirmwareFile string `json:"firmware_file,omitempty"`

	// firmware version
	// Example: NA05
	// Read Only: true
	FirmwareVersion string `json:"firmware_version,omitempty"`

	// hardware revision
	// Example: A1
	// Read Only: true
	HardwareRevision string `json:"hardware_revision,omitempty"`

	// model
	// Example: X1970A
	// Read Only: true
	Model string `json:"model,omitempty"`

	// part number
	// Example: 119-00207
	// Read Only: true
	PartNumber string `json:"part_number,omitempty"`

	// serial number
	// Example: A22P5061550000187
	// Read Only: true
	SerialNumber string `json:"serial_number,omitempty"`

	// slot
	// Example: 6-1
	// Read Only: true
	Slot string `json:"slot,omitempty"`

	// state
	// Read Only: true
	// Enum: [ok erasing erased failed removed]
	State string `json:"state,omitempty"`
}

// Validate validates this node response records items0 controller flash cache items0
func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0ControllerFlashCacheItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","erasing","erased","failed","removed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ControllerFlashCacheItems0TypeStatePropEnum = append(nodeResponseRecordsItems0ControllerFlashCacheItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// state
	// State
	// ok
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0StateOk captures enum value "ok"
	NodeResponseRecordsItems0ControllerFlashCacheItems0StateOk string = "ok"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// state
	// State
	// erasing
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0StateErasing captures enum value "erasing"
	NodeResponseRecordsItems0ControllerFlashCacheItems0StateErasing string = "erasing"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// state
	// State
	// erased
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0StateErased captures enum value "erased"
	NodeResponseRecordsItems0ControllerFlashCacheItems0StateErased string = "erased"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// state
	// State
	// failed
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0StateFailed captures enum value "failed"
	NodeResponseRecordsItems0ControllerFlashCacheItems0StateFailed string = "failed"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// state
	// State
	// removed
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0StateRemoved captures enum value "removed"
	NodeResponseRecordsItems0ControllerFlashCacheItems0StateRemoved string = "removed"
)

// prop value enum
func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ControllerFlashCacheItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 controller flash cache items0 based on the context it is used
func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCapacity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDeviceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFirmwareFile(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFirmwareVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHardwareRevision(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSlot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateCapacity(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "capacity", "body", int64(m.Capacity)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateDeviceID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "device_id", "body", int64(m.DeviceID)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateFirmwareFile(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "firmware_file", "body", string(m.FirmwareFile)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateFirmwareVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "firmware_version", "body", string(m.FirmwareVersion)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateHardwareRevision(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "hardware_revision", "body", string(m.HardwareRevision)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateModel(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "model", "body", string(m.Model)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidatePartNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "part_number", "body", string(m.PartNumber)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serial_number", "body", string(m.SerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateSlot(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "slot", "body", string(m.Slot)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ControllerFlashCacheItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ControllerFrusItems0 node response records items0 controller frus items0
//
// swagger:model NodeResponseRecordsItems0ControllerFrusItems0
type NodeResponseRecordsItems0ControllerFrusItems0 struct {

	// id
	// Read Only: true
	ID string `json:"id,omitempty"`

	// state
	// Read Only: true
	// Enum: [ok error]
	State string `json:"state,omitempty"`

	// type
	// Read Only: true
	// Enum: [fan psu pcie disk nvs dimm controller]
	Type string `json:"type,omitempty"`
}

// Validate validates this node response records items0 controller frus items0
func (m *NodeResponseRecordsItems0ControllerFrusItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0ControllerFrusItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ControllerFrusItems0TypeStatePropEnum = append(nodeResponseRecordsItems0ControllerFrusItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// state
	// State
	// ok
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0StateOk captures enum value "ok"
	NodeResponseRecordsItems0ControllerFrusItems0StateOk string = "ok"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// state
	// State
	// error
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0StateError captures enum value "error"
	NodeResponseRecordsItems0ControllerFrusItems0StateError string = "error"
)

// prop value enum
func (m *NodeResponseRecordsItems0ControllerFrusItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ControllerFrusItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFrusItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var nodeResponseRecordsItems0ControllerFrusItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fan","psu","pcie","disk","nvs","dimm","controller"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ControllerFrusItems0TypeTypePropEnum = append(nodeResponseRecordsItems0ControllerFrusItems0TypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// type
	// Type
	// fan
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0TypeFan captures enum value "fan"
	NodeResponseRecordsItems0ControllerFrusItems0TypeFan string = "fan"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// type
	// Type
	// psu
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0TypePsu captures enum value "psu"
	NodeResponseRecordsItems0ControllerFrusItems0TypePsu string = "psu"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// type
	// Type
	// pcie
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0TypePcie captures enum value "pcie"
	NodeResponseRecordsItems0ControllerFrusItems0TypePcie string = "pcie"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// type
	// Type
	// disk
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0TypeDisk captures enum value "disk"
	NodeResponseRecordsItems0ControllerFrusItems0TypeDisk string = "disk"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// type
	// Type
	// nvs
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0TypeNvs captures enum value "nvs"
	NodeResponseRecordsItems0ControllerFrusItems0TypeNvs string = "nvs"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// type
	// Type
	// dimm
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0TypeDimm captures enum value "dimm"
	NodeResponseRecordsItems0ControllerFrusItems0TypeDimm string = "dimm"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// type
	// Type
	// controller
	// END DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0TypeController captures enum value "controller"
	NodeResponseRecordsItems0ControllerFrusItems0TypeController string = "controller"
)

// prop value enum
func (m *NodeResponseRecordsItems0ControllerFrusItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ControllerFrusItems0TypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFrusItems0) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 controller frus items0 based on the context it is used
func (m *NodeResponseRecordsItems0ControllerFrusItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFrusItems0) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFrusItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFrusItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(m.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFrusItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFrusItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ControllerFrusItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ExternalCache Cache used for buffer management.
//
// swagger:model NodeResponseRecordsItems0ExternalCache
type NodeResponseRecordsItems0ExternalCache struct {

	// Indicates whether the external cache is enabled.
	// Example: true
	IsEnabled bool `json:"is_enabled,omitempty"`

	// Indicates whether HyA caching is enabled.
	// Example: true
	IsHyaEnabled bool `json:"is_hya_enabled,omitempty"`

	// Indicates whether rewarm is enabled.
	// Example: true
	IsRewarmEnabled bool `json:"is_rewarm_enabled,omitempty"`

	// PCS size in gigabytes.
	PcsSize int64 `json:"pcs_size,omitempty"`
}

// Validate validates this node response records items0 external cache
func (m *NodeResponseRecordsItems0ExternalCache) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this node response records items0 external cache based on context it is used
func (m *NodeResponseRecordsItems0ExternalCache) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ExternalCache) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ExternalCache) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ExternalCache
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0Ha node response records items0 ha
//
// swagger:model NodeResponseRecordsItems0Ha
type NodeResponseRecordsItems0Ha struct {

	// Specifies whether giveback is automatically initiated when the node that owns the storage is ready.
	// Read Only: true
	AutoGiveback *bool `json:"auto_giveback,omitempty"`

	// Specifies whether or not storage failover is enabled.
	// Read Only: true
	Enabled *bool `json:"enabled,omitempty"`

	// giveback
	Giveback *NodeResponseRecordsItems0HaGiveback `json:"giveback,omitempty"`

	// interconnect
	Interconnect *NodeResponseRecordsItems0HaInterconnect `json:"interconnect,omitempty"`

	// Nodes in this node's High Availability (HA) group.
	// Read Only: true
	Partners []*NodeResponseRecordsItems0HaPartnersItems0 `json:"partners,omitempty"`

	// ports
	// Read Only: true
	Ports []*NodeResponseRecordsItems0HaPortsItems0 `json:"ports,omitempty"`

	// takeover
	Takeover *NodeResponseRecordsItems0HaTakeover `json:"takeover,omitempty"`
}

// Validate validates this node response records items0 ha
func (m *NodeResponseRecordsItems0Ha) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGiveback(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterconnect(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartners(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTakeover(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Ha) validateGiveback(formats strfmt.Registry) error {
	if swag.IsZero(m.Giveback) { // not required
		return nil
	}

	if m.Giveback != nil {
		if err := m.Giveback.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) validateInterconnect(formats strfmt.Registry) error {
	if swag.IsZero(m.Interconnect) { // not required
		return nil
	}

	if m.Interconnect != nil {
		if err := m.Interconnect.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "interconnect")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) validatePartners(formats strfmt.Registry) error {
	if swag.IsZero(m.Partners) { // not required
		return nil
	}

	for i := 0; i < len(m.Partners); i++ {
		if swag.IsZero(m.Partners[i]) { // not required
			continue
		}

		if m.Partners[i] != nil {
			if err := m.Partners[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "partners" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) validatePorts(formats strfmt.Registry) error {
	if swag.IsZero(m.Ports) { // not required
		return nil
	}

	for i := 0; i < len(m.Ports); i++ {
		if swag.IsZero(m.Ports[i]) { // not required
			continue
		}

		if m.Ports[i] != nil {
			if err := m.Ports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) validateTakeover(formats strfmt.Registry) error {
	if swag.IsZero(m.Takeover) { // not required
		return nil
	}

	if m.Takeover != nil {
		if err := m.Takeover.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 ha based on the context it is used
func (m *NodeResponseRecordsItems0Ha) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAutoGiveback(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGiveback(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInterconnect(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartners(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePorts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTakeover(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Ha) contextValidateAutoGiveback(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"auto_giveback", "body", m.AutoGiveback); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) contextValidateEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) contextValidateGiveback(ctx context.Context, formats strfmt.Registry) error {

	if m.Giveback != nil {
		if err := m.Giveback.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) contextValidateInterconnect(ctx context.Context, formats strfmt.Registry) error {

	if m.Interconnect != nil {
		if err := m.Interconnect.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "interconnect")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) contextValidatePartners(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"partners", "body", []*NodeResponseRecordsItems0HaPartnersItems0(m.Partners)); err != nil {
		return err
	}

	for i := 0; i < len(m.Partners); i++ {

		if m.Partners[i] != nil {
			if err := m.Partners[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "partners" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) contextValidatePorts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"ports", "body", []*NodeResponseRecordsItems0HaPortsItems0(m.Ports)); err != nil {
		return err
	}

	for i := 0; i < len(m.Ports); i++ {

		if m.Ports[i] != nil {
			if err := m.Ports[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) contextValidateTakeover(ctx context.Context, formats strfmt.Registry) error {

	if m.Takeover != nil {
		if err := m.Takeover.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Ha) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Ha) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0Ha
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaGiveback Represents the state of the node that is giving storage back to its HA partner.
//
// swagger:model NodeResponseRecordsItems0HaGiveback
type NodeResponseRecordsItems0HaGiveback struct {

	// failure
	Failure *NodeResponseRecordsItems0HaGivebackFailure `json:"failure,omitempty"`

	// state
	// Example: failed
	// Enum: [nothing_to_giveback not_attempted in_progress failed]
	State string `json:"state,omitempty"`

	// Giveback status of each aggregate.
	// Read Only: true
	Status []*NodeResponseRecordsItems0HaGivebackStatusItems0 `json:"status,omitempty"`
}

// Validate validates this node response records items0 ha giveback
func (m *NodeResponseRecordsItems0HaGiveback) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailure(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGiveback) validateFailure(formats strfmt.Registry) error {
	if swag.IsZero(m.Failure) { // not required
		return nil
	}

	if m.Failure != nil {
		if err := m.Failure.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

var nodeResponseRecordsItems0HaGivebackTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["nothing_to_giveback","not_attempted","in_progress","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0HaGivebackTypeStatePropEnum = append(nodeResponseRecordsItems0HaGivebackTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGiveback
	// NodeResponseRecordsItems0HaGiveback
	// state
	// State
	// nothing_to_giveback
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStateNothingToGiveback captures enum value "nothing_to_giveback"
	NodeResponseRecordsItems0HaGivebackStateNothingToGiveback string = "nothing_to_giveback"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGiveback
	// NodeResponseRecordsItems0HaGiveback
	// state
	// State
	// not_attempted
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStateNotAttempted captures enum value "not_attempted"
	NodeResponseRecordsItems0HaGivebackStateNotAttempted string = "not_attempted"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGiveback
	// NodeResponseRecordsItems0HaGiveback
	// state
	// State
	// in_progress
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStateInProgress captures enum value "in_progress"
	NodeResponseRecordsItems0HaGivebackStateInProgress string = "in_progress"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGiveback
	// NodeResponseRecordsItems0HaGiveback
	// state
	// State
	// failed
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStateFailed captures enum value "failed"
	NodeResponseRecordsItems0HaGivebackStateFailed string = "failed"
)

// prop value enum
func (m *NodeResponseRecordsItems0HaGiveback) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0HaGivebackTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGiveback) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("ha"+"."+"giveback"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0HaGiveback) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	for i := 0; i < len(m.Status); i++ {
		if swag.IsZero(m.Status[i]) { // not required
			continue
		}

		if m.Status[i] != nil {
			if err := m.Status[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "giveback" + "." + "status" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this node response records items0 ha giveback based on the context it is used
func (m *NodeResponseRecordsItems0HaGiveback) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFailure(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGiveback) contextValidateFailure(ctx context.Context, formats strfmt.Registry) error {

	if m.Failure != nil {
		if err := m.Failure.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0HaGiveback) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"giveback"+"."+"status", "body", []*NodeResponseRecordsItems0HaGivebackStatusItems0(m.Status)); err != nil {
		return err
	}

	for i := 0; i < len(m.Status); i++ {

		if m.Status[i] != nil {
			if err := m.Status[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "giveback" + "." + "status" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGiveback) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGiveback) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaGiveback
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaGivebackFailure Indicates the failure code and message.
//
// swagger:model NodeResponseRecordsItems0HaGivebackFailure
type NodeResponseRecordsItems0HaGivebackFailure struct {

	// Message code
	// Example: 852126
	Code int64 `json:"code,omitempty"`

	// Detailed message based on the state.
	// Example: Failed to initiate giveback. Run the \"storage failover show-giveback\" command for more information.
	Message string `json:"message,omitempty"`
}

// Validate validates this node response records items0 ha giveback failure
func (m *NodeResponseRecordsItems0HaGivebackFailure) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this node response records items0 ha giveback failure based on the context it is used
func (m *NodeResponseRecordsItems0HaGivebackFailure) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGivebackFailure) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGivebackFailure) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaGivebackFailure
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaGivebackStatusItems0 node response records items0 ha giveback status items0
//
// swagger:model NodeResponseRecordsItems0HaGivebackStatusItems0
type NodeResponseRecordsItems0HaGivebackStatusItems0 struct {

	// aggregate
	Aggregate *NodeResponseRecordsItems0HaGivebackStatusItems0Aggregate `json:"aggregate,omitempty"`

	// error
	Error *NodeResponseRecordsItems0HaGivebackStatusItems0Error `json:"error,omitempty"`

	// Giveback state of the aggregate. <br/>
	// Possible values include no aggregates to giveback(nothing_to_giveback), failed to disable background disk firmware update(BDFU) on source node(failed_bdfu_source), <br/>
	// giveback delayed as disk firmware update is in progress on source node(delayed_bdfu_source), performing veto checks(running_checks). <br/>
	//
	// Enum: [done failed in_progress not_started nothing_to_giveback failed_bdfu_source failed_bdfu_dest delayed_bdfu_source delayed_bdfu_dest running_checks]
	State string `json:"state,omitempty"`
}

// Validate validates this node response records items0 ha giveback status items0
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAggregate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGivebackStatusItems0) validateAggregate(formats strfmt.Registry) error {
	if swag.IsZero(m.Aggregate) { // not required
		return nil
	}

	if m.Aggregate != nil {
		if err := m.Aggregate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0HaGivebackStatusItems0) validateError(formats strfmt.Registry) error {
	if swag.IsZero(m.Error) { // not required
		return nil
	}

	if m.Error != nil {
		if err := m.Error.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

var nodeResponseRecordsItems0HaGivebackStatusItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["done","failed","in_progress","not_started","nothing_to_giveback","failed_bdfu_source","failed_bdfu_dest","delayed_bdfu_source","delayed_bdfu_dest","running_checks"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0HaGivebackStatusItems0TypeStatePropEnum = append(nodeResponseRecordsItems0HaGivebackStatusItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// state
	// State
	// done
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0StateDone captures enum value "done"
	NodeResponseRecordsItems0HaGivebackStatusItems0StateDone string = "done"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// state
	// State
	// failed
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0StateFailed captures enum value "failed"
	NodeResponseRecordsItems0HaGivebackStatusItems0StateFailed string = "failed"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// state
	// State
	// in_progress
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0StateInProgress captures enum value "in_progress"
	NodeResponseRecordsItems0HaGivebackStatusItems0StateInProgress string = "in_progress"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// state
	// State
	// not_started
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0StateNotStarted captures enum value "not_started"
	NodeResponseRecordsItems0HaGivebackStatusItems0StateNotStarted string = "not_started"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// state
	// State
	// nothing_to_giveback
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0StateNothingToGiveback captures enum value "nothing_to_giveback"
	NodeResponseRecordsItems0HaGivebackStatusItems0StateNothingToGiveback string = "nothing_to_giveback"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// state
	// State
	// failed_bdfu_source
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0StateFailedBdfuSource captures enum value "failed_bdfu_source"
	NodeResponseRecordsItems0HaGivebackStatusItems0StateFailedBdfuSource string = "failed_bdfu_source"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// state
	// State
	// failed_bdfu_dest
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0StateFailedBdfuDest captures enum value "failed_bdfu_dest"
	NodeResponseRecordsItems0HaGivebackStatusItems0StateFailedBdfuDest string = "failed_bdfu_dest"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// state
	// State
	// delayed_bdfu_source
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0StateDelayedBdfuSource captures enum value "delayed_bdfu_source"
	NodeResponseRecordsItems0HaGivebackStatusItems0StateDelayedBdfuSource string = "delayed_bdfu_source"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// state
	// State
	// delayed_bdfu_dest
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0StateDelayedBdfuDest captures enum value "delayed_bdfu_dest"
	NodeResponseRecordsItems0HaGivebackStatusItems0StateDelayedBdfuDest string = "delayed_bdfu_dest"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// NodeResponseRecordsItems0HaGivebackStatusItems0
	// state
	// State
	// running_checks
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0StateRunningChecks captures enum value "running_checks"
	NodeResponseRecordsItems0HaGivebackStatusItems0StateRunningChecks string = "running_checks"
)

// prop value enum
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0HaGivebackStatusItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGivebackStatusItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 ha giveback status items0 based on the context it is used
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAggregate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateError(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGivebackStatusItems0) contextValidateAggregate(ctx context.Context, formats strfmt.Registry) error {

	if m.Aggregate != nil {
		if err := m.Aggregate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0HaGivebackStatusItems0) contextValidateError(ctx context.Context, formats strfmt.Registry) error {

	if m.Error != nil {
		if err := m.Error.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaGivebackStatusItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaGivebackStatusItems0Aggregate Aggregate name and UUID.
//
// swagger:model NodeResponseRecordsItems0HaGivebackStatusItems0Aggregate
type NodeResponseRecordsItems0HaGivebackStatusItems0Aggregate struct {

	// links
	Links *NodeResponseRecordsItems0HaGivebackStatusItems0AggregateLinks `json:"_links,omitempty"`

	// name
	// Example: aggr1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this node response records items0 ha giveback status items0 aggregate
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0Aggregate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGivebackStatusItems0Aggregate) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 ha giveback status items0 aggregate based on the context it is used
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0Aggregate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGivebackStatusItems0Aggregate) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0Aggregate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0Aggregate) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaGivebackStatusItems0Aggregate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaGivebackStatusItems0AggregateLinks node response records items0 ha giveback status items0 aggregate links
//
// swagger:model NodeResponseRecordsItems0HaGivebackStatusItems0AggregateLinks
type NodeResponseRecordsItems0HaGivebackStatusItems0AggregateLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this node response records items0 ha giveback status items0 aggregate links
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0AggregateLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGivebackStatusItems0AggregateLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 ha giveback status items0 aggregate links based on the context it is used
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0AggregateLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGivebackStatusItems0AggregateLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0AggregateLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0AggregateLinks) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaGivebackStatusItems0AggregateLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaGivebackStatusItems0Error Indicates the failed aggregate giveback code and message.
//
// swagger:model NodeResponseRecordsItems0HaGivebackStatusItems0Error
type NodeResponseRecordsItems0HaGivebackStatusItems0Error struct {

	// Message code.
	// Example: 852126
	// Read Only: true
	Code string `json:"code,omitempty"`

	// Detailed message based on the state.
	// Read Only: true
	// Enum: [shutdown not_homes_partner not_sfo failed_limbo offline_failed migrating veto communication_err online_timeout online_failed hdd_to_aff_dest]
	Message string `json:"message,omitempty"`
}

// Validate validates this node response records items0 ha giveback status items0 error
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0Error) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMessage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0HaGivebackStatusItems0ErrorTypeMessagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["shutdown","not_homes_partner","not_sfo","failed_limbo","offline_failed","migrating","veto","communication_err","online_timeout","online_failed","hdd_to_aff_dest"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0HaGivebackStatusItems0ErrorTypeMessagePropEnum = append(nodeResponseRecordsItems0HaGivebackStatusItems0ErrorTypeMessagePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// message
	// Message
	// shutdown
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageShutdown captures enum value "shutdown"
	NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageShutdown string = "shutdown"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// message
	// Message
	// not_homes_partner
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageNotHomesPartner captures enum value "not_homes_partner"
	NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageNotHomesPartner string = "not_homes_partner"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// message
	// Message
	// not_sfo
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageNotSfo captures enum value "not_sfo"
	NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageNotSfo string = "not_sfo"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// message
	// Message
	// failed_limbo
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageFailedLimbo captures enum value "failed_limbo"
	NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageFailedLimbo string = "failed_limbo"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// message
	// Message
	// offline_failed
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageOfflineFailed captures enum value "offline_failed"
	NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageOfflineFailed string = "offline_failed"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// message
	// Message
	// migrating
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageMigrating captures enum value "migrating"
	NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageMigrating string = "migrating"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// message
	// Message
	// veto
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageVeto captures enum value "veto"
	NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageVeto string = "veto"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// message
	// Message
	// communication_err
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageCommunicationErr captures enum value "communication_err"
	NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageCommunicationErr string = "communication_err"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// message
	// Message
	// online_timeout
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageOnlineTimeout captures enum value "online_timeout"
	NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageOnlineTimeout string = "online_timeout"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// message
	// Message
	// online_failed
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageOnlineFailed captures enum value "online_failed"
	NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageOnlineFailed string = "online_failed"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// NodeResponseRecordsItems0HaGivebackStatusItems0Error
	// message
	// Message
	// hdd_to_aff_dest
	// END DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageHddToAffDest captures enum value "hdd_to_aff_dest"
	NodeResponseRecordsItems0HaGivebackStatusItems0ErrorMessageHddToAffDest string = "hdd_to_aff_dest"
)

// prop value enum
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0Error) validateMessageEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0HaGivebackStatusItems0ErrorTypeMessagePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGivebackStatusItems0Error) validateMessage(formats strfmt.Registry) error {
	if swag.IsZero(m.Message) { // not required
		return nil
	}

	// value enum
	if err := m.validateMessageEnum("error"+"."+"message", "body", m.Message); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 ha giveback status items0 error based on the context it is used
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0Error) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGivebackStatusItems0Error) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "error"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0HaGivebackStatusItems0Error) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "error"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0Error) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGivebackStatusItems0Error) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaGivebackStatusItems0Error
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaInterconnect node response records items0 ha interconnect
//
// swagger:model NodeResponseRecordsItems0HaInterconnect
type NodeResponseRecordsItems0HaInterconnect struct {

	// HA interconnect device name.
	// Example: MVIA-RDMA
	// Read Only: true
	Adapter string `json:"adapter,omitempty"`

	// Indicates the HA interconnect status.
	// Read Only: true
	// Enum: [down up]
	State string `json:"state,omitempty"`
}

// Validate validates this node response records items0 ha interconnect
func (m *NodeResponseRecordsItems0HaInterconnect) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0HaInterconnectTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["down","up"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0HaInterconnectTypeStatePropEnum = append(nodeResponseRecordsItems0HaInterconnectTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaInterconnect
	// NodeResponseRecordsItems0HaInterconnect
	// state
	// State
	// down
	// END DEBUGGING
	// NodeResponseRecordsItems0HaInterconnectStateDown captures enum value "down"
	NodeResponseRecordsItems0HaInterconnectStateDown string = "down"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaInterconnect
	// NodeResponseRecordsItems0HaInterconnect
	// state
	// State
	// up
	// END DEBUGGING
	// NodeResponseRecordsItems0HaInterconnectStateUp captures enum value "up"
	NodeResponseRecordsItems0HaInterconnectStateUp string = "up"
)

// prop value enum
func (m *NodeResponseRecordsItems0HaInterconnect) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0HaInterconnectTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaInterconnect) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("ha"+"."+"interconnect"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 ha interconnect based on the context it is used
func (m *NodeResponseRecordsItems0HaInterconnect) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAdapter(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaInterconnect) contextValidateAdapter(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"interconnect"+"."+"adapter", "body", string(m.Adapter)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0HaInterconnect) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"interconnect"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaInterconnect) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaInterconnect) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaInterconnect
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaPartnersItems0 node response records items0 ha partners items0
//
// swagger:model NodeResponseRecordsItems0HaPartnersItems0
type NodeResponseRecordsItems0HaPartnersItems0 struct {

	// links
	Links *NodeResponseRecordsItems0HaPartnersItems0Links `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this node response records items0 ha partners items0
func (m *NodeResponseRecordsItems0HaPartnersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaPartnersItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 ha partners items0 based on the context it is used
func (m *NodeResponseRecordsItems0HaPartnersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaPartnersItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaPartnersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaPartnersItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaPartnersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaPartnersItems0Links node response records items0 ha partners items0 links
//
// swagger:model NodeResponseRecordsItems0HaPartnersItems0Links
type NodeResponseRecordsItems0HaPartnersItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this node response records items0 ha partners items0 links
func (m *NodeResponseRecordsItems0HaPartnersItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaPartnersItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 ha partners items0 links based on the context it is used
func (m *NodeResponseRecordsItems0HaPartnersItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaPartnersItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaPartnersItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaPartnersItems0Links) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaPartnersItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaPortsItems0 node response records items0 ha ports items0
//
// swagger:model NodeResponseRecordsItems0HaPortsItems0
type NodeResponseRecordsItems0HaPortsItems0 struct {

	// HA port number
	// Example: 0
	// Read Only: true
	Number int64 `json:"number,omitempty"`

	// HA port state:
	// * <i>down</i> - Logical HA link is down.
	// * <i>initialized</i> - Logical HA link is initialized. The physical link is up, but the subnet manager hasnt started to configure the port.
	// * <i>armed</i> - Logical HA link is armed. The physical link is up and the subnet manager started but did not yet complete configuring the port.
	// * <i>active</i> - Logical HA link is active.
	// * <i>reserved</i> - Logical HA link is active, but the physical link is down.
	//
	// Example: active
	// Read Only: true
	// Enum: [down initialized armed active reserved]
	State string `json:"state,omitempty"`
}

// Validate validates this node response records items0 ha ports items0
func (m *NodeResponseRecordsItems0HaPortsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0HaPortsItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["down","initialized","armed","active","reserved"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0HaPortsItems0TypeStatePropEnum = append(nodeResponseRecordsItems0HaPortsItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0
	// NodeResponseRecordsItems0HaPortsItems0
	// state
	// State
	// down
	// END DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0StateDown captures enum value "down"
	NodeResponseRecordsItems0HaPortsItems0StateDown string = "down"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0
	// NodeResponseRecordsItems0HaPortsItems0
	// state
	// State
	// initialized
	// END DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0StateInitialized captures enum value "initialized"
	NodeResponseRecordsItems0HaPortsItems0StateInitialized string = "initialized"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0
	// NodeResponseRecordsItems0HaPortsItems0
	// state
	// State
	// armed
	// END DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0StateArmed captures enum value "armed"
	NodeResponseRecordsItems0HaPortsItems0StateArmed string = "armed"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0
	// NodeResponseRecordsItems0HaPortsItems0
	// state
	// State
	// active
	// END DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0StateActive captures enum value "active"
	NodeResponseRecordsItems0HaPortsItems0StateActive string = "active"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0
	// NodeResponseRecordsItems0HaPortsItems0
	// state
	// State
	// reserved
	// END DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0StateReserved captures enum value "reserved"
	NodeResponseRecordsItems0HaPortsItems0StateReserved string = "reserved"
)

// prop value enum
func (m *NodeResponseRecordsItems0HaPortsItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0HaPortsItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaPortsItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 ha ports items0 based on the context it is used
func (m *NodeResponseRecordsItems0HaPortsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaPortsItems0) contextValidateNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "number", "body", int64(m.Number)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0HaPortsItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaPortsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaPortsItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaPortsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaTakeover This represents the state of the node that is taking over storage from its HA partner.
//
// swagger:model NodeResponseRecordsItems0HaTakeover
type NodeResponseRecordsItems0HaTakeover struct {

	// failure
	Failure *NodeResponseRecordsItems0HaTakeoverFailure `json:"failure,omitempty"`

	// state
	// Example: failed
	// Enum: [not_possible not_attempted in_takeover in_progress failed]
	State string `json:"state,omitempty"`
}

// Validate validates this node response records items0 ha takeover
func (m *NodeResponseRecordsItems0HaTakeover) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailure(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaTakeover) validateFailure(formats strfmt.Registry) error {
	if swag.IsZero(m.Failure) { // not required
		return nil
	}

	if m.Failure != nil {
		if err := m.Failure.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

var nodeResponseRecordsItems0HaTakeoverTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["not_possible","not_attempted","in_takeover","in_progress","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0HaTakeoverTypeStatePropEnum = append(nodeResponseRecordsItems0HaTakeoverTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaTakeover
	// NodeResponseRecordsItems0HaTakeover
	// state
	// State
	// not_possible
	// END DEBUGGING
	// NodeResponseRecordsItems0HaTakeoverStateNotPossible captures enum value "not_possible"
	NodeResponseRecordsItems0HaTakeoverStateNotPossible string = "not_possible"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaTakeover
	// NodeResponseRecordsItems0HaTakeover
	// state
	// State
	// not_attempted
	// END DEBUGGING
	// NodeResponseRecordsItems0HaTakeoverStateNotAttempted captures enum value "not_attempted"
	NodeResponseRecordsItems0HaTakeoverStateNotAttempted string = "not_attempted"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaTakeover
	// NodeResponseRecordsItems0HaTakeover
	// state
	// State
	// in_takeover
	// END DEBUGGING
	// NodeResponseRecordsItems0HaTakeoverStateInTakeover captures enum value "in_takeover"
	NodeResponseRecordsItems0HaTakeoverStateInTakeover string = "in_takeover"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaTakeover
	// NodeResponseRecordsItems0HaTakeover
	// state
	// State
	// in_progress
	// END DEBUGGING
	// NodeResponseRecordsItems0HaTakeoverStateInProgress captures enum value "in_progress"
	NodeResponseRecordsItems0HaTakeoverStateInProgress string = "in_progress"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HaTakeover
	// NodeResponseRecordsItems0HaTakeover
	// state
	// State
	// failed
	// END DEBUGGING
	// NodeResponseRecordsItems0HaTakeoverStateFailed captures enum value "failed"
	NodeResponseRecordsItems0HaTakeoverStateFailed string = "failed"
)

// prop value enum
func (m *NodeResponseRecordsItems0HaTakeover) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0HaTakeoverTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaTakeover) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("ha"+"."+"takeover"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 ha takeover based on the context it is used
func (m *NodeResponseRecordsItems0HaTakeover) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFailure(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaTakeover) contextValidateFailure(ctx context.Context, formats strfmt.Registry) error {

	if m.Failure != nil {
		if err := m.Failure.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaTakeover) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaTakeover) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaTakeover
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaTakeoverFailure Indicates the failure code and message.
//
// swagger:model NodeResponseRecordsItems0HaTakeoverFailure
type NodeResponseRecordsItems0HaTakeoverFailure struct {

	// Message code
	// Example: 852130
	Code int64 `json:"code,omitempty"`

	// Detailed message based on the state.
	// Example: Failed to initiate takeover. Run the \"storage failover show-takeover\" command for more information.
	Message string `json:"message,omitempty"`
}

// Validate validates this node response records items0 ha takeover failure
func (m *NodeResponseRecordsItems0HaTakeoverFailure) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this node response records items0 ha takeover failure based on the context it is used
func (m *NodeResponseRecordsItems0HaTakeoverFailure) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaTakeoverFailure) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaTakeoverFailure) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaTakeoverFailure
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HwAssist The hardware assist information.
//
// swagger:model NodeResponseRecordsItems0HwAssist
type NodeResponseRecordsItems0HwAssist struct {

	// status
	Status *NodeResponseRecordsItems0HwAssistStatus `json:"status,omitempty"`
}

// Validate validates this node response records items0 hw assist
func (m *NodeResponseRecordsItems0HwAssist) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HwAssist) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 hw assist based on the context it is used
func (m *NodeResponseRecordsItems0HwAssist) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HwAssist) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HwAssist) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HwAssist) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HwAssist
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HwAssistStatus node response records items0 hw assist status
//
// swagger:model NodeResponseRecordsItems0HwAssistStatus
type NodeResponseRecordsItems0HwAssistStatus struct {

	// Indicates whether hardware assist is enabled on the node.
	Enabled bool `json:"enabled,omitempty"`

	// local
	Local *NodeResponseRecordsItems0HwAssistStatusLocal `json:"local,omitempty"`

	// partner
	Partner *NodeResponseRecordsItems0HwAssistStatusPartner `json:"partner,omitempty"`
}

// Validate validates this node response records items0 hw assist status
func (m *NodeResponseRecordsItems0HwAssistStatus) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLocal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HwAssistStatus) validateLocal(formats strfmt.Registry) error {
	if swag.IsZero(m.Local) { // not required
		return nil
	}

	if m.Local != nil {
		if err := m.Local.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist" + "." + "status" + "." + "local")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0HwAssistStatus) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(m.Partner) { // not required
		return nil
	}

	if m.Partner != nil {
		if err := m.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist" + "." + "status" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 hw assist status based on the context it is used
func (m *NodeResponseRecordsItems0HwAssistStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLocal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HwAssistStatus) contextValidateLocal(ctx context.Context, formats strfmt.Registry) error {

	if m.Local != nil {
		if err := m.Local.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist" + "." + "status" + "." + "local")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0HwAssistStatus) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if m.Partner != nil {
		if err := m.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist" + "." + "status" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HwAssistStatus) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HwAssistStatus) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HwAssistStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HwAssistStatusLocal node response records items0 hw assist status local
//
// swagger:model NodeResponseRecordsItems0HwAssistStatusLocal
type NodeResponseRecordsItems0HwAssistStatusLocal struct {

	// The hardware assist IP address.
	IP string `json:"ip,omitempty"`

	// The hardware assist port.
	Port int64 `json:"port,omitempty"`

	// The hardware assist monitor status.
	// Enum: [active inactive]
	State string `json:"state,omitempty"`
}

// Validate validates this node response records items0 hw assist status local
func (m *NodeResponseRecordsItems0HwAssistStatusLocal) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0HwAssistStatusLocalTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","inactive"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0HwAssistStatusLocalTypeStatePropEnum = append(nodeResponseRecordsItems0HwAssistStatusLocalTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HwAssistStatusLocal
	// NodeResponseRecordsItems0HwAssistStatusLocal
	// state
	// State
	// active
	// END DEBUGGING
	// NodeResponseRecordsItems0HwAssistStatusLocalStateActive captures enum value "active"
	NodeResponseRecordsItems0HwAssistStatusLocalStateActive string = "active"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HwAssistStatusLocal
	// NodeResponseRecordsItems0HwAssistStatusLocal
	// state
	// State
	// inactive
	// END DEBUGGING
	// NodeResponseRecordsItems0HwAssistStatusLocalStateInactive captures enum value "inactive"
	NodeResponseRecordsItems0HwAssistStatusLocalStateInactive string = "inactive"
)

// prop value enum
func (m *NodeResponseRecordsItems0HwAssistStatusLocal) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0HwAssistStatusLocalTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0HwAssistStatusLocal) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("hw_assist"+"."+"status"+"."+"local"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this node response records items0 hw assist status local based on context it is used
func (m *NodeResponseRecordsItems0HwAssistStatusLocal) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HwAssistStatusLocal) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HwAssistStatusLocal) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HwAssistStatusLocal
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HwAssistStatusPartner node response records items0 hw assist status partner
//
// swagger:model NodeResponseRecordsItems0HwAssistStatusPartner
type NodeResponseRecordsItems0HwAssistStatusPartner struct {

	// The hardware assist IP address.
	IP string `json:"ip,omitempty"`

	// The hardware assist port.
	Port int64 `json:"port,omitempty"`

	// The hardware assist monitor status.
	// Enum: [active inactive]
	State string `json:"state,omitempty"`
}

// Validate validates this node response records items0 hw assist status partner
func (m *NodeResponseRecordsItems0HwAssistStatusPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0HwAssistStatusPartnerTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","inactive"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0HwAssistStatusPartnerTypeStatePropEnum = append(nodeResponseRecordsItems0HwAssistStatusPartnerTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HwAssistStatusPartner
	// NodeResponseRecordsItems0HwAssistStatusPartner
	// state
	// State
	// active
	// END DEBUGGING
	// NodeResponseRecordsItems0HwAssistStatusPartnerStateActive captures enum value "active"
	NodeResponseRecordsItems0HwAssistStatusPartnerStateActive string = "active"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0HwAssistStatusPartner
	// NodeResponseRecordsItems0HwAssistStatusPartner
	// state
	// State
	// inactive
	// END DEBUGGING
	// NodeResponseRecordsItems0HwAssistStatusPartnerStateInactive captures enum value "inactive"
	NodeResponseRecordsItems0HwAssistStatusPartnerStateInactive string = "inactive"
)

// prop value enum
func (m *NodeResponseRecordsItems0HwAssistStatusPartner) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0HwAssistStatusPartnerTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0HwAssistStatusPartner) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("hw_assist"+"."+"status"+"."+"partner"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this node response records items0 hw assist status partner based on context it is used
func (m *NodeResponseRecordsItems0HwAssistStatusPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HwAssistStatusPartner) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HwAssistStatusPartner) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HwAssistStatusPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0Links node response records items0 links
//
// swagger:model NodeResponseRecordsItems0Links
type NodeResponseRecordsItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this node response records items0 links
func (m *NodeResponseRecordsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 links based on the context it is used
func (m *NodeResponseRecordsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Links) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ManagementInterface The management interface of the node to be added. The subnet mask is set based on the management interface of the cluster or the managment interfaces of other nodes.
//
// swagger:model NodeResponseRecordsItems0ManagementInterface
type NodeResponseRecordsItems0ManagementInterface struct {

	// ip
	IP *NodeSetupIP `json:"ip,omitempty"`
}

// Validate validates this node response records items0 management interface
func (m *NodeResponseRecordsItems0ManagementInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterface) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 management interface based on the context it is used
func (m *NodeResponseRecordsItems0ManagementInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterface) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterface) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ManagementInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ManagementInterfacesItems0 Network interface
//
// swagger:model NodeResponseRecordsItems0ManagementInterfacesItems0
type NodeResponseRecordsItems0ManagementInterfacesItems0 struct {

	// links
	Links *NodeResponseRecordsItems0ManagementInterfacesItems0Links `json:"_links,omitempty"`

	// ip
	IP *NodeResponseRecordsItems0ManagementInterfacesItems0IP `json:"ip,omitempty"`

	// The name of the interface. If only the name is provided, the SVM scope
	// must be provided by the object this object is embedded in.
	//
	// Example: lif1
	Name string `json:"name,omitempty"`

	// The UUID that uniquely identifies the interface.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this node response records items0 management interfaces items0
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 management interfaces items0 based on the context it is used
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ManagementInterfacesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ManagementInterfacesItems0IP IP information
//
// swagger:model NodeResponseRecordsItems0ManagementInterfacesItems0IP
type NodeResponseRecordsItems0ManagementInterfacesItems0IP struct {

	// address
	Address IPAddressReadonly `json:"address,omitempty"`
}

// Validate validates this node response records items0 management interfaces items0 IP
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0IP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0IP) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.Address) { // not required
		return nil
	}

	if err := m.Address.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 management interfaces items0 IP based on the context it is used
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0IP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0IP) contextValidateAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Address.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0IP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0IP) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ManagementInterfacesItems0IP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ManagementInterfacesItems0Links node response records items0 management interfaces items0 links
//
// swagger:model NodeResponseRecordsItems0ManagementInterfacesItems0Links
type NodeResponseRecordsItems0ManagementInterfacesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this node response records items0 management interfaces items0 links
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 management interfaces items0 links based on the context it is used
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0Links) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ManagementInterfacesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0Metric CPU performance for the nodes.
//
// swagger:model NodeResponseRecordsItems0Metric
type NodeResponseRecordsItems0Metric struct {

	// links
	Links *NodeResponseRecordsItems0MetricLinks `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Enum: [PT15S PT5M PT30M PT2H P1D]
	Duration string `json:"duration,omitempty"`

	// Average CPU Utilization for the node
	// Example: 13
	ProcessorUtilization int64 `json:"processor_utilization,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "inconsistent_delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this node response records items0 metric
func (m *NodeResponseRecordsItems0Metric) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Metric) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var nodeResponseRecordsItems0MetricTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT5M","PT30M","PT2H","P1D"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0MetricTypeDurationPropEnum = append(nodeResponseRecordsItems0MetricTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricDurationPT15S captures enum value "PT15S"
	NodeResponseRecordsItems0MetricDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricDurationPT5M captures enum value "PT5M"
	NodeResponseRecordsItems0MetricDurationPT5M string = "PT5M"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricDurationPT30M captures enum value "PT30M"
	NodeResponseRecordsItems0MetricDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricDurationPT2H captures enum value "PT2H"
	NodeResponseRecordsItems0MetricDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricDurationP1D captures enum value "P1D"
	NodeResponseRecordsItems0MetricDurationP1D string = "P1D"
)

// prop value enum
func (m *NodeResponseRecordsItems0Metric) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0MetricTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0Metric) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

var nodeResponseRecordsItems0MetricTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0MetricTypeStatusPropEnum = append(nodeResponseRecordsItems0MetricTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// status
	// Status
	// ok
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricStatusOk captures enum value "ok"
	NodeResponseRecordsItems0MetricStatusOk string = "ok"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// status
	// Status
	// error
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricStatusError captures enum value "error"
	NodeResponseRecordsItems0MetricStatusError string = "error"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricStatusPartialNoData captures enum value "partial_no_data"
	NodeResponseRecordsItems0MetricStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricStatusPartialNoUUID captures enum value "partial_no_uuid"
	NodeResponseRecordsItems0MetricStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricStatusPartialNoResponse captures enum value "partial_no_response"
	NodeResponseRecordsItems0MetricStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricStatusPartialOtherError captures enum value "partial_other_error"
	NodeResponseRecordsItems0MetricStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricStatusNegativeDelta captures enum value "negative_delta"
	NodeResponseRecordsItems0MetricStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricStatusBackfilledData captures enum value "backfilled_data"
	NodeResponseRecordsItems0MetricStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	NodeResponseRecordsItems0MetricStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metric
	// NodeResponseRecordsItems0Metric
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// NodeResponseRecordsItems0MetricStatusInconsistentOldData captures enum value "inconsistent_old_data"
	NodeResponseRecordsItems0MetricStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *NodeResponseRecordsItems0Metric) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0MetricTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0Metric) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Metric) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 metric based on the context it is used
func (m *NodeResponseRecordsItems0Metric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Metric) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Metric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Metric) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0Metric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0MetricLinks node response records items0 metric links
//
// swagger:model NodeResponseRecordsItems0MetricLinks
type NodeResponseRecordsItems0MetricLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this node response records items0 metric links
func (m *NodeResponseRecordsItems0MetricLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0MetricLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 metric links based on the context it is used
func (m *NodeResponseRecordsItems0MetricLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0MetricLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0MetricLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0MetricLinks) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0MetricLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0Metrocluster Metrocluster
//
// swagger:model NodeResponseRecordsItems0Metrocluster
type NodeResponseRecordsItems0Metrocluster struct {

	// Indicates whether the MetroCluster over IP platform supports custom VLAN IDs.
	// Read Only: true
	CustomVlanCapable *bool `json:"custom_vlan_capable,omitempty"`

	// MetroCluster over IP ports.
	// Read Only: true
	Ports []*NodeResponseRecordsItems0MetroclusterPortsItems0 `json:"ports,omitempty"`

	// The Metrocluster configuration type
	// Read Only: true
	// Enum: [fc fc_2_node ip]
	Type string `json:"type,omitempty"`
}

// Validate validates this node response records items0 metrocluster
func (m *NodeResponseRecordsItems0Metrocluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Metrocluster) validatePorts(formats strfmt.Registry) error {
	if swag.IsZero(m.Ports) { // not required
		return nil
	}

	for i := 0; i < len(m.Ports); i++ {
		if swag.IsZero(m.Ports[i]) { // not required
			continue
		}

		if m.Ports[i] != nil {
			if err := m.Ports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metrocluster" + "." + "ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var nodeResponseRecordsItems0MetroclusterTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fc","fc_2_node","ip"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0MetroclusterTypeTypePropEnum = append(nodeResponseRecordsItems0MetroclusterTypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metrocluster
	// NodeResponseRecordsItems0Metrocluster
	// type
	// Type
	// fc
	// END DEBUGGING
	// NodeResponseRecordsItems0MetroclusterTypeFc captures enum value "fc"
	NodeResponseRecordsItems0MetroclusterTypeFc string = "fc"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metrocluster
	// NodeResponseRecordsItems0Metrocluster
	// type
	// Type
	// fc_2_node
	// END DEBUGGING
	// NodeResponseRecordsItems0MetroclusterTypeFc2Node captures enum value "fc_2_node"
	NodeResponseRecordsItems0MetroclusterTypeFc2Node string = "fc_2_node"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Metrocluster
	// NodeResponseRecordsItems0Metrocluster
	// type
	// Type
	// ip
	// END DEBUGGING
	// NodeResponseRecordsItems0MetroclusterTypeIP captures enum value "ip"
	NodeResponseRecordsItems0MetroclusterTypeIP string = "ip"
)

// prop value enum
func (m *NodeResponseRecordsItems0Metrocluster) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0MetroclusterTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0Metrocluster) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("metrocluster"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 metrocluster based on the context it is used
func (m *NodeResponseRecordsItems0Metrocluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCustomVlanCapable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePorts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Metrocluster) contextValidateCustomVlanCapable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metrocluster"+"."+"custom_vlan_capable", "body", m.CustomVlanCapable); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Metrocluster) contextValidatePorts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metrocluster"+"."+"ports", "body", []*NodeResponseRecordsItems0MetroclusterPortsItems0(m.Ports)); err != nil {
		return err
	}

	for i := 0; i < len(m.Ports); i++ {

		if m.Ports[i] != nil {
			if err := m.Ports[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metrocluster" + "." + "ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Metrocluster) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metrocluster"+"."+"type", "body", string(m.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Metrocluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Metrocluster) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0Metrocluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0MetroclusterPortsItems0 node response records items0 metrocluster ports items0
//
// swagger:model NodeResponseRecordsItems0MetroclusterPortsItems0
type NodeResponseRecordsItems0MetroclusterPortsItems0 struct {

	// name
	// Example: e1b
	Name string `json:"name,omitempty"`
}

// Validate validates this node response records items0 metrocluster ports items0
func (m *NodeResponseRecordsItems0MetroclusterPortsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this node response records items0 metrocluster ports items0 based on context it is used
func (m *NodeResponseRecordsItems0MetroclusterPortsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0MetroclusterPortsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0MetroclusterPortsItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0MetroclusterPortsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0Nvram node response records items0 nvram
//
// swagger:model NodeResponseRecordsItems0Nvram
type NodeResponseRecordsItems0Nvram struct {

	// Specifies status of the NVRAM battery. Possible values:
	// * <i>battery_ok</i>
	// * <i>battery_partially_discharged</i>
	// * <i>battery_fully_discharged</i>
	// * <i>battery_not_present</i>
	// * <i>battery_near_end_of_life</i>
	// * <i>battery_at_end_of_life</i>
	// * <i>battery_unknown</i>
	// * <i>battery_over_charged</i>
	// * <i>battery_fully_charged</i>
	//
	// Read Only: true
	// Enum: [battery_ok battery_partially_discharged battery_fully_discharged battery_not_present battery_near_end_of_life battery_at_end_of_life battery_unknown battery_over_charged battery_fully_charged]
	BatteryState string `json:"battery_state,omitempty"`

	// Vendor specific NVRAM ID of the node.
	// Read Only: true
	ID int64 `json:"id,omitempty"`
}

// Validate validates this node response records items0 nvram
func (m *NodeResponseRecordsItems0Nvram) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBatteryState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0NvramTypeBatteryStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["battery_ok","battery_partially_discharged","battery_fully_discharged","battery_not_present","battery_near_end_of_life","battery_at_end_of_life","battery_unknown","battery_over_charged","battery_fully_charged"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0NvramTypeBatteryStatePropEnum = append(nodeResponseRecordsItems0NvramTypeBatteryStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Nvram
	// NodeResponseRecordsItems0Nvram
	// battery_state
	// BatteryState
	// battery_ok
	// END DEBUGGING
	// NodeResponseRecordsItems0NvramBatteryStateBatteryOk captures enum value "battery_ok"
	NodeResponseRecordsItems0NvramBatteryStateBatteryOk string = "battery_ok"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Nvram
	// NodeResponseRecordsItems0Nvram
	// battery_state
	// BatteryState
	// battery_partially_discharged
	// END DEBUGGING
	// NodeResponseRecordsItems0NvramBatteryStateBatteryPartiallyDischarged captures enum value "battery_partially_discharged"
	NodeResponseRecordsItems0NvramBatteryStateBatteryPartiallyDischarged string = "battery_partially_discharged"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Nvram
	// NodeResponseRecordsItems0Nvram
	// battery_state
	// BatteryState
	// battery_fully_discharged
	// END DEBUGGING
	// NodeResponseRecordsItems0NvramBatteryStateBatteryFullyDischarged captures enum value "battery_fully_discharged"
	NodeResponseRecordsItems0NvramBatteryStateBatteryFullyDischarged string = "battery_fully_discharged"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Nvram
	// NodeResponseRecordsItems0Nvram
	// battery_state
	// BatteryState
	// battery_not_present
	// END DEBUGGING
	// NodeResponseRecordsItems0NvramBatteryStateBatteryNotPresent captures enum value "battery_not_present"
	NodeResponseRecordsItems0NvramBatteryStateBatteryNotPresent string = "battery_not_present"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Nvram
	// NodeResponseRecordsItems0Nvram
	// battery_state
	// BatteryState
	// battery_near_end_of_life
	// END DEBUGGING
	// NodeResponseRecordsItems0NvramBatteryStateBatteryNearEndOfLife captures enum value "battery_near_end_of_life"
	NodeResponseRecordsItems0NvramBatteryStateBatteryNearEndOfLife string = "battery_near_end_of_life"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Nvram
	// NodeResponseRecordsItems0Nvram
	// battery_state
	// BatteryState
	// battery_at_end_of_life
	// END DEBUGGING
	// NodeResponseRecordsItems0NvramBatteryStateBatteryAtEndOfLife captures enum value "battery_at_end_of_life"
	NodeResponseRecordsItems0NvramBatteryStateBatteryAtEndOfLife string = "battery_at_end_of_life"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Nvram
	// NodeResponseRecordsItems0Nvram
	// battery_state
	// BatteryState
	// battery_unknown
	// END DEBUGGING
	// NodeResponseRecordsItems0NvramBatteryStateBatteryUnknown captures enum value "battery_unknown"
	NodeResponseRecordsItems0NvramBatteryStateBatteryUnknown string = "battery_unknown"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Nvram
	// NodeResponseRecordsItems0Nvram
	// battery_state
	// BatteryState
	// battery_over_charged
	// END DEBUGGING
	// NodeResponseRecordsItems0NvramBatteryStateBatteryOverCharged captures enum value "battery_over_charged"
	NodeResponseRecordsItems0NvramBatteryStateBatteryOverCharged string = "battery_over_charged"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Nvram
	// NodeResponseRecordsItems0Nvram
	// battery_state
	// BatteryState
	// battery_fully_charged
	// END DEBUGGING
	// NodeResponseRecordsItems0NvramBatteryStateBatteryFullyCharged captures enum value "battery_fully_charged"
	NodeResponseRecordsItems0NvramBatteryStateBatteryFullyCharged string = "battery_fully_charged"
)

// prop value enum
func (m *NodeResponseRecordsItems0Nvram) validateBatteryStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0NvramTypeBatteryStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0Nvram) validateBatteryState(formats strfmt.Registry) error {
	if swag.IsZero(m.BatteryState) { // not required
		return nil
	}

	// value enum
	if err := m.validateBatteryStateEnum("nvram"+"."+"battery_state", "body", m.BatteryState); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 nvram based on the context it is used
func (m *NodeResponseRecordsItems0Nvram) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBatteryState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Nvram) contextValidateBatteryState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "nvram"+"."+"battery_state", "body", string(m.BatteryState)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Nvram) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "nvram"+"."+"id", "body", int64(m.ID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Nvram) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Nvram) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0Nvram
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ServiceProcessor node response records items0 service processor
//
// swagger:model NodeResponseRecordsItems0ServiceProcessor
type NodeResponseRecordsItems0ServiceProcessor struct {

	// api service
	APIService *NodeResponseRecordsItems0ServiceProcessorAPIService `json:"api_service,omitempty"`

	// auto config
	AutoConfig *NodeResponseRecordsItems0ServiceProcessorAutoConfig `json:"auto_config,omitempty"`

	// Indicates whether the service processor can be automatically updated from ONTAP.
	AutoupdateEnabled bool `json:"autoupdate_enabled,omitempty"`

	// backup
	Backup *NodeResponseRecordsItems0ServiceProcessorBackup `json:"backup,omitempty"`

	// Set to "true" to use DHCP to configure an IPv4 interface. Do not provide values for address, netmask and gateway when set to "true".
	DhcpEnabled bool `json:"dhcp_enabled,omitempty"`

	// The version of firmware installed.
	// Read Only: true
	FirmwareVersion string `json:"firmware_version,omitempty"`

	// ipv4 interface
	IPV4Interface *NodeResponseRecordsItems0ServiceProcessorIPV4Interface `json:"ipv4_interface,omitempty"`

	// ipv6 interface
	IPV6Interface *NodeResponseRecordsItems0ServiceProcessorIPV6Interface `json:"ipv6_interface,omitempty"`

	// Indicates whether the service processor network is configured.
	// Read Only: true
	IsIPConfigured *bool `json:"is_ip_configured,omitempty"`

	// Provides the "update status" of the last service processor update.
	// Read Only: true
	// Enum: [failed passed]
	LastUpdateState string `json:"last_update_state,omitempty"`

	// link status
	// Read Only: true
	// Enum: [up down disabled unknown]
	LinkStatus string `json:"link_status,omitempty"`

	// mac address
	// Read Only: true
	MacAddress string `json:"mac_address,omitempty"`

	// primary
	Primary *NodeResponseRecordsItems0ServiceProcessorPrimary `json:"primary,omitempty"`

	// ssh info
	SSHInfo *NodeResponseRecordsItems0ServiceProcessorSSHInfo `json:"ssh_info,omitempty"`

	// state
	// Read Only: true
	// Enum: [online offline degraded rebooting unknown updating node_offline sp_daemon_offline]
	State string `json:"state,omitempty"`

	// type
	// Read Only: true
	// Enum: [sp none bmc]
	Type string `json:"type,omitempty"`
}

// Validate validates this node response records items0 service processor
func (m *NodeResponseRecordsItems0ServiceProcessor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAPIService(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAutoConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPV4Interface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPV6Interface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastUpdateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinkStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSSHInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validateAPIService(formats strfmt.Registry) error {
	if swag.IsZero(m.APIService) { // not required
		return nil
	}

	if m.APIService != nil {
		if err := m.APIService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "api_service")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validateAutoConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.AutoConfig) { // not required
		return nil
	}

	if m.AutoConfig != nil {
		if err := m.AutoConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "auto_config")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validateBackup(formats strfmt.Registry) error {
	if swag.IsZero(m.Backup) { // not required
		return nil
	}

	if m.Backup != nil {
		if err := m.Backup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "backup")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validateIPV4Interface(formats strfmt.Registry) error {
	if swag.IsZero(m.IPV4Interface) { // not required
		return nil
	}

	if m.IPV4Interface != nil {
		if err := m.IPV4Interface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv4_interface")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validateIPV6Interface(formats strfmt.Registry) error {
	if swag.IsZero(m.IPV6Interface) { // not required
		return nil
	}

	if m.IPV6Interface != nil {
		if err := m.IPV6Interface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv6_interface")
			}
			return err
		}
	}

	return nil
}

var nodeResponseRecordsItems0ServiceProcessorTypeLastUpdateStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["failed","passed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ServiceProcessorTypeLastUpdateStatePropEnum = append(nodeResponseRecordsItems0ServiceProcessorTypeLastUpdateStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// last_update_state
	// LastUpdateState
	// failed
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorLastUpdateStateFailed captures enum value "failed"
	NodeResponseRecordsItems0ServiceProcessorLastUpdateStateFailed string = "failed"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// last_update_state
	// LastUpdateState
	// passed
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorLastUpdateStatePassed captures enum value "passed"
	NodeResponseRecordsItems0ServiceProcessorLastUpdateStatePassed string = "passed"
)

// prop value enum
func (m *NodeResponseRecordsItems0ServiceProcessor) validateLastUpdateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ServiceProcessorTypeLastUpdateStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validateLastUpdateState(formats strfmt.Registry) error {
	if swag.IsZero(m.LastUpdateState) { // not required
		return nil
	}

	// value enum
	if err := m.validateLastUpdateStateEnum("service_processor"+"."+"last_update_state", "body", m.LastUpdateState); err != nil {
		return err
	}

	return nil
}

var nodeResponseRecordsItems0ServiceProcessorTypeLinkStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["up","down","disabled","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ServiceProcessorTypeLinkStatusPropEnum = append(nodeResponseRecordsItems0ServiceProcessorTypeLinkStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// link_status
	// LinkStatus
	// up
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorLinkStatusUp captures enum value "up"
	NodeResponseRecordsItems0ServiceProcessorLinkStatusUp string = "up"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// link_status
	// LinkStatus
	// down
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorLinkStatusDown captures enum value "down"
	NodeResponseRecordsItems0ServiceProcessorLinkStatusDown string = "down"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// link_status
	// LinkStatus
	// disabled
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorLinkStatusDisabled captures enum value "disabled"
	NodeResponseRecordsItems0ServiceProcessorLinkStatusDisabled string = "disabled"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// link_status
	// LinkStatus
	// unknown
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorLinkStatusUnknown captures enum value "unknown"
	NodeResponseRecordsItems0ServiceProcessorLinkStatusUnknown string = "unknown"
)

// prop value enum
func (m *NodeResponseRecordsItems0ServiceProcessor) validateLinkStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ServiceProcessorTypeLinkStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validateLinkStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.LinkStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateLinkStatusEnum("service_processor"+"."+"link_status", "body", m.LinkStatus); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validatePrimary(formats strfmt.Registry) error {
	if swag.IsZero(m.Primary) { // not required
		return nil
	}

	if m.Primary != nil {
		if err := m.Primary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "primary")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validateSSHInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.SSHInfo) { // not required
		return nil
	}

	if m.SSHInfo != nil {
		if err := m.SSHInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ssh_info")
			}
			return err
		}
	}

	return nil
}

var nodeResponseRecordsItems0ServiceProcessorTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["online","offline","degraded","rebooting","unknown","updating","node_offline","sp_daemon_offline"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ServiceProcessorTypeStatePropEnum = append(nodeResponseRecordsItems0ServiceProcessorTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// online
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateOnline captures enum value "online"
	NodeResponseRecordsItems0ServiceProcessorStateOnline string = "online"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// offline
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateOffline captures enum value "offline"
	NodeResponseRecordsItems0ServiceProcessorStateOffline string = "offline"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// degraded
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateDegraded captures enum value "degraded"
	NodeResponseRecordsItems0ServiceProcessorStateDegraded string = "degraded"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// rebooting
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateRebooting captures enum value "rebooting"
	NodeResponseRecordsItems0ServiceProcessorStateRebooting string = "rebooting"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// unknown
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateUnknown captures enum value "unknown"
	NodeResponseRecordsItems0ServiceProcessorStateUnknown string = "unknown"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// updating
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateUpdating captures enum value "updating"
	NodeResponseRecordsItems0ServiceProcessorStateUpdating string = "updating"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// node_offline
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateNodeOffline captures enum value "node_offline"
	NodeResponseRecordsItems0ServiceProcessorStateNodeOffline string = "node_offline"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// sp_daemon_offline
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateSpDaemonOffline captures enum value "sp_daemon_offline"
	NodeResponseRecordsItems0ServiceProcessorStateSpDaemonOffline string = "sp_daemon_offline"
)

// prop value enum
func (m *NodeResponseRecordsItems0ServiceProcessor) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ServiceProcessorTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("service_processor"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var nodeResponseRecordsItems0ServiceProcessorTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["sp","none","bmc"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ServiceProcessorTypeTypePropEnum = append(nodeResponseRecordsItems0ServiceProcessorTypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// type
	// Type
	// sp
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorTypeSp captures enum value "sp"
	NodeResponseRecordsItems0ServiceProcessorTypeSp string = "sp"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// type
	// Type
	// none
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorTypeNone captures enum value "none"
	NodeResponseRecordsItems0ServiceProcessorTypeNone string = "none"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// type
	// Type
	// bmc
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorTypeBmc captures enum value "bmc"
	NodeResponseRecordsItems0ServiceProcessorTypeBmc string = "bmc"
)

// prop value enum
func (m *NodeResponseRecordsItems0ServiceProcessor) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ServiceProcessorTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("service_processor"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 service processor based on the context it is used
func (m *NodeResponseRecordsItems0ServiceProcessor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAPIService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAutoConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBackup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFirmwareVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPV4Interface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPV6Interface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsIPConfigured(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastUpdateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLinkStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMacAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrimary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSSHInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateAPIService(ctx context.Context, formats strfmt.Registry) error {

	if m.APIService != nil {
		if err := m.APIService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "api_service")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateAutoConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.AutoConfig != nil {
		if err := m.AutoConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "auto_config")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateBackup(ctx context.Context, formats strfmt.Registry) error {

	if m.Backup != nil {
		if err := m.Backup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "backup")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateFirmwareVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"firmware_version", "body", string(m.FirmwareVersion)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateIPV4Interface(ctx context.Context, formats strfmt.Registry) error {

	if m.IPV4Interface != nil {
		if err := m.IPV4Interface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv4_interface")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateIPV6Interface(ctx context.Context, formats strfmt.Registry) error {

	if m.IPV6Interface != nil {
		if err := m.IPV6Interface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv6_interface")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateIsIPConfigured(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"is_ip_configured", "body", m.IsIPConfigured); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateLastUpdateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"last_update_state", "body", string(m.LastUpdateState)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateLinkStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"link_status", "body", string(m.LinkStatus)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateMacAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"mac_address", "body", string(m.MacAddress)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidatePrimary(ctx context.Context, formats strfmt.Registry) error {

	if m.Primary != nil {
		if err := m.Primary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "primary")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateSSHInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.SSHInfo != nil {
		if err := m.SSHInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ssh_info")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"type", "body", string(m.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessor) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ServiceProcessor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ServiceProcessorAPIService Provides the properties of the service processor API service.
//
// swagger:model NodeResponseRecordsItems0ServiceProcessorAPIService
type NodeResponseRecordsItems0ServiceProcessorAPIService struct {

	// Indicates whether the service processor API service is enabled.
	// Read Only: true
	Enabled *bool `json:"enabled,omitempty"`

	// Indicates whether the service processor API service limit access is enabled.
	// Read Only: true
	LimitAccess *bool `json:"limit_access,omitempty"`

	// Indicates the port number of service processor API service.
	// Read Only: true
	Port int64 `json:"port,omitempty"`
}

// Validate validates this node response records items0 service processor API service
func (m *NodeResponseRecordsItems0ServiceProcessorAPIService) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this node response records items0 service processor API service based on the context it is used
func (m *NodeResponseRecordsItems0ServiceProcessorAPIService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLimitAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePort(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorAPIService) contextValidateEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"api_service"+"."+"enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorAPIService) contextValidateLimitAccess(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"api_service"+"."+"limit_access", "body", m.LimitAccess); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorAPIService) contextValidatePort(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"api_service"+"."+"port", "body", int64(m.Port)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorAPIService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorAPIService) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ServiceProcessorAPIService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ServiceProcessorAutoConfig Provides the properties of the service processor auto configuration.
//
// swagger:model NodeResponseRecordsItems0ServiceProcessorAutoConfig
type NodeResponseRecordsItems0ServiceProcessorAutoConfig struct {

	// Indicates the service processor auto configuration IPv4 subnet name. To enable IPv4 auto-config give the subnet name, give the value as null or an empty string "" to disable auto-config.
	// Example: ipv4_mgmt
	IPV4Subnet string `json:"ipv4_subnet,omitempty"`

	// Indicates the service processor auto configuration IPv6 subnet name. To enable IPv6 auto-config give the subnet name, give the value as null or an empty string "" to disable auto-config.
	// Example: ipv6_mgmt
	IPV6Subnet string `json:"ipv6_subnet,omitempty"`
}

// Validate validates this node response records items0 service processor auto config
func (m *NodeResponseRecordsItems0ServiceProcessorAutoConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this node response records items0 service processor auto config based on the context it is used
func (m *NodeResponseRecordsItems0ServiceProcessorAutoConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorAutoConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorAutoConfig) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ServiceProcessorAutoConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ServiceProcessorBackup Provides the properties of the service processor backup partition.
//
// swagger:model NodeResponseRecordsItems0ServiceProcessorBackup
type NodeResponseRecordsItems0ServiceProcessorBackup struct {

	// Indicates whether the service processor is currently booted from the backup partition.
	// Read Only: true
	IsCurrent *bool `json:"is_current,omitempty"`

	// Status of the backup partition.
	// Read Only: true
	// Enum: [installed corrupt updating auto_updating none]
	State string `json:"state,omitempty"`

	// Firmware version of the backup partition.
	// Example: 11.6
	// Read Only: true
	Version string `json:"version,omitempty"`
}

// Validate validates this node response records items0 service processor backup
func (m *NodeResponseRecordsItems0ServiceProcessorBackup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0ServiceProcessorBackupTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["installed","corrupt","updating","auto_updating","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ServiceProcessorBackupTypeStatePropEnum = append(nodeResponseRecordsItems0ServiceProcessorBackupTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorBackup
	// NodeResponseRecordsItems0ServiceProcessorBackup
	// state
	// State
	// installed
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorBackupStateInstalled captures enum value "installed"
	NodeResponseRecordsItems0ServiceProcessorBackupStateInstalled string = "installed"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorBackup
	// NodeResponseRecordsItems0ServiceProcessorBackup
	// state
	// State
	// corrupt
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorBackupStateCorrupt captures enum value "corrupt"
	NodeResponseRecordsItems0ServiceProcessorBackupStateCorrupt string = "corrupt"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorBackup
	// NodeResponseRecordsItems0ServiceProcessorBackup
	// state
	// State
	// updating
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorBackupStateUpdating captures enum value "updating"
	NodeResponseRecordsItems0ServiceProcessorBackupStateUpdating string = "updating"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorBackup
	// NodeResponseRecordsItems0ServiceProcessorBackup
	// state
	// State
	// auto_updating
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorBackupStateAutoUpdating captures enum value "auto_updating"
	NodeResponseRecordsItems0ServiceProcessorBackupStateAutoUpdating string = "auto_updating"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorBackup
	// NodeResponseRecordsItems0ServiceProcessorBackup
	// state
	// State
	// none
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorBackupStateNone captures enum value "none"
	NodeResponseRecordsItems0ServiceProcessorBackupStateNone string = "none"
)

// prop value enum
func (m *NodeResponseRecordsItems0ServiceProcessorBackup) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ServiceProcessorBackupTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorBackup) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("service_processor"+"."+"backup"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 service processor backup based on the context it is used
func (m *NodeResponseRecordsItems0ServiceProcessorBackup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIsCurrent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorBackup) contextValidateIsCurrent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"backup"+"."+"is_current", "body", m.IsCurrent); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorBackup) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"backup"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorBackup) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"backup"+"."+"version", "body", string(m.Version)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorBackup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorBackup) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ServiceProcessorBackup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ServiceProcessorIPV4Interface Object to setup an interface along with its default router.
//
// swagger:model NodeResponseRecordsItems0ServiceProcessorIPV4Interface
type NodeResponseRecordsItems0ServiceProcessorIPV4Interface struct {

	// IPv4 or IPv6 address
	// Example: 10.10.10.7
	Address string `json:"address,omitempty"`

	// The IPv4 or IPv6 address of the default router.
	// Example: 10.1.1.1
	Gateway string `json:"gateway,omitempty"`

	// netmask
	Netmask IPNetmask `json:"netmask,omitempty"`
}

// Validate validates this node response records items0 service processor IP v4 interface
func (m *NodeResponseRecordsItems0ServiceProcessorIPV4Interface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetmask(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorIPV4Interface) validateNetmask(formats strfmt.Registry) error {
	if swag.IsZero(m.Netmask) { // not required
		return nil
	}

	if err := m.Netmask.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("service_processor" + "." + "ipv4_interface" + "." + "netmask")
		}
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 service processor IP v4 interface based on the context it is used
func (m *NodeResponseRecordsItems0ServiceProcessorIPV4Interface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetmask(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorIPV4Interface) contextValidateNetmask(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Netmask.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("service_processor" + "." + "ipv4_interface" + "." + "netmask")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorIPV4Interface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorIPV4Interface) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ServiceProcessorIPV4Interface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ServiceProcessorIPV6Interface Object to setup an interface along with its default router.
//
// swagger:model NodeResponseRecordsItems0ServiceProcessorIPV6Interface
type NodeResponseRecordsItems0ServiceProcessorIPV6Interface struct {

	// IPv6 address
	// Example: fd20:8b1e:b255:5011:10:141:4:97
	Address string `json:"address,omitempty"`

	// The IPv6 address of the default router.
	// Example: fd20:8b1e:b255:5011:10::1
	Gateway string `json:"gateway,omitempty"`

	// The IPv6 netmask/prefix length. The default value is 64 with a valid range of 1 to 127.
	// Example: 64
	Netmask int64 `json:"netmask,omitempty"`
}

// Validate validates this node response records items0 service processor IP v6 interface
func (m *NodeResponseRecordsItems0ServiceProcessorIPV6Interface) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this node response records items0 service processor IP v6 interface based on context it is used
func (m *NodeResponseRecordsItems0ServiceProcessorIPV6Interface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorIPV6Interface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorIPV6Interface) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ServiceProcessorIPV6Interface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ServiceProcessorPrimary Provides the properties of the service processor primary partition.
//
// swagger:model NodeResponseRecordsItems0ServiceProcessorPrimary
type NodeResponseRecordsItems0ServiceProcessorPrimary struct {

	// Indicates whether the service processor is currently booted from the primary partition.
	// Read Only: true
	IsCurrent *bool `json:"is_current,omitempty"`

	// Status of the primary partition.
	// Read Only: true
	// Enum: [installed corrupt updating auto_updating none]
	State string `json:"state,omitempty"`

	// Firmware version of the primary partition.
	// Example: 11.6
	// Read Only: true
	Version string `json:"version,omitempty"`
}

// Validate validates this node response records items0 service processor primary
func (m *NodeResponseRecordsItems0ServiceProcessorPrimary) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0ServiceProcessorPrimaryTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["installed","corrupt","updating","auto_updating","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ServiceProcessorPrimaryTypeStatePropEnum = append(nodeResponseRecordsItems0ServiceProcessorPrimaryTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorPrimary
	// NodeResponseRecordsItems0ServiceProcessorPrimary
	// state
	// State
	// installed
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorPrimaryStateInstalled captures enum value "installed"
	NodeResponseRecordsItems0ServiceProcessorPrimaryStateInstalled string = "installed"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorPrimary
	// NodeResponseRecordsItems0ServiceProcessorPrimary
	// state
	// State
	// corrupt
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorPrimaryStateCorrupt captures enum value "corrupt"
	NodeResponseRecordsItems0ServiceProcessorPrimaryStateCorrupt string = "corrupt"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorPrimary
	// NodeResponseRecordsItems0ServiceProcessorPrimary
	// state
	// State
	// updating
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorPrimaryStateUpdating captures enum value "updating"
	NodeResponseRecordsItems0ServiceProcessorPrimaryStateUpdating string = "updating"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorPrimary
	// NodeResponseRecordsItems0ServiceProcessorPrimary
	// state
	// State
	// auto_updating
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorPrimaryStateAutoUpdating captures enum value "auto_updating"
	NodeResponseRecordsItems0ServiceProcessorPrimaryStateAutoUpdating string = "auto_updating"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorPrimary
	// NodeResponseRecordsItems0ServiceProcessorPrimary
	// state
	// State
	// none
	// END DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorPrimaryStateNone captures enum value "none"
	NodeResponseRecordsItems0ServiceProcessorPrimaryStateNone string = "none"
)

// prop value enum
func (m *NodeResponseRecordsItems0ServiceProcessorPrimary) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ServiceProcessorPrimaryTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorPrimary) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("service_processor"+"."+"primary"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 service processor primary based on the context it is used
func (m *NodeResponseRecordsItems0ServiceProcessorPrimary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIsCurrent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorPrimary) contextValidateIsCurrent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"primary"+"."+"is_current", "body", m.IsCurrent); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorPrimary) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"primary"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorPrimary) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"primary"+"."+"version", "body", string(m.Version)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorPrimary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorPrimary) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ServiceProcessorPrimary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ServiceProcessorSSHInfo Service processor SSH allowed IP address configuration applied across the cluster.
//
// swagger:model NodeResponseRecordsItems0ServiceProcessorSSHInfo
type NodeResponseRecordsItems0ServiceProcessorSSHInfo struct {

	// Allowed IP addresses
	AllowedAddresses []IPAddressAndNetmask `json:"allowed_addresses,omitempty"`
}

// Validate validates this node response records items0 service processor SSH info
func (m *NodeResponseRecordsItems0ServiceProcessorSSHInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAllowedAddresses(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorSSHInfo) validateAllowedAddresses(formats strfmt.Registry) error {
	if swag.IsZero(m.AllowedAddresses) { // not required
		return nil
	}

	for i := 0; i < len(m.AllowedAddresses); i++ {

		if err := m.AllowedAddresses[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ssh_info" + "." + "allowed_addresses" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// ContextValidate validate this node response records items0 service processor SSH info based on the context it is used
func (m *NodeResponseRecordsItems0ServiceProcessorSSHInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAllowedAddresses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorSSHInfo) contextValidateAllowedAddresses(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AllowedAddresses); i++ {

		if err := m.AllowedAddresses[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ssh_info" + "." + "allowed_addresses" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorSSHInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorSSHInfo) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ServiceProcessorSSHInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0Statistics Raw CPU performance for the nodes.
//
// swagger:model NodeResponseRecordsItems0Statistics
type NodeResponseRecordsItems0Statistics struct {

	// Base counter for CPU Utilization.
	// Example: 12345123
	ProcessorUtilizationBase int64 `json:"processor_utilization_base,omitempty"`

	// Raw CPU Utilization for the node. This should be divided by the processor_utilization_base to calculate the percentage CPU utilization for the node.
	// Example: 13
	ProcessorUtilizationRaw int64 `json:"processor_utilization_raw,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "inconsistent_delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this node response records items0 statistics
func (m *NodeResponseRecordsItems0Statistics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0StatisticsTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0StatisticsTypeStatusPropEnum = append(nodeResponseRecordsItems0StatisticsTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Statistics
	// NodeResponseRecordsItems0Statistics
	// status
	// Status
	// ok
	// END DEBUGGING
	// NodeResponseRecordsItems0StatisticsStatusOk captures enum value "ok"
	NodeResponseRecordsItems0StatisticsStatusOk string = "ok"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Statistics
	// NodeResponseRecordsItems0Statistics
	// status
	// Status
	// error
	// END DEBUGGING
	// NodeResponseRecordsItems0StatisticsStatusError captures enum value "error"
	NodeResponseRecordsItems0StatisticsStatusError string = "error"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Statistics
	// NodeResponseRecordsItems0Statistics
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// NodeResponseRecordsItems0StatisticsStatusPartialNoData captures enum value "partial_no_data"
	NodeResponseRecordsItems0StatisticsStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Statistics
	// NodeResponseRecordsItems0Statistics
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// NodeResponseRecordsItems0StatisticsStatusPartialNoUUID captures enum value "partial_no_uuid"
	NodeResponseRecordsItems0StatisticsStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Statistics
	// NodeResponseRecordsItems0Statistics
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// NodeResponseRecordsItems0StatisticsStatusPartialNoResponse captures enum value "partial_no_response"
	NodeResponseRecordsItems0StatisticsStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Statistics
	// NodeResponseRecordsItems0Statistics
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// NodeResponseRecordsItems0StatisticsStatusPartialOtherError captures enum value "partial_other_error"
	NodeResponseRecordsItems0StatisticsStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Statistics
	// NodeResponseRecordsItems0Statistics
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// NodeResponseRecordsItems0StatisticsStatusNegativeDelta captures enum value "negative_delta"
	NodeResponseRecordsItems0StatisticsStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Statistics
	// NodeResponseRecordsItems0Statistics
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// NodeResponseRecordsItems0StatisticsStatusBackfilledData captures enum value "backfilled_data"
	NodeResponseRecordsItems0StatisticsStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Statistics
	// NodeResponseRecordsItems0Statistics
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// NodeResponseRecordsItems0StatisticsStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	NodeResponseRecordsItems0StatisticsStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0Statistics
	// NodeResponseRecordsItems0Statistics
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// NodeResponseRecordsItems0StatisticsStatusInconsistentOldData captures enum value "inconsistent_old_data"
	NodeResponseRecordsItems0StatisticsStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *NodeResponseRecordsItems0Statistics) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0StatisticsTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0Statistics) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Statistics) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this node response records items0 statistics based on context it is used
func (m *NodeResponseRecordsItems0Statistics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Statistics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Statistics) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0Statistics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0VM node response records items0 VM
//
// swagger:model NodeResponseRecordsItems0VM
type NodeResponseRecordsItems0VM struct {

	// Cloud provider where the VM is hosted.
	// Read Only: true
	// Enum: [GoogleCloud AWS_S3 Azure_Cloud]
	ProviderType string `json:"provider_type,omitempty"`
}

// Validate validates this node response records items0 VM
func (m *NodeResponseRecordsItems0VM) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProviderType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0VmTypeProviderTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GoogleCloud","AWS_S3","Azure_Cloud"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0VmTypeProviderTypePropEnum = append(nodeResponseRecordsItems0VmTypeProviderTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0VM
	// NodeResponseRecordsItems0VM
	// provider_type
	// ProviderType
	// GoogleCloud
	// END DEBUGGING
	// NodeResponseRecordsItems0VMProviderTypeGoogleCloud captures enum value "GoogleCloud"
	NodeResponseRecordsItems0VMProviderTypeGoogleCloud string = "GoogleCloud"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0VM
	// NodeResponseRecordsItems0VM
	// provider_type
	// ProviderType
	// AWS_S3
	// END DEBUGGING
	// NodeResponseRecordsItems0VMProviderTypeAWSS3 captures enum value "AWS_S3"
	NodeResponseRecordsItems0VMProviderTypeAWSS3 string = "AWS_S3"

	// BEGIN DEBUGGING
	// NodeResponseRecordsItems0VM
	// NodeResponseRecordsItems0VM
	// provider_type
	// ProviderType
	// Azure_Cloud
	// END DEBUGGING
	// NodeResponseRecordsItems0VMProviderTypeAzureCloud captures enum value "Azure_Cloud"
	NodeResponseRecordsItems0VMProviderTypeAzureCloud string = "Azure_Cloud"
)

// prop value enum
func (m *NodeResponseRecordsItems0VM) validateProviderTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0VmTypeProviderTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0VM) validateProviderType(formats strfmt.Registry) error {
	if swag.IsZero(m.ProviderType) { // not required
		return nil
	}

	// value enum
	if err := m.validateProviderTypeEnum("vm"+"."+"provider_type", "body", m.ProviderType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 VM based on the context it is used
func (m *NodeResponseRecordsItems0VM) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProviderType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0VM) contextValidateProviderType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "vm"+"."+"provider_type", "body", string(m.ProviderType)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0VM) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0VM) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0VM
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0Version This returns the cluster version information.  When the cluster has more than one node, the cluster version is equivalent to the lowest of generation, major, and minor versions on all nodes.
//
// swagger:model NodeResponseRecordsItems0Version
type NodeResponseRecordsItems0Version struct {

	// The full cluster version string.
	// Example: NetApp Release 9.4.0: Sun Nov 05 18:20:57 UTC 2017
	// Read Only: true
	Full string `json:"full,omitempty"`

	// The generation portion of the version.
	// Example: 9
	// Read Only: true
	Generation int64 `json:"generation,omitempty"`

	// The major portion of the version.
	// Example: 4
	// Read Only: true
	Major int64 `json:"major,omitempty"`

	// The minor portion of the version.
	// Example: 0
	// Read Only: true
	Minor int64 `json:"minor,omitempty"`
}

// Validate validates this node response records items0 version
func (m *NodeResponseRecordsItems0Version) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this node response records items0 version based on the context it is used
func (m *NodeResponseRecordsItems0Version) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFull(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeneration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMajor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMinor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Version) contextValidateFull(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"full", "body", string(m.Full)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Version) contextValidateGeneration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"generation", "body", int64(m.Generation)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Version) contextValidateMajor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"major", "body", int64(m.Major)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Version) contextValidateMinor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"minor", "body", int64(m.Minor)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Version) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Version) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0Version
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
