// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Cluster Complete cluster information
//
// swagger:model cluster
type Cluster struct {

	// links
	Links *ClusterLinks `json:"_links,omitempty"`

	// certificate
	Certificate *ClusterCertificate `json:"certificate,omitempty"`

	// configuration backup
	ConfigurationBackup *ClusterConfigurationBackup `json:"configuration_backup,omitempty"`

	// contact
	// Example: support@company.com
	Contact string `json:"contact,omitempty"`

	// A list of DNS domains.
	// Domain names have the following requirements:
	// * The name must contain only the following characters: A through Z,
	//   a through z, 0 through 9, ".", "-" or "_".
	// * The first character of each label, delimited by ".", must be one
	//   of the following characters: A through Z or a through z or 0
	//   through 9.
	// * The last character of each label, delimited by ".", must be one of
	//   the following characters: A through Z, a through z, or 0 through 9.
	// * The top level domain must contain only the following characters: A
	//   through Z, a through z.
	// * The system reserves the following names:"all", "local", and "localhost".
	//
	// Example: ["example.com","example2.example3.com"]
	// Max Items: 6
	DNSDomains []string `json:"dns_domains,omitempty"`

	// license
	License *ClusterLicense `json:"license,omitempty"`

	// location
	// Example: building 1
	Location string `json:"location,omitempty"`

	// management interface
	ManagementInterface *ClusterManagementInterface `json:"management_interface,omitempty"`

	// management interfaces
	// Read Only: true
	ManagementInterfaces []*ClusterManagementInterfacesItems0 `json:"management_interfaces,omitempty"`

	// metric
	Metric *ClusterMetric `json:"metric,omitempty"`

	// name
	// Example: cluster1
	Name string `json:"name,omitempty"`

	// The list of IP addresses of the DNS servers. Addresses can be either
	// IPv4 or IPv6 addresses.
	//
	// Example: ["10.224.65.20","2001:db08:a0b:12f0::1"]
	// Max Items: 3
	NameServers []string `json:"name_servers,omitempty"`

	// nodes
	Nodes []*ClusterNodesItems0 `json:"nodes,omitempty"`

	// Host name, IPv4 address, or IPv6 address for the external NTP time servers.
	// Example: ["time.nist.gov","10.98.19.20","2610:20:6F15:15::27"]
	NtpServers []string `json:"ntp_servers,omitempty"`

	// Initial admin password used to create the cluster.
	// Example: mypassword
	// Format: password
	Password strfmt.Password `json:"password,omitempty"`

	// Specifies if this cluster is an All SAN Array.
	// Read Only: true
	SanOptimized *bool `json:"san_optimized,omitempty"`

	// statistics
	Statistics *ClusterStatistics `json:"statistics,omitempty"`

	// timezone
	Timezone *ClusterTimezone `json:"timezone,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`

	// version
	Version *ClusterVersion `json:"version,omitempty"`
}

// Validate validates this cluster
func (m *Cluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCertificate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigurationBackup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDNSDomains(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLicense(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementInterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNameServers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimezone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateCertificate(formats strfmt.Registry) error {
	if swag.IsZero(m.Certificate) { // not required
		return nil
	}

	if m.Certificate != nil {
		if err := m.Certificate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateConfigurationBackup(formats strfmt.Registry) error {
	if swag.IsZero(m.ConfigurationBackup) { // not required
		return nil
	}

	if m.ConfigurationBackup != nil {
		if err := m.ConfigurationBackup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("configuration_backup")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateDNSDomains(formats strfmt.Registry) error {
	if swag.IsZero(m.DNSDomains) { // not required
		return nil
	}

	iDNSDomainsSize := int64(len(m.DNSDomains))

	if err := validate.MaxItems("dns_domains", "body", iDNSDomainsSize, 6); err != nil {
		return err
	}

	for i := 0; i < len(m.DNSDomains); i++ {

		if err := validate.MinLength("dns_domains"+"."+strconv.Itoa(i), "body", m.DNSDomains[i], 1); err != nil {
			return err
		}

		if err := validate.MaxLength("dns_domains"+"."+strconv.Itoa(i), "body", m.DNSDomains[i], 255); err != nil {
			return err
		}

	}

	return nil
}

func (m *Cluster) validateLicense(formats strfmt.Registry) error {
	if swag.IsZero(m.License) { // not required
		return nil
	}

	if m.License != nil {
		if err := m.License.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("license")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateManagementInterface(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementInterface) { // not required
		return nil
	}

	if m.ManagementInterface != nil {
		if err := m.ManagementInterface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateManagementInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.ManagementInterfaces); i++ {
		if swag.IsZero(m.ManagementInterfaces[i]) { // not required
			continue
		}

		if m.ManagementInterfaces[i] != nil {
			if err := m.ManagementInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("management_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateMetric(formats strfmt.Registry) error {
	if swag.IsZero(m.Metric) { // not required
		return nil
	}

	if m.Metric != nil {
		if err := m.Metric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateNameServers(formats strfmt.Registry) error {
	if swag.IsZero(m.NameServers) { // not required
		return nil
	}

	iNameServersSize := int64(len(m.NameServers))

	if err := validate.MaxItems("name_servers", "body", iNameServersSize, 3); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateNodes(formats strfmt.Registry) error {
	if swag.IsZero(m.Nodes) { // not required
		return nil
	}

	for i := 0; i < len(m.Nodes); i++ {
		if swag.IsZero(m.Nodes[i]) { // not required
			continue
		}

		if m.Nodes[i] != nil {
			if err := m.Nodes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nodes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validatePassword(formats strfmt.Registry) error {
	if swag.IsZero(m.Password) { // not required
		return nil
	}

	if err := validate.FormatOf("password", "body", "password", m.Password.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateTimezone(formats strfmt.Registry) error {
	if swag.IsZero(m.Timezone) { // not required
		return nil
	}

	if m.Timezone != nil {
		if err := m.Timezone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("timezone")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster based on the context it is used
func (m *Cluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCertificate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfigurationBackup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLicense(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementInterface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNodes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSanOptimized(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimezone(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateCertificate(ctx context.Context, formats strfmt.Registry) error {

	if m.Certificate != nil {
		if err := m.Certificate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateConfigurationBackup(ctx context.Context, formats strfmt.Registry) error {

	if m.ConfigurationBackup != nil {
		if err := m.ConfigurationBackup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("configuration_backup")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateLicense(ctx context.Context, formats strfmt.Registry) error {

	if m.License != nil {
		if err := m.License.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("license")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateManagementInterface(ctx context.Context, formats strfmt.Registry) error {

	if m.ManagementInterface != nil {
		if err := m.ManagementInterface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateManagementInterfaces(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "management_interfaces", "body", []*ClusterManagementInterfacesItems0(m.ManagementInterfaces)); err != nil {
		return err
	}

	for i := 0; i < len(m.ManagementInterfaces); i++ {

		if m.ManagementInterfaces[i] != nil {
			if err := m.ManagementInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("management_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateMetric(ctx context.Context, formats strfmt.Registry) error {

	if m.Metric != nil {
		if err := m.Metric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateNodes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Nodes); i++ {

		if m.Nodes[i] != nil {
			if err := m.Nodes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nodes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateSanOptimized(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "san_optimized", "body", m.SanOptimized); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {
		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateTimezone(ctx context.Context, formats strfmt.Registry) error {

	if m.Timezone != nil {
		if err := m.Timezone.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("timezone")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", strfmt.UUID(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {
		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Cluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Cluster) UnmarshalBinary(b []byte) error {
	var res Cluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterCertificate Certificate used by cluster and node management interfaces for TLS connection requests.
//
// swagger:model ClusterCertificate
type ClusterCertificate struct {

	// links
	Links *ClusterCertificateLinks `json:"_links,omitempty"`

	// Certificate UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cluster certificate
func (m *ClusterCertificate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterCertificate) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster certificate based on the context it is used
func (m *ClusterCertificate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterCertificate) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterCertificate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterCertificate) UnmarshalBinary(b []byte) error {
	var res ClusterCertificate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterCertificateLinks cluster certificate links
//
// swagger:model ClusterCertificateLinks
type ClusterCertificateLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster certificate links
func (m *ClusterCertificateLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterCertificateLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster certificate links based on the context it is used
func (m *ClusterCertificateLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterCertificateLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterCertificateLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterCertificateLinks) UnmarshalBinary(b []byte) error {
	var res ClusterCertificateLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterConfigurationBackup cluster configuration backup
//
// swagger:model ClusterConfigurationBackup
type ClusterConfigurationBackup struct {

	// password
	// Example: yourpassword
	// Format: password
	Password strfmt.Password `json:"password,omitempty"`

	// An external backup location for the cluster configuration. This is mostly required for single node clusters where node and cluster configuration backups cannot be copied to other nodes in the cluster.
	// Example: http://10.224.65.198/backups
	URL string `json:"url,omitempty"`

	// username
	// Example: me
	Username string `json:"username,omitempty"`

	// Use this parameter with the value "true" to validate the digital certificate of the remote server. Digital certificate validation is available only when the HTTPS protocol is used in the URL; it is disabled by default.
	ValidateCertificate bool `json:"validate_certificate,omitempty"`
}

// Validate validates this cluster configuration backup
func (m *ClusterConfigurationBackup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePassword(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterConfigurationBackup) validatePassword(formats strfmt.Registry) error {
	if swag.IsZero(m.Password) { // not required
		return nil
	}

	if err := validate.FormatOf("configuration_backup"+"."+"password", "body", "password", m.Password.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster configuration backup based on context it is used
func (m *ClusterConfigurationBackup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterConfigurationBackup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterConfigurationBackup) UnmarshalBinary(b []byte) error {
	var res ClusterConfigurationBackup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterLicense License keys or NLF contents.
//
// swagger:model ClusterLicense
type ClusterLicense struct {

	// keys
	Keys []string `json:"keys,omitempty"`
}

// Validate validates this cluster license
func (m *ClusterLicense) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cluster license based on context it is used
func (m *ClusterLicense) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterLicense) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterLicense) UnmarshalBinary(b []byte) error {
	var res ClusterLicense
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterLinks cluster links
//
// swagger:model ClusterLinks
type ClusterLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster links
func (m *ClusterLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster links based on the context it is used
func (m *ClusterLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterLinks) UnmarshalBinary(b []byte) error {
	var res ClusterLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterManagementInterface The management interface of the cluster. The subnet mask and gateway for this interface are used for the node management interfaces provided in the node configuration.
//
// swagger:model ClusterManagementInterface
type ClusterManagementInterface struct {

	// ip
	IP *ClusterManagementInterfaceIP `json:"ip,omitempty"`
}

// Validate validates this cluster management interface
func (m *ClusterManagementInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterface) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster management interface based on the context it is used
func (m *ClusterManagementInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterface) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterManagementInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterManagementInterface) UnmarshalBinary(b []byte) error {
	var res ClusterManagementInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterManagementInterfaceIP Object to setup an interface along with its default router.
//
// swagger:model ClusterManagementInterfaceIP
type ClusterManagementInterfaceIP struct {

	// IPv4 or IPv6 address
	// Example: 10.10.10.7
	Address string `json:"address,omitempty"`

	// The IPv4 or IPv6 address of the default router.
	// Example: 10.1.1.1
	Gateway string `json:"gateway,omitempty"`

	// netmask
	Netmask IPNetmask `json:"netmask,omitempty"`
}

// Validate validates this cluster management interface IP
func (m *ClusterManagementInterfaceIP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetmask(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfaceIP) validateNetmask(formats strfmt.Registry) error {
	if swag.IsZero(m.Netmask) { // not required
		return nil
	}

	if err := m.Netmask.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("management_interface" + "." + "ip" + "." + "netmask")
		}
		return err
	}

	return nil
}

// ContextValidate validate this cluster management interface IP based on the context it is used
func (m *ClusterManagementInterfaceIP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetmask(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfaceIP) contextValidateNetmask(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Netmask.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("management_interface" + "." + "ip" + "." + "netmask")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterManagementInterfaceIP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterManagementInterfaceIP) UnmarshalBinary(b []byte) error {
	var res ClusterManagementInterfaceIP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterManagementInterfacesItems0 cluster management interfaces items0
//
// swagger:model ClusterManagementInterfacesItems0
type ClusterManagementInterfacesItems0 struct {

	// links
	Links *ClusterManagementInterfacesItems0Links `json:"_links,omitempty"`

	// ip
	IP *ClusterManagementInterfacesItems0IP `json:"ip,omitempty"`

	// The name of the interface.
	// Example: lif1
	Name string `json:"name,omitempty"`

	// The UUID that uniquely identifies the interface.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cluster management interfaces items0
func (m *ClusterManagementInterfacesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfacesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterManagementInterfacesItems0) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster management interfaces items0 based on the context it is used
func (m *ClusterManagementInterfacesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfacesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterManagementInterfacesItems0) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterManagementInterfacesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterManagementInterfacesItems0) UnmarshalBinary(b []byte) error {
	var res ClusterManagementInterfacesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterManagementInterfacesItems0IP IP information
//
// swagger:model ClusterManagementInterfacesItems0IP
type ClusterManagementInterfacesItems0IP struct {

	// address
	Address IPAddressReadonly `json:"address,omitempty"`
}

// Validate validates this cluster management interfaces items0 IP
func (m *ClusterManagementInterfacesItems0IP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfacesItems0IP) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.Address) { // not required
		return nil
	}

	if err := m.Address.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// ContextValidate validate this cluster management interfaces items0 IP based on the context it is used
func (m *ClusterManagementInterfacesItems0IP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfacesItems0IP) contextValidateAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Address.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterManagementInterfacesItems0IP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterManagementInterfacesItems0IP) UnmarshalBinary(b []byte) error {
	var res ClusterManagementInterfacesItems0IP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterManagementInterfacesItems0Links cluster management interfaces items0 links
//
// swagger:model ClusterManagementInterfacesItems0Links
type ClusterManagementInterfacesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster management interfaces items0 links
func (m *ClusterManagementInterfacesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfacesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster management interfaces items0 links based on the context it is used
func (m *ClusterManagementInterfacesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfacesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterManagementInterfacesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterManagementInterfacesItems0Links) UnmarshalBinary(b []byte) error {
	var res ClusterManagementInterfacesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetric Performance numbers, such as IOPS latency and throughput.
//
// swagger:model ClusterMetric
type ClusterMetric struct {

	// links
	Links *ClusterMetricLinks `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// iops
	Iops *ClusterMetricIops `json:"iops,omitempty"`

	// latency
	Latency *ClusterMetricLatency `json:"latency,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// throughput
	Throughput *ClusterMetricThroughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25 11:20:13
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this cluster metric
func (m *ClusterMetric) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetric) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var clusterMetricTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterMetricTypeDurationPropEnum = append(clusterMetricTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// duration
	// Duration
	// PT15S
	// END RIPPY DEBUGGING
	// ClusterMetricDurationPT15S captures enum value "PT15S"
	ClusterMetricDurationPT15S string = "PT15S"

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// duration
	// Duration
	// PT4M
	// END RIPPY DEBUGGING
	// ClusterMetricDurationPT4M captures enum value "PT4M"
	ClusterMetricDurationPT4M string = "PT4M"

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// duration
	// Duration
	// PT30M
	// END RIPPY DEBUGGING
	// ClusterMetricDurationPT30M captures enum value "PT30M"
	ClusterMetricDurationPT30M string = "PT30M"

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// duration
	// Duration
	// PT2H
	// END RIPPY DEBUGGING
	// ClusterMetricDurationPT2H captures enum value "PT2H"
	ClusterMetricDurationPT2H string = "PT2H"

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// duration
	// Duration
	// P1D
	// END RIPPY DEBUGGING
	// ClusterMetricDurationP1D captures enum value "P1D"
	ClusterMetricDurationP1D string = "P1D"

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// duration
	// Duration
	// PT5M
	// END RIPPY DEBUGGING
	// ClusterMetricDurationPT5M captures enum value "PT5M"
	ClusterMetricDurationPT5M string = "PT5M"
)

// prop value enum
func (m *ClusterMetric) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterMetricTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterMetric) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetric) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetric) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

var clusterMetricTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterMetricTypeStatusPropEnum = append(clusterMetricTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// ok
	// END RIPPY DEBUGGING
	// ClusterMetricStatusOk captures enum value "ok"
	ClusterMetricStatusOk string = "ok"

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// error
	// END RIPPY DEBUGGING
	// ClusterMetricStatusError captures enum value "error"
	ClusterMetricStatusError string = "error"

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// partial_no_data
	// END RIPPY DEBUGGING
	// ClusterMetricStatusPartialNoData captures enum value "partial_no_data"
	ClusterMetricStatusPartialNoData string = "partial_no_data"

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// partial_no_uuid
	// END RIPPY DEBUGGING
	// ClusterMetricStatusPartialNoUUID captures enum value "partial_no_uuid"
	ClusterMetricStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// partial_no_response
	// END RIPPY DEBUGGING
	// ClusterMetricStatusPartialNoResponse captures enum value "partial_no_response"
	ClusterMetricStatusPartialNoResponse string = "partial_no_response"

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// partial_other_error
	// END RIPPY DEBUGGING
	// ClusterMetricStatusPartialOtherError captures enum value "partial_other_error"
	ClusterMetricStatusPartialOtherError string = "partial_other_error"

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// negative_delta
	// END RIPPY DEBUGGING
	// ClusterMetricStatusNegativeDelta captures enum value "negative_delta"
	ClusterMetricStatusNegativeDelta string = "negative_delta"

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// backfilled_data
	// END RIPPY DEBUGGING
	// ClusterMetricStatusBackfilledData captures enum value "backfilled_data"
	ClusterMetricStatusBackfilledData string = "backfilled_data"

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// inconsistent_delta_time
	// END RIPPY DEBUGGING
	// ClusterMetricStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	ClusterMetricStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN RIPPY DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// inconsistent_old_data
	// END RIPPY DEBUGGING
	// ClusterMetricStatusInconsistentOldData captures enum value "inconsistent_old_data"
	ClusterMetricStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *ClusterMetric) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterMetricTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterMetric) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetric) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetric) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster metric based on the context it is used
func (m *ClusterMetric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetric) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetric) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetric) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetric) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetric) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetric) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetric) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetric) UnmarshalBinary(b []byte) error {
	var res ClusterMetric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetricIops The rate of I/O operations observed at the storage object.
//
// swagger:model ClusterMetricIops
type ClusterMetricIops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this cluster metric iops
func (m *ClusterMetricIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster metric iops based on the context it is used
func (m *ClusterMetricIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetricIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetricIops) UnmarshalBinary(b []byte) error {
	var res ClusterMetricIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetricLatency The round trip latency in microseconds observed at the storage object.
//
// swagger:model ClusterMetricLatency
type ClusterMetricLatency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this cluster metric latency
func (m *ClusterMetricLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster metric latency based on the context it is used
func (m *ClusterMetricLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetricLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetricLatency) UnmarshalBinary(b []byte) error {
	var res ClusterMetricLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetricLinks cluster metric links
//
// swagger:model ClusterMetricLinks
type ClusterMetricLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster metric links
func (m *ClusterMetricLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetricLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metric links based on the context it is used
func (m *ClusterMetricLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetricLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetricLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetricLinks) UnmarshalBinary(b []byte) error {
	var res ClusterMetricLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetricThroughput The rate of throughput bytes per second observed at the storage object.
//
// swagger:model ClusterMetricThroughput
type ClusterMetricThroughput struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this cluster metric throughput
func (m *ClusterMetricThroughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster metric throughput based on the context it is used
func (m *ClusterMetricThroughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetricThroughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetricThroughput) UnmarshalBinary(b []byte) error {
	var res ClusterMetricThroughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0 Complete node information
//
// swagger:model ClusterNodesItems0
type ClusterNodesItems0 struct {

	// links
	Links *ClusterNodesItems0Links `json:"_links,omitempty"`

	// cluster interface
	ClusterInterface *ClusterNodesItems0ClusterInterface `json:"cluster_interface,omitempty"`

	// cluster interfaces
	// Read Only: true
	ClusterInterfaces []*ClusterNodesItems0ClusterInterfacesItems0 `json:"cluster_interfaces,omitempty"`

	// controller
	Controller *ClusterNodesItems0Controller `json:"controller,omitempty"`

	// The current or "wall clock" time of the node in ISO-8601 date, time, and time zone format.
	// The ISO-8601 date and time are localized based on the ONTAP cluster's timezone setting.
	//
	// Example: 2019-04-17 15:49:26
	// Read Only: true
	// Format: date-time
	Date *strfmt.DateTime `json:"date,omitempty"`

	// ha
	Ha *ClusterNodesItems0Ha `json:"ha,omitempty"`

	// location
	// Example: rack 2 row 5
	Location string `json:"location,omitempty"`

	// management interface
	ManagementInterface *ClusterNodesItems0ManagementInterface `json:"management_interface,omitempty"`

	// management interfaces
	// Read Only: true
	ManagementInterfaces []*ClusterNodesItems0ManagementInterfacesItems0 `json:"management_interfaces,omitempty"`

	// Possible values:
	// * <i>available</i> - A node is detected on the internal cluster network and can be added to the cluster.  Nodes that have a membership of "available" are not returned when a GET request is called when the cluster exists. Provide a query on the "membership" property for <i>available</i> to scan for nodes on the cluster network. Nodes that have a membership of "available" are returned automatically before a cluster is created.
	// * <i>joining</i> - Joining nodes are in the process of being added to the cluster. The node might be progressing through the steps to become a member or might have failed. The job to add the node or create the cluster provides details on the current progress of the node.
	// * <i>member</i> - Nodes that are members have successfully joined the cluster.
	//
	// Read Only: true
	// Enum: [available joining member]
	Membership string `json:"membership,omitempty"`

	// model
	// Example: FAS3070
	// Read Only: true
	Model string `json:"model,omitempty"`

	// name
	// Example: node-01
	Name string `json:"name,omitempty"`

	// serial number
	// Example: 4048820-60-9
	// Read Only: true
	SerialNumber string `json:"serial_number,omitempty"`

	// service processor
	ServiceProcessor *ClusterNodesItems0ServiceProcessor `json:"service_processor,omitempty"`

	// State of the node:
	// * <i>up</i> - Node is up and operational.
	// * <i>booting</i> - Node is booting up.
	// * <i>down</i> - Node has stopped or is dumping core.
	// * <i>taken_over</i> - Node has been taken over by its HA partner and is not yet waiting for giveback.
	// * <i>waiting_for_giveback</i> - Node has been taken over by its HA partner and is waiting for the HA partner to giveback disks.
	// * <i>degraded</i> - Node has one or more critical services offline.
	// * <i>unknown</i> - Node or its HA partner cannot be contacted and there is no information on the node's state.
	//
	// Read Only: true
	// Enum: [up booting down taken_over waiting_for_giveback degraded unknown]
	State string `json:"state,omitempty"`

	// system id
	// Example: 537035403
	// Read Only: true
	SystemID string `json:"system_id,omitempty"`

	// OEM system machine type.
	// Example: 7Y56-CTOWW1
	// Read Only: true
	SystemMachineType string `json:"system_machine_type,omitempty"`

	// The total time, in seconds, that the node has been up.
	// Example: 300536
	// Read Only: true
	Uptime int64 `json:"uptime,omitempty"`

	// uuid
	// Example: 4ea7a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`

	// OEM vendor serial number.
	// Example: 791603000068
	// Read Only: true
	VendorSerialNumber string `json:"vendor_serial_number,omitempty"`

	// version
	Version *ClusterNodesItems0Version `json:"version,omitempty"`

	// vm
	VM *ClusterNodesItems0VM `json:"vm,omitempty"`
}

// Validate validates this cluster nodes items0
func (m *ClusterNodesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterInterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateController(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHa(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementInterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMembership(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceProcessor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVM(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateClusterInterface(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterInterface) { // not required
		return nil
	}

	if m.ClusterInterface != nil {
		if err := m.ClusterInterface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateClusterInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.ClusterInterfaces); i++ {
		if swag.IsZero(m.ClusterInterfaces[i]) { // not required
			continue
		}

		if m.ClusterInterfaces[i] != nil {
			if err := m.ClusterInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cluster_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0) validateController(formats strfmt.Registry) error {
	if swag.IsZero(m.Controller) { // not required
		return nil
	}

	if m.Controller != nil {
		if err := m.Controller.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateDate(formats strfmt.Registry) error {
	if swag.IsZero(m.Date) { // not required
		return nil
	}

	if err := validate.FormatOf("date", "body", "date-time", m.Date.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) validateHa(formats strfmt.Registry) error {
	if swag.IsZero(m.Ha) { // not required
		return nil
	}

	if m.Ha != nil {
		if err := m.Ha.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateManagementInterface(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementInterface) { // not required
		return nil
	}

	if m.ManagementInterface != nil {
		if err := m.ManagementInterface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateManagementInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.ManagementInterfaces); i++ {
		if swag.IsZero(m.ManagementInterfaces[i]) { // not required
			continue
		}

		if m.ManagementInterfaces[i] != nil {
			if err := m.ManagementInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("management_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var clusterNodesItems0TypeMembershipPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["available","joining","member"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0TypeMembershipPropEnum = append(clusterNodesItems0TypeMembershipPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// membership
	// Membership
	// available
	// END RIPPY DEBUGGING
	// ClusterNodesItems0MembershipAvailable captures enum value "available"
	ClusterNodesItems0MembershipAvailable string = "available"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// membership
	// Membership
	// joining
	// END RIPPY DEBUGGING
	// ClusterNodesItems0MembershipJoining captures enum value "joining"
	ClusterNodesItems0MembershipJoining string = "joining"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// membership
	// Membership
	// member
	// END RIPPY DEBUGGING
	// ClusterNodesItems0MembershipMember captures enum value "member"
	ClusterNodesItems0MembershipMember string = "member"
)

// prop value enum
func (m *ClusterNodesItems0) validateMembershipEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0TypeMembershipPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0) validateMembership(formats strfmt.Registry) error {
	if swag.IsZero(m.Membership) { // not required
		return nil
	}

	// value enum
	if err := m.validateMembershipEnum("membership", "body", m.Membership); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) validateServiceProcessor(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceProcessor) { // not required
		return nil
	}

	if m.ServiceProcessor != nil {
		if err := m.ServiceProcessor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor")
			}
			return err
		}
	}

	return nil
}

var clusterNodesItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["up","booting","down","taken_over","waiting_for_giveback","degraded","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0TypeStatePropEnum = append(clusterNodesItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// state
	// State
	// up
	// END RIPPY DEBUGGING
	// ClusterNodesItems0StateUp captures enum value "up"
	ClusterNodesItems0StateUp string = "up"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// state
	// State
	// booting
	// END RIPPY DEBUGGING
	// ClusterNodesItems0StateBooting captures enum value "booting"
	ClusterNodesItems0StateBooting string = "booting"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// state
	// State
	// down
	// END RIPPY DEBUGGING
	// ClusterNodesItems0StateDown captures enum value "down"
	ClusterNodesItems0StateDown string = "down"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// state
	// State
	// taken_over
	// END RIPPY DEBUGGING
	// ClusterNodesItems0StateTakenOver captures enum value "taken_over"
	ClusterNodesItems0StateTakenOver string = "taken_over"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// state
	// State
	// waiting_for_giveback
	// END RIPPY DEBUGGING
	// ClusterNodesItems0StateWaitingForGiveback captures enum value "waiting_for_giveback"
	ClusterNodesItems0StateWaitingForGiveback string = "waiting_for_giveback"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// state
	// State
	// degraded
	// END RIPPY DEBUGGING
	// ClusterNodesItems0StateDegraded captures enum value "degraded"
	ClusterNodesItems0StateDegraded string = "degraded"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// state
	// State
	// unknown
	// END RIPPY DEBUGGING
	// ClusterNodesItems0StateUnknown captures enum value "unknown"
	ClusterNodesItems0StateUnknown string = "unknown"
)

// prop value enum
func (m *ClusterNodesItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) validateUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateVM(formats strfmt.Registry) error {
	if swag.IsZero(m.VM) { // not required
		return nil
	}

	if m.VM != nil {
		if err := m.VM.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vm")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 based on the context it is used
func (m *ClusterNodesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterInterface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateController(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHa(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementInterface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMembership(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServiceProcessor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSystemID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSystemMachineType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUptime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVendorSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVM(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateClusterInterface(ctx context.Context, formats strfmt.Registry) error {

	if m.ClusterInterface != nil {
		if err := m.ClusterInterface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateClusterInterfaces(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cluster_interfaces", "body", []*ClusterNodesItems0ClusterInterfacesItems0(m.ClusterInterfaces)); err != nil {
		return err
	}

	for i := 0; i < len(m.ClusterInterfaces); i++ {

		if m.ClusterInterfaces[i] != nil {
			if err := m.ClusterInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cluster_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateController(ctx context.Context, formats strfmt.Registry) error {

	if m.Controller != nil {
		if err := m.Controller.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "date", "body", m.Date); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateHa(ctx context.Context, formats strfmt.Registry) error {

	if m.Ha != nil {
		if err := m.Ha.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateManagementInterface(ctx context.Context, formats strfmt.Registry) error {

	if m.ManagementInterface != nil {
		if err := m.ManagementInterface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateManagementInterfaces(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "management_interfaces", "body", []*ClusterNodesItems0ManagementInterfacesItems0(m.ManagementInterfaces)); err != nil {
		return err
	}

	for i := 0; i < len(m.ManagementInterfaces); i++ {

		if m.ManagementInterfaces[i] != nil {
			if err := m.ManagementInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("management_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateMembership(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "membership", "body", string(m.Membership)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateModel(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "model", "body", string(m.Model)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serial_number", "body", string(m.SerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateServiceProcessor(ctx context.Context, formats strfmt.Registry) error {

	if m.ServiceProcessor != nil {
		if err := m.ServiceProcessor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateSystemID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "system_id", "body", string(m.SystemID)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateSystemMachineType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "system_machine_type", "body", string(m.SystemMachineType)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateUptime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uptime", "body", int64(m.Uptime)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", strfmt.UUID(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateVendorSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "vendor_serial_number", "body", string(m.VendorSerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {
		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateVM(ctx context.Context, formats strfmt.Registry) error {

	if m.VM != nil {
		if err := m.VM.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vm")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ClusterInterface The cluster network IP address of the node to be added.
//
// swagger:model ClusterNodesItems0ClusterInterface
type ClusterNodesItems0ClusterInterface struct {

	// ip
	IP *NodeSetupIP `json:"ip,omitempty"`
}

// Validate validates this cluster nodes items0 cluster interface
func (m *ClusterNodesItems0ClusterInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterface) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 cluster interface based on the context it is used
func (m *ClusterNodesItems0ClusterInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterface) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterface) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ClusterInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ClusterInterfacesItems0 Network interface
//
// swagger:model ClusterNodesItems0ClusterInterfacesItems0
type ClusterNodesItems0ClusterInterfacesItems0 struct {

	// links
	Links *ClusterNodesItems0ClusterInterfacesItems0Links `json:"_links,omitempty"`

	// ip
	IP *ClusterNodesItems0ClusterInterfacesItems0IP `json:"ip,omitempty"`

	// The name of the interface.
	// Example: lif1
	Name string `json:"name,omitempty"`

	// The UUID that uniquely identifies the interface.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cluster nodes items0 cluster interfaces items0
func (m *ClusterNodesItems0ClusterInterfacesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 cluster interfaces items0 based on the context it is used
func (m *ClusterNodesItems0ClusterInterfacesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterfacesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterfacesItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ClusterInterfacesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ClusterInterfacesItems0IP IP information
//
// swagger:model ClusterNodesItems0ClusterInterfacesItems0IP
type ClusterNodesItems0ClusterInterfacesItems0IP struct {

	// address
	Address IPAddressReadonly `json:"address,omitempty"`
}

// Validate validates this cluster nodes items0 cluster interfaces items0 IP
func (m *ClusterNodesItems0ClusterInterfacesItems0IP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0IP) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.Address) { // not required
		return nil
	}

	if err := m.Address.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 cluster interfaces items0 IP based on the context it is used
func (m *ClusterNodesItems0ClusterInterfacesItems0IP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0IP) contextValidateAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Address.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterfacesItems0IP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterfacesItems0IP) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ClusterInterfacesItems0IP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ClusterInterfacesItems0Links cluster nodes items0 cluster interfaces items0 links
//
// swagger:model ClusterNodesItems0ClusterInterfacesItems0Links
type ClusterNodesItems0ClusterInterfacesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster nodes items0 cluster interfaces items0 links
func (m *ClusterNodesItems0ClusterInterfacesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 cluster interfaces items0 links based on the context it is used
func (m *ClusterNodesItems0ClusterInterfacesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterfacesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterfacesItems0Links) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ClusterInterfacesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0Controller Controller information
//
// swagger:model ClusterNodesItems0Controller
type ClusterNodesItems0Controller struct {

	// A list of Flash-Cache devices. Only returned when requested by name.
	// Read Only: true
	FlashCache []*ClusterNodesItems0ControllerFlashCacheItems0 `json:"flash_cache,omitempty"`

	// List of FRUs on the node. Only returned when requested by name.
	Frus []*ClusterNodesItems0ControllerFrusItems0 `json:"frus,omitempty"`

	// Specifies whether the hardware is currently operating outside of its recommended temperature range. The hardware shuts down if the temperature exceeds critical thresholds.
	// Read Only: true
	// Enum: [over normal]
	OverTemperature string `json:"over_temperature,omitempty"`
}

// Validate validates this cluster nodes items0 controller
func (m *ClusterNodesItems0Controller) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFlashCache(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverTemperature(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Controller) validateFlashCache(formats strfmt.Registry) error {
	if swag.IsZero(m.FlashCache) { // not required
		return nil
	}

	for i := 0; i < len(m.FlashCache); i++ {
		if swag.IsZero(m.FlashCache[i]) { // not required
			continue
		}

		if m.FlashCache[i] != nil {
			if err := m.FlashCache[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "flash_cache" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Controller) validateFrus(formats strfmt.Registry) error {
	if swag.IsZero(m.Frus) { // not required
		return nil
	}

	for i := 0; i < len(m.Frus); i++ {
		if swag.IsZero(m.Frus[i]) { // not required
			continue
		}

		if m.Frus[i] != nil {
			if err := m.Frus[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "frus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var clusterNodesItems0ControllerTypeOverTemperaturePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["over","normal"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ControllerTypeOverTemperaturePropEnum = append(clusterNodesItems0ControllerTypeOverTemperaturePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0Controller
	// ClusterNodesItems0Controller
	// over_temperature
	// OverTemperature
	// over
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerOverTemperatureOver captures enum value "over"
	ClusterNodesItems0ControllerOverTemperatureOver string = "over"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0Controller
	// ClusterNodesItems0Controller
	// over_temperature
	// OverTemperature
	// normal
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerOverTemperatureNormal captures enum value "normal"
	ClusterNodesItems0ControllerOverTemperatureNormal string = "normal"
)

// prop value enum
func (m *ClusterNodesItems0Controller) validateOverTemperatureEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ControllerTypeOverTemperaturePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0Controller) validateOverTemperature(formats strfmt.Registry) error {
	if swag.IsZero(m.OverTemperature) { // not required
		return nil
	}

	// value enum
	if err := m.validateOverTemperatureEnum("controller"+"."+"over_temperature", "body", m.OverTemperature); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 controller based on the context it is used
func (m *ClusterNodesItems0Controller) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFlashCache(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFrus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOverTemperature(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Controller) contextValidateFlashCache(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"flash_cache", "body", []*ClusterNodesItems0ControllerFlashCacheItems0(m.FlashCache)); err != nil {
		return err
	}

	for i := 0; i < len(m.FlashCache); i++ {

		if m.FlashCache[i] != nil {
			if err := m.FlashCache[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "flash_cache" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Controller) contextValidateFrus(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Frus); i++ {

		if m.Frus[i] != nil {
			if err := m.Frus[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "frus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Controller) contextValidateOverTemperature(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"over_temperature", "body", string(m.OverTemperature)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0Controller) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0Controller) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0Controller
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ControllerFlashCacheItems0 cluster nodes items0 controller flash cache items0
//
// swagger:model ClusterNodesItems0ControllerFlashCacheItems0
type ClusterNodesItems0ControllerFlashCacheItems0 struct {

	// Size in bytes
	// Example: 1024000000000
	// Read Only: true
	Capacity int64 `json:"capacity,omitempty"`

	// firmware version
	// Example: NA05
	// Read Only: true
	FirmwareVersion string `json:"firmware_version,omitempty"`

	// hardware revision
	// Example: A1
	// Read Only: true
	HardwareRevision string `json:"hardware_revision,omitempty"`

	// model
	// Example: X1970A
	// Read Only: true
	Model string `json:"model,omitempty"`

	// part number
	// Example: 119-00207
	// Read Only: true
	PartNumber string `json:"part_number,omitempty"`

	// serial number
	// Example: A22P5061550000187
	// Read Only: true
	SerialNumber string `json:"serial_number,omitempty"`

	// slot
	// Example: 6-1
	// Read Only: true
	Slot string `json:"slot,omitempty"`

	// state
	// Read Only: true
	// Enum: [ok erasing erased failed removed]
	State string `json:"state,omitempty"`
}

// Validate validates this cluster nodes items0 controller flash cache items0
func (m *ClusterNodesItems0ControllerFlashCacheItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0ControllerFlashCacheItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","erasing","erased","failed","removed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ControllerFlashCacheItems0TypeStatePropEnum = append(clusterNodesItems0ControllerFlashCacheItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0
	// ClusterNodesItems0ControllerFlashCacheItems0
	// state
	// State
	// ok
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0StateOk captures enum value "ok"
	ClusterNodesItems0ControllerFlashCacheItems0StateOk string = "ok"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0
	// ClusterNodesItems0ControllerFlashCacheItems0
	// state
	// State
	// erasing
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0StateErasing captures enum value "erasing"
	ClusterNodesItems0ControllerFlashCacheItems0StateErasing string = "erasing"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0
	// ClusterNodesItems0ControllerFlashCacheItems0
	// state
	// State
	// erased
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0StateErased captures enum value "erased"
	ClusterNodesItems0ControllerFlashCacheItems0StateErased string = "erased"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0
	// ClusterNodesItems0ControllerFlashCacheItems0
	// state
	// State
	// failed
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0StateFailed captures enum value "failed"
	ClusterNodesItems0ControllerFlashCacheItems0StateFailed string = "failed"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0
	// ClusterNodesItems0ControllerFlashCacheItems0
	// state
	// State
	// removed
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0StateRemoved captures enum value "removed"
	ClusterNodesItems0ControllerFlashCacheItems0StateRemoved string = "removed"
)

// prop value enum
func (m *ClusterNodesItems0ControllerFlashCacheItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ControllerFlashCacheItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 controller flash cache items0 based on the context it is used
func (m *ClusterNodesItems0ControllerFlashCacheItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCapacity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFirmwareVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHardwareRevision(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSlot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateCapacity(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "capacity", "body", int64(m.Capacity)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateFirmwareVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "firmware_version", "body", string(m.FirmwareVersion)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateHardwareRevision(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "hardware_revision", "body", string(m.HardwareRevision)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateModel(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "model", "body", string(m.Model)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidatePartNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "part_number", "body", string(m.PartNumber)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serial_number", "body", string(m.SerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateSlot(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "slot", "body", string(m.Slot)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFlashCacheItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFlashCacheItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ControllerFlashCacheItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ControllerFrusItems0 cluster nodes items0 controller frus items0
//
// swagger:model ClusterNodesItems0ControllerFrusItems0
type ClusterNodesItems0ControllerFrusItems0 struct {

	// id
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// state
	// Read Only: true
	// Enum: [ok error]
	State string `json:"state,omitempty"`

	// type
	// Read Only: true
	// Enum: [fan psu pcie disk nvs dimm controller]
	Type string `json:"type,omitempty"`
}

// Validate validates this cluster nodes items0 controller frus items0
func (m *ClusterNodesItems0ControllerFrusItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0ControllerFrusItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ControllerFrusItems0TypeStatePropEnum = append(clusterNodesItems0ControllerFrusItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// state
	// State
	// ok
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0StateOk captures enum value "ok"
	ClusterNodesItems0ControllerFrusItems0StateOk string = "ok"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// state
	// State
	// error
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0StateError captures enum value "error"
	ClusterNodesItems0ControllerFrusItems0StateError string = "error"
)

// prop value enum
func (m *ClusterNodesItems0ControllerFrusItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ControllerFrusItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFrusItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var clusterNodesItems0ControllerFrusItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fan","psu","pcie","disk","nvs","dimm","controller"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ControllerFrusItems0TypeTypePropEnum = append(clusterNodesItems0ControllerFrusItems0TypeTypePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// type
	// Type
	// fan
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0TypeFan captures enum value "fan"
	ClusterNodesItems0ControllerFrusItems0TypeFan string = "fan"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// type
	// Type
	// psu
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0TypePsu captures enum value "psu"
	ClusterNodesItems0ControllerFrusItems0TypePsu string = "psu"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// type
	// Type
	// pcie
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0TypePcie captures enum value "pcie"
	ClusterNodesItems0ControllerFrusItems0TypePcie string = "pcie"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// type
	// Type
	// disk
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0TypeDisk captures enum value "disk"
	ClusterNodesItems0ControllerFrusItems0TypeDisk string = "disk"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// type
	// Type
	// nvs
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0TypeNvs captures enum value "nvs"
	ClusterNodesItems0ControllerFrusItems0TypeNvs string = "nvs"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// type
	// Type
	// dimm
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0TypeDimm captures enum value "dimm"
	ClusterNodesItems0ControllerFrusItems0TypeDimm string = "dimm"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// type
	// Type
	// controller
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0TypeController captures enum value "controller"
	ClusterNodesItems0ControllerFrusItems0TypeController string = "controller"
)

// prop value enum
func (m *ClusterNodesItems0ControllerFrusItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ControllerFrusItems0TypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFrusItems0) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 controller frus items0 based on the context it is used
func (m *ClusterNodesItems0ControllerFrusItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFrusItems0) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", int64(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFrusItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFrusItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(m.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFrusItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFrusItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ControllerFrusItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0Ha cluster nodes items0 ha
//
// swagger:model ClusterNodesItems0Ha
type ClusterNodesItems0Ha struct {

	// Specifies whether giveback is automatically initiated when the node that owns the storage is ready.
	// Read Only: true
	AutoGiveback *bool `json:"auto_giveback,omitempty"`

	// Specifies whether or not storage failover is enabled.
	// Read Only: true
	Enabled *bool `json:"enabled,omitempty"`

	// giveback
	Giveback *ClusterNodesItems0HaGiveback `json:"giveback,omitempty"`

	// Nodes in this node's High Availability (HA) group.
	// Read Only: true
	Partners []*ClusterNodesItems0HaPartnersItems0 `json:"partners,omitempty"`

	// ports
	// Read Only: true
	Ports []*ClusterNodesItems0HaPortsItems0 `json:"ports,omitempty"`

	// takeover
	Takeover *ClusterNodesItems0HaTakeover `json:"takeover,omitempty"`
}

// Validate validates this cluster nodes items0 ha
func (m *ClusterNodesItems0Ha) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGiveback(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartners(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTakeover(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Ha) validateGiveback(formats strfmt.Registry) error {
	if swag.IsZero(m.Giveback) { // not required
		return nil
	}

	if m.Giveback != nil {
		if err := m.Giveback.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0Ha) validatePartners(formats strfmt.Registry) error {
	if swag.IsZero(m.Partners) { // not required
		return nil
	}

	for i := 0; i < len(m.Partners); i++ {
		if swag.IsZero(m.Partners[i]) { // not required
			continue
		}

		if m.Partners[i] != nil {
			if err := m.Partners[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "partners" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Ha) validatePorts(formats strfmt.Registry) error {
	if swag.IsZero(m.Ports) { // not required
		return nil
	}

	for i := 0; i < len(m.Ports); i++ {
		if swag.IsZero(m.Ports[i]) { // not required
			continue
		}

		if m.Ports[i] != nil {
			if err := m.Ports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Ha) validateTakeover(formats strfmt.Registry) error {
	if swag.IsZero(m.Takeover) { // not required
		return nil
	}

	if m.Takeover != nil {
		if err := m.Takeover.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha based on the context it is used
func (m *ClusterNodesItems0Ha) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAutoGiveback(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGiveback(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartners(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePorts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTakeover(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Ha) contextValidateAutoGiveback(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"auto_giveback", "body", m.AutoGiveback); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Ha) contextValidateEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Ha) contextValidateGiveback(ctx context.Context, formats strfmt.Registry) error {

	if m.Giveback != nil {
		if err := m.Giveback.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0Ha) contextValidatePartners(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"partners", "body", []*ClusterNodesItems0HaPartnersItems0(m.Partners)); err != nil {
		return err
	}

	for i := 0; i < len(m.Partners); i++ {

		if m.Partners[i] != nil {
			if err := m.Partners[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "partners" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Ha) contextValidatePorts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"ports", "body", []*ClusterNodesItems0HaPortsItems0(m.Ports)); err != nil {
		return err
	}

	for i := 0; i < len(m.Ports); i++ {

		if m.Ports[i] != nil {
			if err := m.Ports[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Ha) contextValidateTakeover(ctx context.Context, formats strfmt.Registry) error {

	if m.Takeover != nil {
		if err := m.Takeover.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0Ha) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0Ha) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0Ha
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaGiveback Represents the state of the node that is giving storage back to its HA partner.
//
// swagger:model ClusterNodesItems0HaGiveback
type ClusterNodesItems0HaGiveback struct {

	// failure
	Failure *ClusterNodesItems0HaGivebackFailure `json:"failure,omitempty"`

	// state
	// Example: failed
	// Enum: [nothing_to_giveback not_attempted in_progress failed]
	State string `json:"state,omitempty"`
}

// Validate validates this cluster nodes items0 ha giveback
func (m *ClusterNodesItems0HaGiveback) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailure(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaGiveback) validateFailure(formats strfmt.Registry) error {
	if swag.IsZero(m.Failure) { // not required
		return nil
	}

	if m.Failure != nil {
		if err := m.Failure.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

var clusterNodesItems0HaGivebackTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["nothing_to_giveback","not_attempted","in_progress","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0HaGivebackTypeStatePropEnum = append(clusterNodesItems0HaGivebackTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0HaGiveback
	// ClusterNodesItems0HaGiveback
	// state
	// State
	// nothing_to_giveback
	// END RIPPY DEBUGGING
	// ClusterNodesItems0HaGivebackStateNothingToGiveback captures enum value "nothing_to_giveback"
	ClusterNodesItems0HaGivebackStateNothingToGiveback string = "nothing_to_giveback"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0HaGiveback
	// ClusterNodesItems0HaGiveback
	// state
	// State
	// not_attempted
	// END RIPPY DEBUGGING
	// ClusterNodesItems0HaGivebackStateNotAttempted captures enum value "not_attempted"
	ClusterNodesItems0HaGivebackStateNotAttempted string = "not_attempted"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0HaGiveback
	// ClusterNodesItems0HaGiveback
	// state
	// State
	// in_progress
	// END RIPPY DEBUGGING
	// ClusterNodesItems0HaGivebackStateInProgress captures enum value "in_progress"
	ClusterNodesItems0HaGivebackStateInProgress string = "in_progress"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0HaGiveback
	// ClusterNodesItems0HaGiveback
	// state
	// State
	// failed
	// END RIPPY DEBUGGING
	// ClusterNodesItems0HaGivebackStateFailed captures enum value "failed"
	ClusterNodesItems0HaGivebackStateFailed string = "failed"
)

// prop value enum
func (m *ClusterNodesItems0HaGiveback) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0HaGivebackTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0HaGiveback) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("ha"+"."+"giveback"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha giveback based on the context it is used
func (m *ClusterNodesItems0HaGiveback) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFailure(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaGiveback) contextValidateFailure(ctx context.Context, formats strfmt.Registry) error {

	if m.Failure != nil {
		if err := m.Failure.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaGiveback) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaGiveback) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaGiveback
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaGivebackFailure Indicates the failure code and message.
//
// swagger:model ClusterNodesItems0HaGivebackFailure
type ClusterNodesItems0HaGivebackFailure struct {

	// Message code
	// Example: 852126
	Code int64 `json:"code,omitempty"`

	// Detailed message based on the state.
	// Example: Failed to initiate giveback. Run the \"storage failover show-giveback\" command for more information.
	Message string `json:"message,omitempty"`
}

// Validate validates this cluster nodes items0 ha giveback failure
func (m *ClusterNodesItems0HaGivebackFailure) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster nodes items0 ha giveback failure based on the context it is used
func (m *ClusterNodesItems0HaGivebackFailure) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaGivebackFailure) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaGivebackFailure) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaGivebackFailure
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaPartnersItems0 cluster nodes items0 ha partners items0
//
// swagger:model ClusterNodesItems0HaPartnersItems0
type ClusterNodesItems0HaPartnersItems0 struct {

	// links
	Links *ClusterNodesItems0HaPartnersItems0Links `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cluster nodes items0 ha partners items0
func (m *ClusterNodesItems0HaPartnersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaPartnersItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha partners items0 based on the context it is used
func (m *ClusterNodesItems0HaPartnersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaPartnersItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaPartnersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaPartnersItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaPartnersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaPartnersItems0Links cluster nodes items0 ha partners items0 links
//
// swagger:model ClusterNodesItems0HaPartnersItems0Links
type ClusterNodesItems0HaPartnersItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster nodes items0 ha partners items0 links
func (m *ClusterNodesItems0HaPartnersItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaPartnersItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha partners items0 links based on the context it is used
func (m *ClusterNodesItems0HaPartnersItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaPartnersItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaPartnersItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaPartnersItems0Links) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaPartnersItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaPortsItems0 cluster nodes items0 ha ports items0
//
// swagger:model ClusterNodesItems0HaPortsItems0
type ClusterNodesItems0HaPortsItems0 struct {

	// HA port number
	// Example: 0
	// Read Only: true
	Number int64 `json:"number,omitempty"`

	// HA port state:
	// * <i>down</i> - Logical HA link is down.
	// * <i>initialized</i> - Logical HA link is initialized. The physical link is up, but the subnet manager hasnt started to configure the port.
	// * <i>armed</i> - Logical HA link is armed. The physical link is up and the subnet manager started but did not yet complete configuring the port.
	// * <i>active</i> - Logical HA link is active.
	// * <i>reserved</i> - Logical HA link is active, but the physical link is down.
	//
	// Example: active
	// Read Only: true
	// Enum: [down initialized armed active reserved]
	State string `json:"state,omitempty"`
}

// Validate validates this cluster nodes items0 ha ports items0
func (m *ClusterNodesItems0HaPortsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0HaPortsItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["down","initialized","armed","active","reserved"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0HaPortsItems0TypeStatePropEnum = append(clusterNodesItems0HaPortsItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0HaPortsItems0
	// ClusterNodesItems0HaPortsItems0
	// state
	// State
	// down
	// END RIPPY DEBUGGING
	// ClusterNodesItems0HaPortsItems0StateDown captures enum value "down"
	ClusterNodesItems0HaPortsItems0StateDown string = "down"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0HaPortsItems0
	// ClusterNodesItems0HaPortsItems0
	// state
	// State
	// initialized
	// END RIPPY DEBUGGING
	// ClusterNodesItems0HaPortsItems0StateInitialized captures enum value "initialized"
	ClusterNodesItems0HaPortsItems0StateInitialized string = "initialized"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0HaPortsItems0
	// ClusterNodesItems0HaPortsItems0
	// state
	// State
	// armed
	// END RIPPY DEBUGGING
	// ClusterNodesItems0HaPortsItems0StateArmed captures enum value "armed"
	ClusterNodesItems0HaPortsItems0StateArmed string = "armed"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0HaPortsItems0
	// ClusterNodesItems0HaPortsItems0
	// state
	// State
	// active
	// END RIPPY DEBUGGING
	// ClusterNodesItems0HaPortsItems0StateActive captures enum value "active"
	ClusterNodesItems0HaPortsItems0StateActive string = "active"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0HaPortsItems0
	// ClusterNodesItems0HaPortsItems0
	// state
	// State
	// reserved
	// END RIPPY DEBUGGING
	// ClusterNodesItems0HaPortsItems0StateReserved captures enum value "reserved"
	ClusterNodesItems0HaPortsItems0StateReserved string = "reserved"
)

// prop value enum
func (m *ClusterNodesItems0HaPortsItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0HaPortsItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0HaPortsItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha ports items0 based on the context it is used
func (m *ClusterNodesItems0HaPortsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaPortsItems0) contextValidateNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "number", "body", int64(m.Number)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0HaPortsItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaPortsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaPortsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaPortsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaTakeover This represents the state of the node that is taking over storage from its HA partner.
//
// swagger:model ClusterNodesItems0HaTakeover
type ClusterNodesItems0HaTakeover struct {

	// failure
	Failure *ClusterNodesItems0HaTakeoverFailure `json:"failure,omitempty"`

	// state
	// Example: failed
	// Enum: [not_possible not_attempted in_takeover in_progress failed]
	State string `json:"state,omitempty"`
}

// Validate validates this cluster nodes items0 ha takeover
func (m *ClusterNodesItems0HaTakeover) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailure(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaTakeover) validateFailure(formats strfmt.Registry) error {
	if swag.IsZero(m.Failure) { // not required
		return nil
	}

	if m.Failure != nil {
		if err := m.Failure.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

var clusterNodesItems0HaTakeoverTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["not_possible","not_attempted","in_takeover","in_progress","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0HaTakeoverTypeStatePropEnum = append(clusterNodesItems0HaTakeoverTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0HaTakeover
	// ClusterNodesItems0HaTakeover
	// state
	// State
	// not_possible
	// END RIPPY DEBUGGING
	// ClusterNodesItems0HaTakeoverStateNotPossible captures enum value "not_possible"
	ClusterNodesItems0HaTakeoverStateNotPossible string = "not_possible"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0HaTakeover
	// ClusterNodesItems0HaTakeover
	// state
	// State
	// not_attempted
	// END RIPPY DEBUGGING
	// ClusterNodesItems0HaTakeoverStateNotAttempted captures enum value "not_attempted"
	ClusterNodesItems0HaTakeoverStateNotAttempted string = "not_attempted"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0HaTakeover
	// ClusterNodesItems0HaTakeover
	// state
	// State
	// in_takeover
	// END RIPPY DEBUGGING
	// ClusterNodesItems0HaTakeoverStateInTakeover captures enum value "in_takeover"
	ClusterNodesItems0HaTakeoverStateInTakeover string = "in_takeover"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0HaTakeover
	// ClusterNodesItems0HaTakeover
	// state
	// State
	// in_progress
	// END RIPPY DEBUGGING
	// ClusterNodesItems0HaTakeoverStateInProgress captures enum value "in_progress"
	ClusterNodesItems0HaTakeoverStateInProgress string = "in_progress"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0HaTakeover
	// ClusterNodesItems0HaTakeover
	// state
	// State
	// failed
	// END RIPPY DEBUGGING
	// ClusterNodesItems0HaTakeoverStateFailed captures enum value "failed"
	ClusterNodesItems0HaTakeoverStateFailed string = "failed"
)

// prop value enum
func (m *ClusterNodesItems0HaTakeover) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0HaTakeoverTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0HaTakeover) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("ha"+"."+"takeover"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha takeover based on the context it is used
func (m *ClusterNodesItems0HaTakeover) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFailure(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaTakeover) contextValidateFailure(ctx context.Context, formats strfmt.Registry) error {

	if m.Failure != nil {
		if err := m.Failure.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaTakeover) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaTakeover) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaTakeover
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaTakeoverFailure Indicates the failure code and message.
//
// swagger:model ClusterNodesItems0HaTakeoverFailure
type ClusterNodesItems0HaTakeoverFailure struct {

	// Message code
	// Example: 852130
	Code int64 `json:"code,omitempty"`

	// Detailed message based on the state.
	// Example: Failed to initiate takeover. Run the \"storage failover show-takeover\" command for more information.
	Message string `json:"message,omitempty"`
}

// Validate validates this cluster nodes items0 ha takeover failure
func (m *ClusterNodesItems0HaTakeoverFailure) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster nodes items0 ha takeover failure based on the context it is used
func (m *ClusterNodesItems0HaTakeoverFailure) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaTakeoverFailure) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaTakeoverFailure) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaTakeoverFailure
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0Links cluster nodes items0 links
//
// swagger:model ClusterNodesItems0Links
type ClusterNodesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster nodes items0 links
func (m *ClusterNodesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 links based on the context it is used
func (m *ClusterNodesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0Links) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ManagementInterface The management interface of the node to be added. The subnet mask is set based on the management interface of the cluster or the managment interfaces of other nodes.
//
// swagger:model ClusterNodesItems0ManagementInterface
type ClusterNodesItems0ManagementInterface struct {

	// ip
	IP *NodeSetupIP `json:"ip,omitempty"`
}

// Validate validates this cluster nodes items0 management interface
func (m *ClusterNodesItems0ManagementInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterface) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 management interface based on the context it is used
func (m *ClusterNodesItems0ManagementInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterface) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterface) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ManagementInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ManagementInterfacesItems0 Network interface
//
// swagger:model ClusterNodesItems0ManagementInterfacesItems0
type ClusterNodesItems0ManagementInterfacesItems0 struct {

	// links
	Links *ClusterNodesItems0ManagementInterfacesItems0Links `json:"_links,omitempty"`

	// ip
	IP *ClusterNodesItems0ManagementInterfacesItems0IP `json:"ip,omitempty"`

	// The name of the interface.
	// Example: lif1
	Name string `json:"name,omitempty"`

	// The UUID that uniquely identifies the interface.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cluster nodes items0 management interfaces items0
func (m *ClusterNodesItems0ManagementInterfacesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 management interfaces items0 based on the context it is used
func (m *ClusterNodesItems0ManagementInterfacesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterfacesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterfacesItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ManagementInterfacesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ManagementInterfacesItems0IP IP information
//
// swagger:model ClusterNodesItems0ManagementInterfacesItems0IP
type ClusterNodesItems0ManagementInterfacesItems0IP struct {

	// address
	Address IPAddressReadonly `json:"address,omitempty"`
}

// Validate validates this cluster nodes items0 management interfaces items0 IP
func (m *ClusterNodesItems0ManagementInterfacesItems0IP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0IP) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.Address) { // not required
		return nil
	}

	if err := m.Address.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 management interfaces items0 IP based on the context it is used
func (m *ClusterNodesItems0ManagementInterfacesItems0IP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0IP) contextValidateAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Address.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterfacesItems0IP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterfacesItems0IP) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ManagementInterfacesItems0IP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ManagementInterfacesItems0Links cluster nodes items0 management interfaces items0 links
//
// swagger:model ClusterNodesItems0ManagementInterfacesItems0Links
type ClusterNodesItems0ManagementInterfacesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster nodes items0 management interfaces items0 links
func (m *ClusterNodesItems0ManagementInterfacesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 management interfaces items0 links based on the context it is used
func (m *ClusterNodesItems0ManagementInterfacesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterfacesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterfacesItems0Links) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ManagementInterfacesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ServiceProcessor cluster nodes items0 service processor
//
// swagger:model ClusterNodesItems0ServiceProcessor
type ClusterNodesItems0ServiceProcessor struct {

	// Set to "true" to use DHCP to configure an IPv4 interface.
	DhcpEnabled bool `json:"dhcp_enabled,omitempty"`

	// The version of firmware installed.
	// Read Only: true
	FirmwareVersion string `json:"firmware_version,omitempty"`

	// ipv4 interface
	IPV4Interface *ClusterNodesItems0ServiceProcessorIPV4Interface `json:"ipv4_interface,omitempty"`

	// ipv6 interface
	IPV6Interface *ClusterNodesItems0ServiceProcessorIPV6Interface `json:"ipv6_interface,omitempty"`

	// link status
	// Read Only: true
	// Enum: [up down disabled unknown]
	LinkStatus string `json:"link_status,omitempty"`

	// mac address
	// Read Only: true
	MacAddress string `json:"mac_address,omitempty"`

	// state
	// Read Only: true
	// Enum: [online offline degraded rebooting unknown updating node_offline sp_daemon_offline]
	State string `json:"state,omitempty"`
}

// Validate validates this cluster nodes items0 service processor
func (m *ClusterNodesItems0ServiceProcessor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIPV4Interface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPV6Interface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinkStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validateIPV4Interface(formats strfmt.Registry) error {
	if swag.IsZero(m.IPV4Interface) { // not required
		return nil
	}

	if m.IPV4Interface != nil {
		if err := m.IPV4Interface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv4_interface")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validateIPV6Interface(formats strfmt.Registry) error {
	if swag.IsZero(m.IPV6Interface) { // not required
		return nil
	}

	if m.IPV6Interface != nil {
		if err := m.IPV6Interface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv6_interface")
			}
			return err
		}
	}

	return nil
}

var clusterNodesItems0ServiceProcessorTypeLinkStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["up","down","disabled","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ServiceProcessorTypeLinkStatusPropEnum = append(clusterNodesItems0ServiceProcessorTypeLinkStatusPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// link_status
	// LinkStatus
	// up
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessorLinkStatusUp captures enum value "up"
	ClusterNodesItems0ServiceProcessorLinkStatusUp string = "up"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// link_status
	// LinkStatus
	// down
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessorLinkStatusDown captures enum value "down"
	ClusterNodesItems0ServiceProcessorLinkStatusDown string = "down"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// link_status
	// LinkStatus
	// disabled
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessorLinkStatusDisabled captures enum value "disabled"
	ClusterNodesItems0ServiceProcessorLinkStatusDisabled string = "disabled"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// link_status
	// LinkStatus
	// unknown
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessorLinkStatusUnknown captures enum value "unknown"
	ClusterNodesItems0ServiceProcessorLinkStatusUnknown string = "unknown"
)

// prop value enum
func (m *ClusterNodesItems0ServiceProcessor) validateLinkStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ServiceProcessorTypeLinkStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validateLinkStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.LinkStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateLinkStatusEnum("service_processor"+"."+"link_status", "body", m.LinkStatus); err != nil {
		return err
	}

	return nil
}

var clusterNodesItems0ServiceProcessorTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["online","offline","degraded","rebooting","unknown","updating","node_offline","sp_daemon_offline"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ServiceProcessorTypeStatePropEnum = append(clusterNodesItems0ServiceProcessorTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// online
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateOnline captures enum value "online"
	ClusterNodesItems0ServiceProcessorStateOnline string = "online"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// offline
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateOffline captures enum value "offline"
	ClusterNodesItems0ServiceProcessorStateOffline string = "offline"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// degraded
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateDegraded captures enum value "degraded"
	ClusterNodesItems0ServiceProcessorStateDegraded string = "degraded"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// rebooting
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateRebooting captures enum value "rebooting"
	ClusterNodesItems0ServiceProcessorStateRebooting string = "rebooting"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// unknown
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateUnknown captures enum value "unknown"
	ClusterNodesItems0ServiceProcessorStateUnknown string = "unknown"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// updating
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateUpdating captures enum value "updating"
	ClusterNodesItems0ServiceProcessorStateUpdating string = "updating"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// node_offline
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateNodeOffline captures enum value "node_offline"
	ClusterNodesItems0ServiceProcessorStateNodeOffline string = "node_offline"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// sp_daemon_offline
	// END RIPPY DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateSpDaemonOffline captures enum value "sp_daemon_offline"
	ClusterNodesItems0ServiceProcessorStateSpDaemonOffline string = "sp_daemon_offline"
)

// prop value enum
func (m *ClusterNodesItems0ServiceProcessor) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ServiceProcessorTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("service_processor"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 service processor based on the context it is used
func (m *ClusterNodesItems0ServiceProcessor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFirmwareVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPV4Interface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPV6Interface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLinkStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMacAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateFirmwareVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"firmware_version", "body", string(m.FirmwareVersion)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateIPV4Interface(ctx context.Context, formats strfmt.Registry) error {

	if m.IPV4Interface != nil {
		if err := m.IPV4Interface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv4_interface")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateIPV6Interface(ctx context.Context, formats strfmt.Registry) error {

	if m.IPV6Interface != nil {
		if err := m.IPV6Interface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv6_interface")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateLinkStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"link_status", "body", string(m.LinkStatus)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateMacAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"mac_address", "body", string(m.MacAddress)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessor) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ServiceProcessor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ServiceProcessorIPV4Interface Object to setup an interface along with its default router.
//
// swagger:model ClusterNodesItems0ServiceProcessorIPV4Interface
type ClusterNodesItems0ServiceProcessorIPV4Interface struct {

	// IPv4 or IPv6 address
	// Example: 10.10.10.7
	Address string `json:"address,omitempty"`

	// The IPv4 or IPv6 address of the default router.
	// Example: 10.1.1.1
	Gateway string `json:"gateway,omitempty"`

	// netmask
	Netmask IPNetmask `json:"netmask,omitempty"`
}

// Validate validates this cluster nodes items0 service processor IP v4 interface
func (m *ClusterNodesItems0ServiceProcessorIPV4Interface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetmask(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessorIPV4Interface) validateNetmask(formats strfmt.Registry) error {
	if swag.IsZero(m.Netmask) { // not required
		return nil
	}

	if err := m.Netmask.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("service_processor" + "." + "ipv4_interface" + "." + "netmask")
		}
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 service processor IP v4 interface based on the context it is used
func (m *ClusterNodesItems0ServiceProcessorIPV4Interface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetmask(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessorIPV4Interface) contextValidateNetmask(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Netmask.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("service_processor" + "." + "ipv4_interface" + "." + "netmask")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorIPV4Interface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorIPV4Interface) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ServiceProcessorIPV4Interface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ServiceProcessorIPV6Interface Object to setup an interface along with its default router.
//
// swagger:model ClusterNodesItems0ServiceProcessorIPV6Interface
type ClusterNodesItems0ServiceProcessorIPV6Interface struct {

	// IPv4 or IPv6 address
	// Example: 10.10.10.7
	Address string `json:"address,omitempty"`

	// The IPv4 or IPv6 address of the default router.
	// Example: 10.1.1.1
	Gateway string `json:"gateway,omitempty"`

	// netmask
	Netmask IPNetmask `json:"netmask,omitempty"`
}

// Validate validates this cluster nodes items0 service processor IP v6 interface
func (m *ClusterNodesItems0ServiceProcessorIPV6Interface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetmask(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessorIPV6Interface) validateNetmask(formats strfmt.Registry) error {
	if swag.IsZero(m.Netmask) { // not required
		return nil
	}

	if err := m.Netmask.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("service_processor" + "." + "ipv6_interface" + "." + "netmask")
		}
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 service processor IP v6 interface based on the context it is used
func (m *ClusterNodesItems0ServiceProcessorIPV6Interface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetmask(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessorIPV6Interface) contextValidateNetmask(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Netmask.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("service_processor" + "." + "ipv6_interface" + "." + "netmask")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorIPV6Interface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorIPV6Interface) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ServiceProcessorIPV6Interface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0VM cluster nodes items0 VM
//
// swagger:model ClusterNodesItems0VM
type ClusterNodesItems0VM struct {

	// Cloud provider where the VM is hosted.
	// Read Only: true
	// Enum: [GoogleCloud AWS_S3 Azure_Cloud]
	ProviderType string `json:"provider_type,omitempty"`
}

// Validate validates this cluster nodes items0 VM
func (m *ClusterNodesItems0VM) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProviderType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0VmTypeProviderTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GoogleCloud","AWS_S3","Azure_Cloud"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0VmTypeProviderTypePropEnum = append(clusterNodesItems0VmTypeProviderTypePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0VM
	// ClusterNodesItems0VM
	// provider_type
	// ProviderType
	// GoogleCloud
	// END RIPPY DEBUGGING
	// ClusterNodesItems0VMProviderTypeGoogleCloud captures enum value "GoogleCloud"
	ClusterNodesItems0VMProviderTypeGoogleCloud string = "GoogleCloud"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0VM
	// ClusterNodesItems0VM
	// provider_type
	// ProviderType
	// AWS_S3
	// END RIPPY DEBUGGING
	// ClusterNodesItems0VMProviderTypeAWSS3 captures enum value "AWS_S3"
	ClusterNodesItems0VMProviderTypeAWSS3 string = "AWS_S3"

	// BEGIN RIPPY DEBUGGING
	// ClusterNodesItems0VM
	// ClusterNodesItems0VM
	// provider_type
	// ProviderType
	// Azure_Cloud
	// END RIPPY DEBUGGING
	// ClusterNodesItems0VMProviderTypeAzureCloud captures enum value "Azure_Cloud"
	ClusterNodesItems0VMProviderTypeAzureCloud string = "Azure_Cloud"
)

// prop value enum
func (m *ClusterNodesItems0VM) validateProviderTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0VmTypeProviderTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0VM) validateProviderType(formats strfmt.Registry) error {
	if swag.IsZero(m.ProviderType) { // not required
		return nil
	}

	// value enum
	if err := m.validateProviderTypeEnum("vm"+"."+"provider_type", "body", m.ProviderType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 VM based on the context it is used
func (m *ClusterNodesItems0VM) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProviderType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0VM) contextValidateProviderType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "vm"+"."+"provider_type", "body", string(m.ProviderType)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0VM) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0VM) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0VM
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0Version This returns the cluster version information.  When the cluster has more than one node, the cluster version is equivalent to the lowest of generation, major, and minor versions on all nodes.
//
// swagger:model ClusterNodesItems0Version
type ClusterNodesItems0Version struct {

	// The full cluster version string.
	// Example: NetApp Release 9.4.0: Sun Nov 05 18:20:57 UTC 2017
	// Read Only: true
	Full string `json:"full,omitempty"`

	// The generation portion of the version.
	// Example: 9
	// Read Only: true
	Generation int64 `json:"generation,omitempty"`

	// The major portion of the version.
	// Example: 4
	// Read Only: true
	Major int64 `json:"major,omitempty"`

	// The minor portion of the version.
	// Example: 0
	// Read Only: true
	Minor int64 `json:"minor,omitempty"`
}

// Validate validates this cluster nodes items0 version
func (m *ClusterNodesItems0Version) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster nodes items0 version based on the context it is used
func (m *ClusterNodesItems0Version) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFull(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeneration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMajor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMinor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Version) contextValidateFull(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"full", "body", string(m.Full)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Version) contextValidateGeneration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"generation", "body", int64(m.Generation)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Version) contextValidateMajor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"major", "body", int64(m.Major)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Version) contextValidateMinor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"minor", "body", int64(m.Minor)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0Version) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0Version) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0Version
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterStatistics These are raw performance numbers, such as IOPS latency and throughput. These numbers are aggregated across all nodes in the cluster and increase with the uptime of the cluster.
//
// swagger:model ClusterStatistics
type ClusterStatistics struct {

	// iops raw
	IopsRaw *ClusterStatisticsIopsRaw `json:"iops_raw,omitempty"`

	// latency raw
	LatencyRaw *ClusterStatisticsLatencyRaw `json:"latency_raw,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// throughput raw
	ThroughputRaw *ClusterStatisticsThroughputRaw `json:"throughput_raw,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25 11:20:13
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this cluster statistics
func (m *ClusterStatistics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIopsRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughputRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterStatistics) validateIopsRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.IopsRaw) { // not required
		return nil
	}

	if m.IopsRaw != nil {
		if err := m.IopsRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterStatistics) validateLatencyRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.LatencyRaw) { // not required
		return nil
	}

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

var clusterStatisticsTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterStatisticsTypeStatusPropEnum = append(clusterStatisticsTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// ok
	// END RIPPY DEBUGGING
	// ClusterStatisticsStatusOk captures enum value "ok"
	ClusterStatisticsStatusOk string = "ok"

	// BEGIN RIPPY DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// error
	// END RIPPY DEBUGGING
	// ClusterStatisticsStatusError captures enum value "error"
	ClusterStatisticsStatusError string = "error"

	// BEGIN RIPPY DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// partial_no_data
	// END RIPPY DEBUGGING
	// ClusterStatisticsStatusPartialNoData captures enum value "partial_no_data"
	ClusterStatisticsStatusPartialNoData string = "partial_no_data"

	// BEGIN RIPPY DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// partial_no_uuid
	// END RIPPY DEBUGGING
	// ClusterStatisticsStatusPartialNoUUID captures enum value "partial_no_uuid"
	ClusterStatisticsStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN RIPPY DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// partial_no_response
	// END RIPPY DEBUGGING
	// ClusterStatisticsStatusPartialNoResponse captures enum value "partial_no_response"
	ClusterStatisticsStatusPartialNoResponse string = "partial_no_response"

	// BEGIN RIPPY DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// partial_other_error
	// END RIPPY DEBUGGING
	// ClusterStatisticsStatusPartialOtherError captures enum value "partial_other_error"
	ClusterStatisticsStatusPartialOtherError string = "partial_other_error"

	// BEGIN RIPPY DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// negative_delta
	// END RIPPY DEBUGGING
	// ClusterStatisticsStatusNegativeDelta captures enum value "negative_delta"
	ClusterStatisticsStatusNegativeDelta string = "negative_delta"

	// BEGIN RIPPY DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// backfilled_data
	// END RIPPY DEBUGGING
	// ClusterStatisticsStatusBackfilledData captures enum value "backfilled_data"
	ClusterStatisticsStatusBackfilledData string = "backfilled_data"

	// BEGIN RIPPY DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// inconsistent_delta_time
	// END RIPPY DEBUGGING
	// ClusterStatisticsStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	ClusterStatisticsStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN RIPPY DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// inconsistent_old_data
	// END RIPPY DEBUGGING
	// ClusterStatisticsStatusInconsistentOldData captures enum value "inconsistent_old_data"
	ClusterStatisticsStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *ClusterStatistics) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterStatisticsTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterStatistics) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *ClusterStatistics) validateThroughputRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ThroughputRaw) { // not required
		return nil
	}

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterStatistics) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster statistics based on the context it is used
func (m *ClusterStatistics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIopsRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatencyRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughputRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterStatistics) contextValidateIopsRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.IopsRaw != nil {
		if err := m.IopsRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterStatistics) contextValidateLatencyRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterStatistics) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterStatistics) contextValidateThroughputRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterStatistics) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterStatistics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterStatistics) UnmarshalBinary(b []byte) error {
	var res ClusterStatistics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterStatisticsIopsRaw The number of I/O operations observed at the storage object. This can be used along with delta time to calculate the rate of I/O operations per unit of time.
//
// swagger:model ClusterStatisticsIopsRaw
type ClusterStatisticsIopsRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this cluster statistics iops raw
func (m *ClusterStatisticsIopsRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster statistics iops raw based on the context it is used
func (m *ClusterStatisticsIopsRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterStatisticsIopsRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterStatisticsIopsRaw) UnmarshalBinary(b []byte) error {
	var res ClusterStatisticsIopsRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterStatisticsLatencyRaw The raw latency in microseconds observed at the storage object. This can be divided by the raw IOPS value to calculate the average latency per I/O operation.
//
// swagger:model ClusterStatisticsLatencyRaw
type ClusterStatisticsLatencyRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this cluster statistics latency raw
func (m *ClusterStatisticsLatencyRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster statistics latency raw based on the context it is used
func (m *ClusterStatisticsLatencyRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterStatisticsLatencyRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterStatisticsLatencyRaw) UnmarshalBinary(b []byte) error {
	var res ClusterStatisticsLatencyRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterStatisticsThroughputRaw Throughput bytes observed at the storage object. This can be used along with delta time to calculate the rate of throughput bytes per unit of time.
//
// swagger:model ClusterStatisticsThroughputRaw
type ClusterStatisticsThroughputRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this cluster statistics throughput raw
func (m *ClusterStatisticsThroughputRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster statistics throughput raw based on the context it is used
func (m *ClusterStatisticsThroughputRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterStatisticsThroughputRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterStatisticsThroughputRaw) UnmarshalBinary(b []byte) error {
	var res ClusterStatisticsThroughputRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterTimezone Provides the cluster-wide time zone information that localizes time found on messages displayed on each node's:
// * console messages;
// * logging to internal ONTAP log files; and
// * localized REST API full ISO-8601 date, time, and time zone format information.
// Machine-to-machine interfaces, such as file access protocols (NFS, CIFS), block access protocols (SAN), and other protocols
// such as Manage ONTAP (ONTAPI), use second or subsecond time values that are based on world time or UTC.
//
//
// swagger:model ClusterTimezone
type ClusterTimezone struct {

	// The ONTAP time zone name or identification in either IANA time zone format "Area/Location", or an ONTAP traditional time zone.
	// </br>
	// The initial first node in cluster setting for time zone is "Etc/UTC".
	// "Etc/UTC" is the IANA timezone "Area/Location" specifier for
	// Coordinated Universal Time (UTC), which is an offset of 0.
	// ### IANA time zone format
	// The IANA time zone, formatted as "Area/Location", is based on geographic areas that have had the same time zone offset for many years.
	// </br>
	// "Location" represents a compound name using additional forward slashes.
	// </br>
	// An example of the "Area/Location" time zone is "America/New_York" and represents most of the United States Eastern Time Zone.
	// Examples of "Area/Location" with "Location" as a compound name are "America/Argentina/Buenos_Aires" and "America/Indiana/Indianapolis".
	// ### ONTAP traditional time zone
	// Examples of the traditional time zones are "EST5EDT" for the United States Eastern Time Zone and "CET" for Central European Time Zone.
	//
	// Example: America/New_York
	Name string `json:"name,omitempty"`
}

// Validate validates this cluster timezone
func (m *ClusterTimezone) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cluster timezone based on context it is used
func (m *ClusterTimezone) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterTimezone) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterTimezone) UnmarshalBinary(b []byte) error {
	var res ClusterTimezone
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterVersion This returns the cluster version information.  When the cluster has more than one node, the cluster version is equivalent to the lowest of generation, major, and minor versions on all nodes.
//
// swagger:model ClusterVersion
type ClusterVersion struct {

	// The full cluster version string.
	// Example: NetApp Release 9.4.0: Sun Nov 05 18:20:57 UTC 2017
	// Read Only: true
	Full string `json:"full,omitempty"`

	// The generation portion of the version.
	// Example: 9
	// Read Only: true
	Generation int64 `json:"generation,omitempty"`

	// The major portion of the version.
	// Example: 4
	// Read Only: true
	Major int64 `json:"major,omitempty"`

	// The minor portion of the version.
	// Example: 0
	// Read Only: true
	Minor int64 `json:"minor,omitempty"`
}

// Validate validates this cluster version
func (m *ClusterVersion) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster version based on the context it is used
func (m *ClusterVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFull(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeneration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMajor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMinor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterVersion) contextValidateFull(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"full", "body", string(m.Full)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterVersion) contextValidateGeneration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"generation", "body", int64(m.Generation)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterVersion) contextValidateMajor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"major", "body", int64(m.Major)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterVersion) contextValidateMinor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"minor", "body", int64(m.Minor)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterVersion) UnmarshalBinary(b []byte) error {
	var res ClusterVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HELLO RIPPY
